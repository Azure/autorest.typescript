/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { PagedAsyncIterableIterator, PageSettings } from "@azure/core-paging";
import { MongoDBResources } from "../operationsInterfaces";
import * as coreClient from "@azure/core-client";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
import { CosmosDBManagementClient } from "../cosmosDBManagementClient";
import {
  SimplePollerLike,
  OperationState,
  createHttpPoller,
} from "@azure/core-lro";
import { createLroSpec } from "../lroImpl";
import {
  MongoDBDatabaseGetResults,
  MongoDBResourcesListMongoDBDatabasesOptionalParams,
  MongoDBResourcesListMongoDBDatabasesResponse,
  MongoDBCollectionGetResults,
  MongoDBResourcesListMongoDBCollectionsOptionalParams,
  MongoDBResourcesListMongoDBCollectionsResponse,
  MongoDBResourcesGetMongoDBDatabaseOptionalParams,
  MongoDBResourcesGetMongoDBDatabaseResponse,
  MongoDBDatabaseCreateUpdateParameters,
  MongoDBResourcesCreateUpdateMongoDBDatabaseOptionalParams,
  MongoDBResourcesCreateUpdateMongoDBDatabaseResponse,
  MongoDBResourcesDeleteMongoDBDatabaseOptionalParams,
  MongoDBResourcesGetMongoDBDatabaseThroughputOptionalParams,
  MongoDBResourcesGetMongoDBDatabaseThroughputResponse,
  ThroughputSettingsUpdateParameters,
  MongoDBResourcesUpdateMongoDBDatabaseThroughputOptionalParams,
  MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse,
  MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleOptionalParams,
  MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse,
  MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputOptionalParams,
  MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse,
  MongoDBResourcesGetMongoDBCollectionOptionalParams,
  MongoDBResourcesGetMongoDBCollectionResponse,
  MongoDBCollectionCreateUpdateParameters,
  MongoDBResourcesCreateUpdateMongoDBCollectionOptionalParams,
  MongoDBResourcesCreateUpdateMongoDBCollectionResponse,
  MongoDBResourcesDeleteMongoDBCollectionOptionalParams,
  MongoDBResourcesGetMongoDBCollectionThroughputOptionalParams,
  MongoDBResourcesGetMongoDBCollectionThroughputResponse,
  MongoDBResourcesUpdateMongoDBCollectionThroughputOptionalParams,
  MongoDBResourcesUpdateMongoDBCollectionThroughputResponse,
  MongoDBResourcesMigrateMongoDBCollectionToAutoscaleOptionalParams,
  MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse,
  MongoDBResourcesMigrateMongoDBCollectionToManualThroughputOptionalParams,
  MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse,
  ContinuousBackupRestoreLocation,
  MongoDBResourcesRetrieveContinuousBackupInformationOptionalParams,
  MongoDBResourcesRetrieveContinuousBackupInformationResponse,
} from "../models";

/// <reference lib="esnext.asynciterable" />
/** Class containing MongoDBResources operations. */
export class MongoDBResourcesImpl implements MongoDBResources {
  private readonly client: CosmosDBManagementClient;

  /**
   * Initialize a new instance of the class MongoDBResources class.
   * @param client Reference to the service client
   */
  constructor(client: CosmosDBManagementClient) {
    this.client = client;
  }

  /**
   * Lists the MongoDB databases under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  public listMongoDBDatabases(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoDBDatabasesOptionalParams,
  ): PagedAsyncIterableIterator<MongoDBDatabaseGetResults> {
    const iter = this.listMongoDBDatabasesPagingAll(
      resourceGroupName,
      accountName,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listMongoDBDatabasesPagingPage(
          resourceGroupName,
          accountName,
          options,
          settings,
        );
      },
    };
  }

  private async *listMongoDBDatabasesPagingPage(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoDBDatabasesOptionalParams,
    _settings?: PageSettings,
  ): AsyncIterableIterator<MongoDBDatabaseGetResults[]> {
    let result: MongoDBResourcesListMongoDBDatabasesResponse;
    result = await this._listMongoDBDatabases(
      resourceGroupName,
      accountName,
      options,
    );
    yield result.value || [];
  }

  private async *listMongoDBDatabasesPagingAll(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoDBDatabasesOptionalParams,
  ): AsyncIterableIterator<MongoDBDatabaseGetResults> {
    for await (const page of this.listMongoDBDatabasesPagingPage(
      resourceGroupName,
      accountName,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * Lists the MongoDB collection under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  public listMongoDBCollections(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesListMongoDBCollectionsOptionalParams,
  ): PagedAsyncIterableIterator<MongoDBCollectionGetResults> {
    const iter = this.listMongoDBCollectionsPagingAll(
      resourceGroupName,
      accountName,
      databaseName,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listMongoDBCollectionsPagingPage(
          resourceGroupName,
          accountName,
          databaseName,
          options,
          settings,
        );
      },
    };
  }

  private async *listMongoDBCollectionsPagingPage(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesListMongoDBCollectionsOptionalParams,
    _settings?: PageSettings,
  ): AsyncIterableIterator<MongoDBCollectionGetResults[]> {
    let result: MongoDBResourcesListMongoDBCollectionsResponse;
    result = await this._listMongoDBCollections(
      resourceGroupName,
      accountName,
      databaseName,
      options,
    );
    yield result.value || [];
  }

  private async *listMongoDBCollectionsPagingAll(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesListMongoDBCollectionsOptionalParams,
  ): AsyncIterableIterator<MongoDBCollectionGetResults> {
    for await (const page of this.listMongoDBCollectionsPagingPage(
      resourceGroupName,
      accountName,
      databaseName,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * Lists the MongoDB databases under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  private _listMongoDBDatabases(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoDBDatabasesOptionalParams,
  ): Promise<MongoDBResourcesListMongoDBDatabasesResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, options },
      listMongoDBDatabasesOperationSpec,
    );
  }

  /**
   * Gets the MongoDB databases under an existing Azure Cosmos DB database account with the provided
   * name.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  getMongoDBDatabase(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesGetMongoDBDatabaseOptionalParams,
  ): Promise<MongoDBResourcesGetMongoDBDatabaseResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, options },
      getMongoDBDatabaseOperationSpec,
    );
  }

  /**
   * Create or updates Azure Cosmos DB MongoDB database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param createUpdateMongoDBDatabaseParameters The parameters to provide for the current MongoDB
   *                                              database.
   * @param options The options parameters.
   */
  async beginCreateUpdateMongoDBDatabase(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    createUpdateMongoDBDatabaseParameters: MongoDBDatabaseCreateUpdateParameters,
    options?: MongoDBResourcesCreateUpdateMongoDBDatabaseOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<MongoDBResourcesCreateUpdateMongoDBDatabaseResponse>,
      MongoDBResourcesCreateUpdateMongoDBDatabaseResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<MongoDBResourcesCreateUpdateMongoDBDatabaseResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        accountName,
        databaseName,
        createUpdateMongoDBDatabaseParameters,
        options,
      },
      spec: createUpdateMongoDBDatabaseOperationSpec,
    });
    const poller = await createHttpPoller<
      MongoDBResourcesCreateUpdateMongoDBDatabaseResponse,
      OperationState<MongoDBResourcesCreateUpdateMongoDBDatabaseResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Create or updates Azure Cosmos DB MongoDB database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param createUpdateMongoDBDatabaseParameters The parameters to provide for the current MongoDB
   *                                              database.
   * @param options The options parameters.
   */
  async beginCreateUpdateMongoDBDatabaseAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    createUpdateMongoDBDatabaseParameters: MongoDBDatabaseCreateUpdateParameters,
    options?: MongoDBResourcesCreateUpdateMongoDBDatabaseOptionalParams,
  ): Promise<MongoDBResourcesCreateUpdateMongoDBDatabaseResponse> {
    const poller = await this.beginCreateUpdateMongoDBDatabase(
      resourceGroupName,
      accountName,
      databaseName,
      createUpdateMongoDBDatabaseParameters,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Deletes an existing Azure Cosmos DB MongoDB database.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginDeleteMongoDBDatabase(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesDeleteMongoDBDatabaseOptionalParams,
  ): Promise<SimplePollerLike<OperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { resourceGroupName, accountName, databaseName, options },
      spec: deleteMongoDBDatabaseOperationSpec,
    });
    const poller = await createHttpPoller<void, OperationState<void>>(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Deletes an existing Azure Cosmos DB MongoDB database.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginDeleteMongoDBDatabaseAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesDeleteMongoDBDatabaseOptionalParams,
  ): Promise<void> {
    const poller = await this.beginDeleteMongoDBDatabase(
      resourceGroupName,
      accountName,
      databaseName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Gets the RUs per second of the MongoDB database under an existing Azure Cosmos DB database account
   * with the provided name.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  getMongoDBDatabaseThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesGetMongoDBDatabaseThroughputOptionalParams,
  ): Promise<MongoDBResourcesGetMongoDBDatabaseThroughputResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, options },
      getMongoDBDatabaseThroughputOperationSpec,
    );
  }

  /**
   * Update RUs per second of the an Azure Cosmos DB MongoDB database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
   *                                   MongoDB database.
   * @param options The options parameters.
   */
  async beginUpdateMongoDBDatabaseThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    updateThroughputParameters: ThroughputSettingsUpdateParameters,
    options?: MongoDBResourcesUpdateMongoDBDatabaseThroughputOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse>,
      MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        accountName,
        databaseName,
        updateThroughputParameters,
        options,
      },
      spec: updateMongoDBDatabaseThroughputOperationSpec,
    });
    const poller = await createHttpPoller<
      MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse,
      OperationState<MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Update RUs per second of the an Azure Cosmos DB MongoDB database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
   *                                   MongoDB database.
   * @param options The options parameters.
   */
  async beginUpdateMongoDBDatabaseThroughputAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    updateThroughputParameters: ThroughputSettingsUpdateParameters,
    options?: MongoDBResourcesUpdateMongoDBDatabaseThroughputOptionalParams,
  ): Promise<MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse> {
    const poller = await this.beginUpdateMongoDBDatabaseThroughput(
      resourceGroupName,
      accountName,
      databaseName,
      updateThroughputParameters,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB database from manual throughput to autoscale
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBDatabaseToAutoscale(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse>,
      MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { resourceGroupName, accountName, databaseName, options },
      spec: migrateMongoDBDatabaseToAutoscaleOperationSpec,
    });
    const poller = await createHttpPoller<
      MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse,
      OperationState<MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB database from manual throughput to autoscale
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBDatabaseToAutoscaleAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleOptionalParams,
  ): Promise<MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse> {
    const poller = await this.beginMigrateMongoDBDatabaseToAutoscale(
      resourceGroupName,
      accountName,
      databaseName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB database from autoscale to manual throughput
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBDatabaseToManualThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse>,
      MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { resourceGroupName, accountName, databaseName, options },
      spec: migrateMongoDBDatabaseToManualThroughputOperationSpec,
    });
    const poller = await createHttpPoller<
      MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse,
      OperationState<MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB database from autoscale to manual throughput
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBDatabaseToManualThroughputAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputOptionalParams,
  ): Promise<MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse> {
    const poller = await this.beginMigrateMongoDBDatabaseToManualThroughput(
      resourceGroupName,
      accountName,
      databaseName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Lists the MongoDB collection under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  private _listMongoDBCollections(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesListMongoDBCollectionsOptionalParams,
  ): Promise<MongoDBResourcesListMongoDBCollectionsResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, options },
      listMongoDBCollectionsOperationSpec,
    );
  }

  /**
   * Gets the MongoDB collection under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  getMongoDBCollection(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesGetMongoDBCollectionOptionalParams,
  ): Promise<MongoDBResourcesGetMongoDBCollectionResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, collectionName, options },
      getMongoDBCollectionOperationSpec,
    );
  }

  /**
   * Create or update an Azure Cosmos DB MongoDB Collection
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param createUpdateMongoDBCollectionParameters The parameters to provide for the current MongoDB
   *                                                Collection.
   * @param options The options parameters.
   */
  async beginCreateUpdateMongoDBCollection(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    createUpdateMongoDBCollectionParameters: MongoDBCollectionCreateUpdateParameters,
    options?: MongoDBResourcesCreateUpdateMongoDBCollectionOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<MongoDBResourcesCreateUpdateMongoDBCollectionResponse>,
      MongoDBResourcesCreateUpdateMongoDBCollectionResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<MongoDBResourcesCreateUpdateMongoDBCollectionResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        accountName,
        databaseName,
        collectionName,
        createUpdateMongoDBCollectionParameters,
        options,
      },
      spec: createUpdateMongoDBCollectionOperationSpec,
    });
    const poller = await createHttpPoller<
      MongoDBResourcesCreateUpdateMongoDBCollectionResponse,
      OperationState<MongoDBResourcesCreateUpdateMongoDBCollectionResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Create or update an Azure Cosmos DB MongoDB Collection
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param createUpdateMongoDBCollectionParameters The parameters to provide for the current MongoDB
   *                                                Collection.
   * @param options The options parameters.
   */
  async beginCreateUpdateMongoDBCollectionAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    createUpdateMongoDBCollectionParameters: MongoDBCollectionCreateUpdateParameters,
    options?: MongoDBResourcesCreateUpdateMongoDBCollectionOptionalParams,
  ): Promise<MongoDBResourcesCreateUpdateMongoDBCollectionResponse> {
    const poller = await this.beginCreateUpdateMongoDBCollection(
      resourceGroupName,
      accountName,
      databaseName,
      collectionName,
      createUpdateMongoDBCollectionParameters,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Deletes an existing Azure Cosmos DB MongoDB Collection.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  async beginDeleteMongoDBCollection(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesDeleteMongoDBCollectionOptionalParams,
  ): Promise<SimplePollerLike<OperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        accountName,
        databaseName,
        collectionName,
        options,
      },
      spec: deleteMongoDBCollectionOperationSpec,
    });
    const poller = await createHttpPoller<void, OperationState<void>>(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Deletes an existing Azure Cosmos DB MongoDB Collection.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  async beginDeleteMongoDBCollectionAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesDeleteMongoDBCollectionOptionalParams,
  ): Promise<void> {
    const poller = await this.beginDeleteMongoDBCollection(
      resourceGroupName,
      accountName,
      databaseName,
      collectionName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Gets the RUs per second of the MongoDB collection under an existing Azure Cosmos DB database account
   * with the provided name.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  getMongoDBCollectionThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesGetMongoDBCollectionThroughputOptionalParams,
  ): Promise<MongoDBResourcesGetMongoDBCollectionThroughputResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, collectionName, options },
      getMongoDBCollectionThroughputOperationSpec,
    );
  }

  /**
   * Update the RUs per second of an Azure Cosmos DB MongoDB collection
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
   *                                   MongoDB collection.
   * @param options The options parameters.
   */
  async beginUpdateMongoDBCollectionThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    updateThroughputParameters: ThroughputSettingsUpdateParameters,
    options?: MongoDBResourcesUpdateMongoDBCollectionThroughputOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<MongoDBResourcesUpdateMongoDBCollectionThroughputResponse>,
      MongoDBResourcesUpdateMongoDBCollectionThroughputResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<MongoDBResourcesUpdateMongoDBCollectionThroughputResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        accountName,
        databaseName,
        collectionName,
        updateThroughputParameters,
        options,
      },
      spec: updateMongoDBCollectionThroughputOperationSpec,
    });
    const poller = await createHttpPoller<
      MongoDBResourcesUpdateMongoDBCollectionThroughputResponse,
      OperationState<MongoDBResourcesUpdateMongoDBCollectionThroughputResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Update the RUs per second of an Azure Cosmos DB MongoDB collection
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
   *                                   MongoDB collection.
   * @param options The options parameters.
   */
  async beginUpdateMongoDBCollectionThroughputAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    updateThroughputParameters: ThroughputSettingsUpdateParameters,
    options?: MongoDBResourcesUpdateMongoDBCollectionThroughputOptionalParams,
  ): Promise<MongoDBResourcesUpdateMongoDBCollectionThroughputResponse> {
    const poller = await this.beginUpdateMongoDBCollectionThroughput(
      resourceGroupName,
      accountName,
      databaseName,
      collectionName,
      updateThroughputParameters,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB collection from manual throughput to autoscale
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBCollectionToAutoscale(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesMigrateMongoDBCollectionToAutoscaleOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse>,
      MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        accountName,
        databaseName,
        collectionName,
        options,
      },
      spec: migrateMongoDBCollectionToAutoscaleOperationSpec,
    });
    const poller = await createHttpPoller<
      MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse,
      OperationState<MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB collection from manual throughput to autoscale
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBCollectionToAutoscaleAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesMigrateMongoDBCollectionToAutoscaleOptionalParams,
  ): Promise<MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse> {
    const poller = await this.beginMigrateMongoDBCollectionToAutoscale(
      resourceGroupName,
      accountName,
      databaseName,
      collectionName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB collection from autoscale to manual throughput
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBCollectionToManualThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesMigrateMongoDBCollectionToManualThroughputOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse>,
      MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        accountName,
        databaseName,
        collectionName,
        options,
      },
      spec: migrateMongoDBCollectionToManualThroughputOperationSpec,
    });
    const poller = await createHttpPoller<
      MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse,
      OperationState<MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB collection from autoscale to manual throughput
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBCollectionToManualThroughputAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesMigrateMongoDBCollectionToManualThroughputOptionalParams,
  ): Promise<MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse> {
    const poller = await this.beginMigrateMongoDBCollectionToManualThroughput(
      resourceGroupName,
      accountName,
      databaseName,
      collectionName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Retrieves continuous backup information for a Mongodb collection.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param location The name of the continuous backup restore location.
   * @param options The options parameters.
   */
  async beginRetrieveContinuousBackupInformation(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    location: ContinuousBackupRestoreLocation,
    options?: MongoDBResourcesRetrieveContinuousBackupInformationOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<MongoDBResourcesRetrieveContinuousBackupInformationResponse>,
      MongoDBResourcesRetrieveContinuousBackupInformationResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<MongoDBResourcesRetrieveContinuousBackupInformationResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        accountName,
        databaseName,
        collectionName,
        location,
        options,
      },
      spec: retrieveContinuousBackupInformationOperationSpec,
    });
    const poller = await createHttpPoller<
      MongoDBResourcesRetrieveContinuousBackupInformationResponse,
      OperationState<MongoDBResourcesRetrieveContinuousBackupInformationResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      resourceLocationConfig: "location",
    });
    await poller.poll();
    return poller;
  }

  /**
   * Retrieves continuous backup information for a Mongodb collection.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param location The name of the continuous backup restore location.
   * @param options The options parameters.
   */
  async beginRetrieveContinuousBackupInformationAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    location: ContinuousBackupRestoreLocation,
    options?: MongoDBResourcesRetrieveContinuousBackupInformationOptionalParams,
  ): Promise<MongoDBResourcesRetrieveContinuousBackupInformationResponse> {
    const poller = await this.beginRetrieveContinuousBackupInformation(
      resourceGroupName,
      accountName,
      databaseName,
      collectionName,
      location,
      options,
    );
    return poller.pollUntilDone();
  }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);

const listMongoDBDatabasesOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.MongoDBDatabaseListResult,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const getMongoDBDatabaseOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.MongoDBDatabaseGetResults,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const createUpdateMongoDBDatabaseOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.MongoDBDatabaseGetResults,
    },
    201: {
      bodyMapper: Mappers.MongoDBDatabaseGetResults,
    },
    202: {
      bodyMapper: Mappers.MongoDBDatabaseGetResults,
    },
    204: {
      bodyMapper: Mappers.MongoDBDatabaseGetResults,
    },
  },
  requestBody: Parameters.createUpdateMongoDBDatabaseParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const deleteMongoDBDatabaseOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}",
  httpMethod: "DELETE",
  responses: { 200: {}, 201: {}, 202: {}, 204: {} },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
  ],
  serializer,
};
const getMongoDBDatabaseThroughputOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/throughputSettings/default",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const updateMongoDBDatabaseThroughputOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/throughputSettings/default",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults,
    },
    201: {
      bodyMapper: Mappers.ThroughputSettingsGetResults,
    },
    202: {
      bodyMapper: Mappers.ThroughputSettingsGetResults,
    },
    204: {
      bodyMapper: Mappers.ThroughputSettingsGetResults,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  requestBody: Parameters.updateThroughputParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const migrateMongoDBDatabaseToAutoscaleOperationSpec: coreClient.OperationSpec =
  {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/throughputSettings/default/migrateToAutoscale",
    httpMethod: "POST",
    responses: {
      200: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      201: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      202: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      204: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      default: {
        bodyMapper: Mappers.CloudError,
      },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
      Parameters.$host,
      Parameters.subscriptionId,
      Parameters.resourceGroupName,
      Parameters.accountName,
      Parameters.databaseName,
    ],
    headerParameters: [Parameters.accept],
    serializer,
  };
const migrateMongoDBDatabaseToManualThroughputOperationSpec: coreClient.OperationSpec =
  {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/throughputSettings/default/migrateToManualThroughput",
    httpMethod: "POST",
    responses: {
      200: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      201: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      202: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      204: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      default: {
        bodyMapper: Mappers.CloudError,
      },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
      Parameters.$host,
      Parameters.subscriptionId,
      Parameters.resourceGroupName,
      Parameters.accountName,
      Parameters.databaseName,
    ],
    headerParameters: [Parameters.accept],
    serializer,
  };
const listMongoDBCollectionsOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.MongoDBCollectionListResult,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const getMongoDBCollectionOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.MongoDBCollectionGetResults,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.collectionName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const createUpdateMongoDBCollectionOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.MongoDBCollectionGetResults,
    },
    201: {
      bodyMapper: Mappers.MongoDBCollectionGetResults,
    },
    202: {
      bodyMapper: Mappers.MongoDBCollectionGetResults,
    },
    204: {
      bodyMapper: Mappers.MongoDBCollectionGetResults,
    },
  },
  requestBody: Parameters.createUpdateMongoDBCollectionParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.collectionName,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const deleteMongoDBCollectionOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}",
  httpMethod: "DELETE",
  responses: { 200: {}, 201: {}, 202: {}, 204: {} },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.collectionName,
  ],
  serializer,
};
const getMongoDBCollectionThroughputOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/throughputSettings/default",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.collectionName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const updateMongoDBCollectionThroughputOperationSpec: coreClient.OperationSpec =
  {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/throughputSettings/default",
    httpMethod: "PUT",
    responses: {
      200: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      201: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      202: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      204: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
    },
    requestBody: Parameters.updateThroughputParameters,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
      Parameters.$host,
      Parameters.subscriptionId,
      Parameters.resourceGroupName,
      Parameters.accountName,
      Parameters.databaseName,
      Parameters.collectionName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
  };
const migrateMongoDBCollectionToAutoscaleOperationSpec: coreClient.OperationSpec =
  {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/throughputSettings/default/migrateToAutoscale",
    httpMethod: "POST",
    responses: {
      200: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      201: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      202: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      204: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      default: {
        bodyMapper: Mappers.CloudError,
      },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
      Parameters.$host,
      Parameters.subscriptionId,
      Parameters.resourceGroupName,
      Parameters.accountName,
      Parameters.databaseName,
      Parameters.collectionName,
    ],
    headerParameters: [Parameters.accept],
    serializer,
  };
const migrateMongoDBCollectionToManualThroughputOperationSpec: coreClient.OperationSpec =
  {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/throughputSettings/default/migrateToManualThroughput",
    httpMethod: "POST",
    responses: {
      200: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      201: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      202: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      204: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      default: {
        bodyMapper: Mappers.CloudError,
      },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
      Parameters.$host,
      Parameters.subscriptionId,
      Parameters.resourceGroupName,
      Parameters.accountName,
      Parameters.databaseName,
      Parameters.collectionName,
    ],
    headerParameters: [Parameters.accept],
    serializer,
  };
const retrieveContinuousBackupInformationOperationSpec: coreClient.OperationSpec =
  {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/retrieveContinuousBackupInformation",
    httpMethod: "POST",
    responses: {
      200: {
        bodyMapper: Mappers.BackupInformation,
      },
      201: {
        bodyMapper: Mappers.BackupInformation,
      },
      202: {
        bodyMapper: Mappers.BackupInformation,
      },
      204: {
        bodyMapper: Mappers.BackupInformation,
      },
      default: {
        bodyMapper: Mappers.CloudError,
      },
    },
    requestBody: Parameters.location,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
      Parameters.$host,
      Parameters.subscriptionId,
      Parameters.resourceGroupName,
      Parameters.accountName,
      Parameters.databaseName,
      Parameters.collectionName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
  };
