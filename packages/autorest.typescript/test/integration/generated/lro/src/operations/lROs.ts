/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { tracingClient } from "../tracing";
import { LROs } from "../operationsInterfaces";
import * as coreClient from "@azure/core-client";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
import { LROClient } from "../lROClient";
import {
  SimplePollerLike,
  OperationState,
  createHttpPoller,
} from "@azure/core-lro";
import { createLroSpec } from "../lroImpl";
import {
  LROsPut200SucceededOptionalParams,
  LROsPut200SucceededResponse,
  LROsPatch200SucceededIgnoreHeadersOptionalParams,
  LROsPatch200SucceededIgnoreHeadersResponse,
  LROsPatch201RetryWithAsyncHeaderOptionalParams,
  LROsPatch201RetryWithAsyncHeaderResponse,
  LROsPatch202RetryWithAsyncAndLocationHeaderOptionalParams,
  LROsPatch202RetryWithAsyncAndLocationHeaderResponse,
  LROsPut201SucceededOptionalParams,
  LROsPut201SucceededResponse,
  LROsPost202ListOptionalParams,
  LROsPost202ListResponse,
  LROsPut200SucceededNoStateOptionalParams,
  LROsPut200SucceededNoStateResponse,
  LROsPut202Retry200OptionalParams,
  LROsPut202Retry200Response,
  LROsPut201CreatingSucceeded200OptionalParams,
  LROsPut201CreatingSucceeded200Response,
  LROsPut200UpdatingSucceeded204OptionalParams,
  LROsPut200UpdatingSucceeded204Response,
  LROsPut201CreatingFailed200OptionalParams,
  LROsPut201CreatingFailed200Response,
  LROsPut200Acceptedcanceled200OptionalParams,
  LROsPut200Acceptedcanceled200Response,
  LROsPutNoHeaderInRetryOptionalParams,
  LROsPutNoHeaderInRetryResponse,
  LROsPutAsyncRetrySucceededOptionalParams,
  LROsPutAsyncRetrySucceededResponse,
  LROsPutAsyncNoRetrySucceededOptionalParams,
  LROsPutAsyncNoRetrySucceededResponse,
  LROsPutAsyncRetryFailedOptionalParams,
  LROsPutAsyncRetryFailedResponse,
  LROsPutAsyncNoRetrycanceledOptionalParams,
  LROsPutAsyncNoRetrycanceledResponse,
  LROsPutAsyncNoHeaderInRetryOptionalParams,
  LROsPutAsyncNoHeaderInRetryResponse,
  LROsPutNonResourceOptionalParams,
  LROsPutNonResourceResponse,
  LROsPutAsyncNonResourceOptionalParams,
  LROsPutAsyncNonResourceResponse,
  LROsPutSubResourceOptionalParams,
  LROsPutSubResourceResponse,
  LROsPutAsyncSubResourceOptionalParams,
  LROsPutAsyncSubResourceResponse,
  LROsDeleteProvisioning202Accepted200SucceededOptionalParams,
  LROsDeleteProvisioning202Accepted200SucceededResponse,
  LROsDeleteProvisioning202DeletingFailed200OptionalParams,
  LROsDeleteProvisioning202DeletingFailed200Response,
  LROsDeleteProvisioning202Deletingcanceled200OptionalParams,
  LROsDeleteProvisioning202Deletingcanceled200Response,
  LROsDelete204SucceededOptionalParams,
  LROsDelete202Retry200OptionalParams,
  LROsDelete202Retry200Response,
  LROsDelete202NoRetry204OptionalParams,
  LROsDelete202NoRetry204Response,
  LROsDeleteNoHeaderInRetryOptionalParams,
  LROsDeleteNoHeaderInRetryResponse,
  LROsDeleteAsyncNoHeaderInRetryOptionalParams,
  LROsDeleteAsyncNoHeaderInRetryResponse,
  LROsDeleteAsyncRetrySucceededOptionalParams,
  LROsDeleteAsyncRetrySucceededResponse,
  LROsDeleteAsyncNoRetrySucceededOptionalParams,
  LROsDeleteAsyncNoRetrySucceededResponse,
  LROsDeleteAsyncRetryFailedOptionalParams,
  LROsDeleteAsyncRetryFailedResponse,
  LROsDeleteAsyncRetrycanceledOptionalParams,
  LROsDeleteAsyncRetrycanceledResponse,
  LROsPost200WithPayloadOptionalParams,
  LROsPost200WithPayloadResponse,
  LROsPost202Retry200OptionalParams,
  LROsPost202Retry200Response,
  LROsPost202NoRetry204OptionalParams,
  LROsPost202NoRetry204Response,
  LROsPostDoubleHeadersFinalLocationGetOptionalParams,
  LROsPostDoubleHeadersFinalLocationGetResponse,
  LROsPostDoubleHeadersFinalAzureHeaderGetOptionalParams,
  LROsPostDoubleHeadersFinalAzureHeaderGetResponse,
  LROsPostDoubleHeadersFinalAzureHeaderGetDefaultOptionalParams,
  LROsPostDoubleHeadersFinalAzureHeaderGetDefaultResponse,
  LROsPostAsyncRetrySucceededOptionalParams,
  LROsPostAsyncRetrySucceededResponse,
  LROsPostAsyncNoRetrySucceededOptionalParams,
  LROsPostAsyncNoRetrySucceededResponse,
  LROsPostAsyncRetryFailedOptionalParams,
  LROsPostAsyncRetryFailedResponse,
  LROsPostAsyncRetrycanceledOptionalParams,
  LROsPostAsyncRetrycanceledResponse,
} from "../models";

/** Class containing LROs operations. */
export class LROsImpl implements LROs {
  private readonly client: LROClient;

  /**
   * Initialize a new instance of the class LROs class.
   * @param client Reference to the service client
   */
  constructor(client: LROClient) {
    this.client = client;
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Succeeded’.
   * @param options The options parameters.
   */
  async beginPut200Succeeded(
    options?: LROsPut200SucceededOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPut200SucceededResponse>,
      LROsPut200SucceededResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPut200SucceededResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPut200Succeeded",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPut200SucceededResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: put200SucceededOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPut200SucceededResponse,
      OperationState<LROsPut200SucceededResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Succeeded’.
   * @param options The options parameters.
   */
  async beginPut200SucceededAndWait(
    options?: LROsPut200SucceededOptionalParams,
  ): Promise<LROsPut200SucceededResponse> {
    const poller = await this.beginPut200Succeeded(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 200 to the initial request with location header. We
   * should not have any subsequent calls after receiving this first response.
   * @param options The options parameters.
   */
  async beginPatch200SucceededIgnoreHeaders(
    options?: LROsPatch200SucceededIgnoreHeadersOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPatch200SucceededIgnoreHeadersResponse>,
      LROsPatch200SucceededIgnoreHeadersResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPatch200SucceededIgnoreHeadersResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPatch200SucceededIgnoreHeaders",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPatch200SucceededIgnoreHeadersResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: patch200SucceededIgnoreHeadersOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPatch200SucceededIgnoreHeadersResponse,
      OperationState<LROsPatch200SucceededIgnoreHeadersResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running put request, service returns a 200 to the initial request with location header. We
   * should not have any subsequent calls after receiving this first response.
   * @param options The options parameters.
   */
  async beginPatch200SucceededIgnoreHeadersAndWait(
    options?: LROsPatch200SucceededIgnoreHeadersOptionalParams,
  ): Promise<LROsPatch200SucceededIgnoreHeadersResponse> {
    const poller = await this.beginPatch200SucceededIgnoreHeaders(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running patch request, service returns a 201 to the initial request with async header.
   * @param options The options parameters.
   */
  async beginPatch201RetryWithAsyncHeader(
    options?: LROsPatch201RetryWithAsyncHeaderOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPatch201RetryWithAsyncHeaderResponse>,
      LROsPatch201RetryWithAsyncHeaderResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPatch201RetryWithAsyncHeaderResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPatch201RetryWithAsyncHeader",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPatch201RetryWithAsyncHeaderResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: patch201RetryWithAsyncHeaderOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPatch201RetryWithAsyncHeaderResponse,
      OperationState<LROsPatch201RetryWithAsyncHeaderResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running patch request, service returns a 201 to the initial request with async header.
   * @param options The options parameters.
   */
  async beginPatch201RetryWithAsyncHeaderAndWait(
    options?: LROsPatch201RetryWithAsyncHeaderOptionalParams,
  ): Promise<LROsPatch201RetryWithAsyncHeaderResponse> {
    const poller = await this.beginPatch201RetryWithAsyncHeader(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running patch request, service returns a 202 to the initial request with async and location
   * header.
   * @param options The options parameters.
   */
  async beginPatch202RetryWithAsyncAndLocationHeader(
    options?: LROsPatch202RetryWithAsyncAndLocationHeaderOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPatch202RetryWithAsyncAndLocationHeaderResponse>,
      LROsPatch202RetryWithAsyncAndLocationHeaderResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPatch202RetryWithAsyncAndLocationHeaderResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPatch202RetryWithAsyncAndLocationHeader",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPatch202RetryWithAsyncAndLocationHeaderResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: patch202RetryWithAsyncAndLocationHeaderOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPatch202RetryWithAsyncAndLocationHeaderResponse,
      OperationState<LROsPatch202RetryWithAsyncAndLocationHeaderResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running patch request, service returns a 202 to the initial request with async and location
   * header.
   * @param options The options parameters.
   */
  async beginPatch202RetryWithAsyncAndLocationHeaderAndWait(
    options?: LROsPatch202RetryWithAsyncAndLocationHeaderOptionalParams,
  ): Promise<LROsPatch202RetryWithAsyncAndLocationHeaderResponse> {
    const poller =
      await this.beginPatch202RetryWithAsyncAndLocationHeader(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 201 to the initial request, with an entity that contains
   * ProvisioningState=’Succeeded’.
   * @param options The options parameters.
   */
  async beginPut201Succeeded(
    options?: LROsPut201SucceededOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPut201SucceededResponse>,
      LROsPut201SucceededResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPut201SucceededResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPut201Succeeded",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPut201SucceededResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: put201SucceededOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPut201SucceededResponse,
      OperationState<LROsPut201SucceededResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running put request, service returns a 201 to the initial request, with an entity that contains
   * ProvisioningState=’Succeeded’.
   * @param options The options parameters.
   */
  async beginPut201SucceededAndWait(
    options?: LROsPut201SucceededOptionalParams,
  ): Promise<LROsPut201SucceededResponse> {
    const poller = await this.beginPut201Succeeded(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 202 with empty body to first request, returns a 200 with
   * body [{ 'id': '100', 'name': 'foo' }].
   * @param options The options parameters.
   */
  async beginPost202List(
    options?: LROsPost202ListOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPost202ListResponse>,
      LROsPost202ListResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPost202ListResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPost202List",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPost202ListResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: post202ListOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPost202ListResponse,
      OperationState<LROsPost202ListResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running put request, service returns a 202 with empty body to first request, returns a 200 with
   * body [{ 'id': '100', 'name': 'foo' }].
   * @param options The options parameters.
   */
  async beginPost202ListAndWait(
    options?: LROsPost202ListOptionalParams,
  ): Promise<LROsPost202ListResponse> {
    const poller = await this.beginPost202List(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that does not
   * contain ProvisioningState=’Succeeded’.
   * @param options The options parameters.
   */
  async beginPut200SucceededNoState(
    options?: LROsPut200SucceededNoStateOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPut200SucceededNoStateResponse>,
      LROsPut200SucceededNoStateResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPut200SucceededNoStateResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPut200SucceededNoState",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPut200SucceededNoStateResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: put200SucceededNoStateOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPut200SucceededNoStateResponse,
      OperationState<LROsPut200SucceededNoStateResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that does not
   * contain ProvisioningState=’Succeeded’.
   * @param options The options parameters.
   */
  async beginPut200SucceededNoStateAndWait(
    options?: LROsPut200SucceededNoStateOptionalParams,
  ): Promise<LROsPut200SucceededNoStateResponse> {
    const poller = await this.beginPut200SucceededNoState(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 202 to the initial request, with a location header that
   * points to a polling URL that returns a 200 and an entity that doesn't contains ProvisioningState
   * @param options The options parameters.
   */
  async beginPut202Retry200(
    options?: LROsPut202Retry200OptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPut202Retry200Response>,
      LROsPut202Retry200Response
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPut202Retry200Response> => {
      return tracingClient.withSpan(
        "LROClient.beginPut202Retry200",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPut202Retry200Response>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: put202Retry200OperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPut202Retry200Response,
      OperationState<LROsPut202Retry200Response>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running put request, service returns a 202 to the initial request, with a location header that
   * points to a polling URL that returns a 200 and an entity that doesn't contains ProvisioningState
   * @param options The options parameters.
   */
  async beginPut202Retry200AndWait(
    options?: LROsPut202Retry200OptionalParams,
  ): Promise<LROsPut202Retry200Response> {
    const poller = await this.beginPut202Retry200(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 201 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with
   * ProvisioningState=’Succeeded’
   * @param options The options parameters.
   */
  async beginPut201CreatingSucceeded200(
    options?: LROsPut201CreatingSucceeded200OptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPut201CreatingSucceeded200Response>,
      LROsPut201CreatingSucceeded200Response
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPut201CreatingSucceeded200Response> => {
      return tracingClient.withSpan(
        "LROClient.beginPut201CreatingSucceeded200",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPut201CreatingSucceeded200Response>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: put201CreatingSucceeded200OperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPut201CreatingSucceeded200Response,
      OperationState<LROsPut201CreatingSucceeded200Response>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running put request, service returns a 201 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with
   * ProvisioningState=’Succeeded’
   * @param options The options parameters.
   */
  async beginPut201CreatingSucceeded200AndWait(
    options?: LROsPut201CreatingSucceeded200OptionalParams,
  ): Promise<LROsPut201CreatingSucceeded200Response> {
    const poller = await this.beginPut201CreatingSucceeded200(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 201 to the initial request, with an entity that contains
   * ProvisioningState=’Updating’.  Polls return this value until the last poll returns a ‘200’ with
   * ProvisioningState=’Succeeded’
   * @param options The options parameters.
   */
  async beginPut200UpdatingSucceeded204(
    options?: LROsPut200UpdatingSucceeded204OptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPut200UpdatingSucceeded204Response>,
      LROsPut200UpdatingSucceeded204Response
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPut200UpdatingSucceeded204Response> => {
      return tracingClient.withSpan(
        "LROClient.beginPut200UpdatingSucceeded204",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPut200UpdatingSucceeded204Response>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: put200UpdatingSucceeded204OperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPut200UpdatingSucceeded204Response,
      OperationState<LROsPut200UpdatingSucceeded204Response>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running put request, service returns a 201 to the initial request, with an entity that contains
   * ProvisioningState=’Updating’.  Polls return this value until the last poll returns a ‘200’ with
   * ProvisioningState=’Succeeded’
   * @param options The options parameters.
   */
  async beginPut200UpdatingSucceeded204AndWait(
    options?: LROsPut200UpdatingSucceeded204OptionalParams,
  ): Promise<LROsPut200UpdatingSucceeded204Response> {
    const poller = await this.beginPut200UpdatingSucceeded204(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 201 to the initial request, with an entity that contains
   * ProvisioningState=’Created’.  Polls return this value until the last poll returns a ‘200’ with
   * ProvisioningState=’Failed’
   * @param options The options parameters.
   */
  async beginPut201CreatingFailed200(
    options?: LROsPut201CreatingFailed200OptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPut201CreatingFailed200Response>,
      LROsPut201CreatingFailed200Response
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPut201CreatingFailed200Response> => {
      return tracingClient.withSpan(
        "LROClient.beginPut201CreatingFailed200",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPut201CreatingFailed200Response>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: put201CreatingFailed200OperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPut201CreatingFailed200Response,
      OperationState<LROsPut201CreatingFailed200Response>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running put request, service returns a 201 to the initial request, with an entity that contains
   * ProvisioningState=’Created’.  Polls return this value until the last poll returns a ‘200’ with
   * ProvisioningState=’Failed’
   * @param options The options parameters.
   */
  async beginPut201CreatingFailed200AndWait(
    options?: LROsPut201CreatingFailed200OptionalParams,
  ): Promise<LROsPut201CreatingFailed200Response> {
    const poller = await this.beginPut201CreatingFailed200(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 201 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with
   * ProvisioningState=’Canceled’
   * @param options The options parameters.
   */
  async beginPut200Acceptedcanceled200(
    options?: LROsPut200Acceptedcanceled200OptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPut200Acceptedcanceled200Response>,
      LROsPut200Acceptedcanceled200Response
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPut200Acceptedcanceled200Response> => {
      return tracingClient.withSpan(
        "LROClient.beginPut200Acceptedcanceled200",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPut200Acceptedcanceled200Response>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: put200Acceptedcanceled200OperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPut200Acceptedcanceled200Response,
      OperationState<LROsPut200Acceptedcanceled200Response>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running put request, service returns a 201 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with
   * ProvisioningState=’Canceled’
   * @param options The options parameters.
   */
  async beginPut200Acceptedcanceled200AndWait(
    options?: LROsPut200Acceptedcanceled200OptionalParams,
  ): Promise<LROsPut200Acceptedcanceled200Response> {
    const poller = await this.beginPut200Acceptedcanceled200(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 202 to the initial request with location header.
   * Subsequent calls to operation status do not contain location header.
   * @param options The options parameters.
   */
  async beginPutNoHeaderInRetry(
    options?: LROsPutNoHeaderInRetryOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPutNoHeaderInRetryResponse>,
      LROsPutNoHeaderInRetryResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPutNoHeaderInRetryResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPutNoHeaderInRetry",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPutNoHeaderInRetryResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: putNoHeaderInRetryOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPutNoHeaderInRetryResponse,
      OperationState<LROsPutNoHeaderInRetryResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running put request, service returns a 202 to the initial request with location header.
   * Subsequent calls to operation status do not contain location header.
   * @param options The options parameters.
   */
  async beginPutNoHeaderInRetryAndWait(
    options?: LROsPutNoHeaderInRetryOptionalParams,
  ): Promise<LROsPutNoHeaderInRetryResponse> {
    const poller = await this.beginPutNoHeaderInRetry(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
   * operation status
   * @param options The options parameters.
   */
  async beginPutAsyncRetrySucceeded(
    options?: LROsPutAsyncRetrySucceededOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPutAsyncRetrySucceededResponse>,
      LROsPutAsyncRetrySucceededResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPutAsyncRetrySucceededResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPutAsyncRetrySucceeded",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPutAsyncRetrySucceededResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: putAsyncRetrySucceededOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPutAsyncRetrySucceededResponse,
      OperationState<LROsPutAsyncRetrySucceededResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
   * operation status
   * @param options The options parameters.
   */
  async beginPutAsyncRetrySucceededAndWait(
    options?: LROsPutAsyncRetrySucceededOptionalParams,
  ): Promise<LROsPutAsyncRetrySucceededResponse> {
    const poller = await this.beginPutAsyncRetrySucceeded(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
   * operation status
   * @param options The options parameters.
   */
  async beginPutAsyncNoRetrySucceeded(
    options?: LROsPutAsyncNoRetrySucceededOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPutAsyncNoRetrySucceededResponse>,
      LROsPutAsyncNoRetrySucceededResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPutAsyncNoRetrySucceededResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPutAsyncNoRetrySucceeded",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPutAsyncNoRetrySucceededResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: putAsyncNoRetrySucceededOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPutAsyncNoRetrySucceededResponse,
      OperationState<LROsPutAsyncNoRetrySucceededResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
   * operation status
   * @param options The options parameters.
   */
  async beginPutAsyncNoRetrySucceededAndWait(
    options?: LROsPutAsyncNoRetrySucceededOptionalParams,
  ): Promise<LROsPutAsyncNoRetrySucceededResponse> {
    const poller = await this.beginPutAsyncNoRetrySucceeded(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
   * operation status
   * @param options The options parameters.
   */
  async beginPutAsyncRetryFailed(
    options?: LROsPutAsyncRetryFailedOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPutAsyncRetryFailedResponse>,
      LROsPutAsyncRetryFailedResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPutAsyncRetryFailedResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPutAsyncRetryFailed",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPutAsyncRetryFailedResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: putAsyncRetryFailedOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPutAsyncRetryFailedResponse,
      OperationState<LROsPutAsyncRetryFailedResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
   * operation status
   * @param options The options parameters.
   */
  async beginPutAsyncRetryFailedAndWait(
    options?: LROsPutAsyncRetryFailedOptionalParams,
  ): Promise<LROsPutAsyncRetryFailedResponse> {
    const poller = await this.beginPutAsyncRetryFailed(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
   * operation status
   * @param options The options parameters.
   */
  async beginPutAsyncNoRetrycanceled(
    options?: LROsPutAsyncNoRetrycanceledOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPutAsyncNoRetrycanceledResponse>,
      LROsPutAsyncNoRetrycanceledResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPutAsyncNoRetrycanceledResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPutAsyncNoRetrycanceled",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPutAsyncNoRetrycanceledResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: putAsyncNoRetrycanceledOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPutAsyncNoRetrycanceledResponse,
      OperationState<LROsPutAsyncNoRetrycanceledResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
   * operation status
   * @param options The options parameters.
   */
  async beginPutAsyncNoRetrycanceledAndWait(
    options?: LROsPutAsyncNoRetrycanceledOptionalParams,
  ): Promise<LROsPutAsyncNoRetrycanceledResponse> {
    const poller = await this.beginPutAsyncNoRetrycanceled(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation
   * header. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
   * @param options The options parameters.
   */
  async beginPutAsyncNoHeaderInRetry(
    options?: LROsPutAsyncNoHeaderInRetryOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPutAsyncNoHeaderInRetryResponse>,
      LROsPutAsyncNoHeaderInRetryResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPutAsyncNoHeaderInRetryResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPutAsyncNoHeaderInRetry",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPutAsyncNoHeaderInRetryResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: putAsyncNoHeaderInRetryOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPutAsyncNoHeaderInRetryResponse,
      OperationState<LROsPutAsyncNoHeaderInRetryResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation
   * header. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
   * @param options The options parameters.
   */
  async beginPutAsyncNoHeaderInRetryAndWait(
    options?: LROsPutAsyncNoHeaderInRetryOptionalParams,
  ): Promise<LROsPutAsyncNoHeaderInRetryResponse> {
    const poller = await this.beginPutAsyncNoHeaderInRetry(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request with non resource.
   * @param options The options parameters.
   */
  async beginPutNonResource(
    options?: LROsPutNonResourceOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPutNonResourceResponse>,
      LROsPutNonResourceResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPutNonResourceResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPutNonResource",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPutNonResourceResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: putNonResourceOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPutNonResourceResponse,
      OperationState<LROsPutNonResourceResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running put request with non resource.
   * @param options The options parameters.
   */
  async beginPutNonResourceAndWait(
    options?: LROsPutNonResourceOptionalParams,
  ): Promise<LROsPutNonResourceResponse> {
    const poller = await this.beginPutNonResource(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request with non resource.
   * @param options The options parameters.
   */
  async beginPutAsyncNonResource(
    options?: LROsPutAsyncNonResourceOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPutAsyncNonResourceResponse>,
      LROsPutAsyncNonResourceResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPutAsyncNonResourceResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPutAsyncNonResource",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPutAsyncNonResourceResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: putAsyncNonResourceOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPutAsyncNonResourceResponse,
      OperationState<LROsPutAsyncNonResourceResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running put request with non resource.
   * @param options The options parameters.
   */
  async beginPutAsyncNonResourceAndWait(
    options?: LROsPutAsyncNonResourceOptionalParams,
  ): Promise<LROsPutAsyncNonResourceResponse> {
    const poller = await this.beginPutAsyncNonResource(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request with sub resource.
   * @param options The options parameters.
   */
  async beginPutSubResource(
    options?: LROsPutSubResourceOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPutSubResourceResponse>,
      LROsPutSubResourceResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPutSubResourceResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPutSubResource",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPutSubResourceResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: putSubResourceOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPutSubResourceResponse,
      OperationState<LROsPutSubResourceResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running put request with sub resource.
   * @param options The options parameters.
   */
  async beginPutSubResourceAndWait(
    options?: LROsPutSubResourceOptionalParams,
  ): Promise<LROsPutSubResourceResponse> {
    const poller = await this.beginPutSubResource(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request with sub resource.
   * @param options The options parameters.
   */
  async beginPutAsyncSubResource(
    options?: LROsPutAsyncSubResourceOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPutAsyncSubResourceResponse>,
      LROsPutAsyncSubResourceResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPutAsyncSubResourceResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPutAsyncSubResource",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPutAsyncSubResourceResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: putAsyncSubResourceOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPutAsyncSubResourceResponse,
      OperationState<LROsPutAsyncSubResourceResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running put request with sub resource.
   * @param options The options parameters.
   */
  async beginPutAsyncSubResourceAndWait(
    options?: LROsPutAsyncSubResourceOptionalParams,
  ): Promise<LROsPutAsyncSubResourceResponse> {
    const poller = await this.beginPutAsyncSubResource(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running delete request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Accepted’.  Polls return this value until the last poll returns a ‘200’
   * with ProvisioningState=’Succeeded’
   * @param options The options parameters.
   */
  async beginDeleteProvisioning202Accepted200Succeeded(
    options?: LROsDeleteProvisioning202Accepted200SucceededOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsDeleteProvisioning202Accepted200SucceededResponse>,
      LROsDeleteProvisioning202Accepted200SucceededResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsDeleteProvisioning202Accepted200SucceededResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginDeleteProvisioning202Accepted200Succeeded",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsDeleteProvisioning202Accepted200SucceededResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: deleteProvisioning202Accepted200SucceededOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsDeleteProvisioning202Accepted200SucceededResponse,
      OperationState<LROsDeleteProvisioning202Accepted200SucceededResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running delete request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Accepted’.  Polls return this value until the last poll returns a ‘200’
   * with ProvisioningState=’Succeeded’
   * @param options The options parameters.
   */
  async beginDeleteProvisioning202Accepted200SucceededAndWait(
    options?: LROsDeleteProvisioning202Accepted200SucceededOptionalParams,
  ): Promise<LROsDeleteProvisioning202Accepted200SucceededResponse> {
    const poller =
      await this.beginDeleteProvisioning202Accepted200Succeeded(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running delete request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’
   * with ProvisioningState=’Failed’
   * @param options The options parameters.
   */
  async beginDeleteProvisioning202DeletingFailed200(
    options?: LROsDeleteProvisioning202DeletingFailed200OptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsDeleteProvisioning202DeletingFailed200Response>,
      LROsDeleteProvisioning202DeletingFailed200Response
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsDeleteProvisioning202DeletingFailed200Response> => {
      return tracingClient.withSpan(
        "LROClient.beginDeleteProvisioning202DeletingFailed200",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsDeleteProvisioning202DeletingFailed200Response>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: deleteProvisioning202DeletingFailed200OperationSpec,
    });
    const poller = await createHttpPoller<
      LROsDeleteProvisioning202DeletingFailed200Response,
      OperationState<LROsDeleteProvisioning202DeletingFailed200Response>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running delete request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’
   * with ProvisioningState=’Failed’
   * @param options The options parameters.
   */
  async beginDeleteProvisioning202DeletingFailed200AndWait(
    options?: LROsDeleteProvisioning202DeletingFailed200OptionalParams,
  ): Promise<LROsDeleteProvisioning202DeletingFailed200Response> {
    const poller =
      await this.beginDeleteProvisioning202DeletingFailed200(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running delete request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’
   * with ProvisioningState=’Canceled’
   * @param options The options parameters.
   */
  async beginDeleteProvisioning202Deletingcanceled200(
    options?: LROsDeleteProvisioning202Deletingcanceled200OptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsDeleteProvisioning202Deletingcanceled200Response>,
      LROsDeleteProvisioning202Deletingcanceled200Response
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsDeleteProvisioning202Deletingcanceled200Response> => {
      return tracingClient.withSpan(
        "LROClient.beginDeleteProvisioning202Deletingcanceled200",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsDeleteProvisioning202Deletingcanceled200Response>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: deleteProvisioning202Deletingcanceled200OperationSpec,
    });
    const poller = await createHttpPoller<
      LROsDeleteProvisioning202Deletingcanceled200Response,
      OperationState<LROsDeleteProvisioning202Deletingcanceled200Response>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running delete request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’
   * with ProvisioningState=’Canceled’
   * @param options The options parameters.
   */
  async beginDeleteProvisioning202Deletingcanceled200AndWait(
    options?: LROsDeleteProvisioning202Deletingcanceled200OptionalParams,
  ): Promise<LROsDeleteProvisioning202Deletingcanceled200Response> {
    const poller =
      await this.beginDeleteProvisioning202Deletingcanceled200(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running delete succeeds and returns right away
   * @param options The options parameters.
   */
  async beginDelete204Succeeded(
    options?: LROsDelete204SucceededOptionalParams,
  ): Promise<SimplePollerLike<OperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<void> => {
      return tracingClient.withSpan(
        "LROClient.beginDelete204Succeeded",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(args, spec) as Promise<void>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: delete204SucceededOperationSpec,
    });
    const poller = await createHttpPoller<void, OperationState<void>>(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running delete succeeds and returns right away
   * @param options The options parameters.
   */
  async beginDelete204SucceededAndWait(
    options?: LROsDelete204SucceededOptionalParams,
  ): Promise<void> {
    const poller = await this.beginDelete204Succeeded(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Polls return this value
   * until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
   * @param options The options parameters.
   */
  async beginDelete202Retry200(
    options?: LROsDelete202Retry200OptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsDelete202Retry200Response>,
      LROsDelete202Retry200Response
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsDelete202Retry200Response> => {
      return tracingClient.withSpan(
        "LROClient.beginDelete202Retry200",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsDelete202Retry200Response>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: delete202Retry200OperationSpec,
    });
    const poller = await createHttpPoller<
      LROsDelete202Retry200Response,
      OperationState<LROsDelete202Retry200Response>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Polls return this value
   * until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
   * @param options The options parameters.
   */
  async beginDelete202Retry200AndWait(
    options?: LROsDelete202Retry200OptionalParams,
  ): Promise<LROsDelete202Retry200Response> {
    const poller = await this.beginDelete202Retry200(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Polls return this value
   * until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
   * @param options The options parameters.
   */
  async beginDelete202NoRetry204(
    options?: LROsDelete202NoRetry204OptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsDelete202NoRetry204Response>,
      LROsDelete202NoRetry204Response
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsDelete202NoRetry204Response> => {
      return tracingClient.withSpan(
        "LROClient.beginDelete202NoRetry204",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsDelete202NoRetry204Response>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: delete202NoRetry204OperationSpec,
    });
    const poller = await createHttpPoller<
      LROsDelete202NoRetry204Response,
      OperationState<LROsDelete202NoRetry204Response>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Polls return this value
   * until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
   * @param options The options parameters.
   */
  async beginDelete202NoRetry204AndWait(
    options?: LROsDelete202NoRetry204OptionalParams,
  ): Promise<LROsDelete202NoRetry204Response> {
    const poller = await this.beginDelete202NoRetry204(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running delete request, service returns a location header in the initial request. Subsequent
   * calls to operation status do not contain location header.
   * @param options The options parameters.
   */
  async beginDeleteNoHeaderInRetry(
    options?: LROsDeleteNoHeaderInRetryOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsDeleteNoHeaderInRetryResponse>,
      LROsDeleteNoHeaderInRetryResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsDeleteNoHeaderInRetryResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginDeleteNoHeaderInRetry",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsDeleteNoHeaderInRetryResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: deleteNoHeaderInRetryOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsDeleteNoHeaderInRetryResponse,
      OperationState<LROsDeleteNoHeaderInRetryResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running delete request, service returns a location header in the initial request. Subsequent
   * calls to operation status do not contain location header.
   * @param options The options parameters.
   */
  async beginDeleteNoHeaderInRetryAndWait(
    options?: LROsDeleteNoHeaderInRetryOptionalParams,
  ): Promise<LROsDeleteNoHeaderInRetryResponse> {
    const poller = await this.beginDeleteNoHeaderInRetry(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running delete request, service returns an Azure-AsyncOperation header in the initial request.
   * Subsequent calls to operation status do not contain Azure-AsyncOperation header.
   * @param options The options parameters.
   */
  async beginDeleteAsyncNoHeaderInRetry(
    options?: LROsDeleteAsyncNoHeaderInRetryOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsDeleteAsyncNoHeaderInRetryResponse>,
      LROsDeleteAsyncNoHeaderInRetryResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsDeleteAsyncNoHeaderInRetryResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginDeleteAsyncNoHeaderInRetry",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsDeleteAsyncNoHeaderInRetryResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: deleteAsyncNoHeaderInRetryOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsDeleteAsyncNoHeaderInRetryResponse,
      OperationState<LROsDeleteAsyncNoHeaderInRetryResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running delete request, service returns an Azure-AsyncOperation header in the initial request.
   * Subsequent calls to operation status do not contain Azure-AsyncOperation header.
   * @param options The options parameters.
   */
  async beginDeleteAsyncNoHeaderInRetryAndWait(
    options?: LROsDeleteAsyncNoHeaderInRetryOptionalParams,
  ): Promise<LROsDeleteAsyncNoHeaderInRetryResponse> {
    const poller = await this.beginDeleteAsyncNoHeaderInRetry(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Poll the endpoint
   * indicated in the Azure-AsyncOperation header for operation status
   * @param options The options parameters.
   */
  async beginDeleteAsyncRetrySucceeded(
    options?: LROsDeleteAsyncRetrySucceededOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsDeleteAsyncRetrySucceededResponse>,
      LROsDeleteAsyncRetrySucceededResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsDeleteAsyncRetrySucceededResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginDeleteAsyncRetrySucceeded",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsDeleteAsyncRetrySucceededResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: deleteAsyncRetrySucceededOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsDeleteAsyncRetrySucceededResponse,
      OperationState<LROsDeleteAsyncRetrySucceededResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Poll the endpoint
   * indicated in the Azure-AsyncOperation header for operation status
   * @param options The options parameters.
   */
  async beginDeleteAsyncRetrySucceededAndWait(
    options?: LROsDeleteAsyncRetrySucceededOptionalParams,
  ): Promise<LROsDeleteAsyncRetrySucceededResponse> {
    const poller = await this.beginDeleteAsyncRetrySucceeded(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Poll the endpoint
   * indicated in the Azure-AsyncOperation header for operation status
   * @param options The options parameters.
   */
  async beginDeleteAsyncNoRetrySucceeded(
    options?: LROsDeleteAsyncNoRetrySucceededOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsDeleteAsyncNoRetrySucceededResponse>,
      LROsDeleteAsyncNoRetrySucceededResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsDeleteAsyncNoRetrySucceededResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginDeleteAsyncNoRetrySucceeded",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsDeleteAsyncNoRetrySucceededResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: deleteAsyncNoRetrySucceededOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsDeleteAsyncNoRetrySucceededResponse,
      OperationState<LROsDeleteAsyncNoRetrySucceededResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Poll the endpoint
   * indicated in the Azure-AsyncOperation header for operation status
   * @param options The options parameters.
   */
  async beginDeleteAsyncNoRetrySucceededAndWait(
    options?: LROsDeleteAsyncNoRetrySucceededOptionalParams,
  ): Promise<LROsDeleteAsyncNoRetrySucceededResponse> {
    const poller = await this.beginDeleteAsyncNoRetrySucceeded(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Poll the endpoint
   * indicated in the Azure-AsyncOperation header for operation status
   * @param options The options parameters.
   */
  async beginDeleteAsyncRetryFailed(
    options?: LROsDeleteAsyncRetryFailedOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsDeleteAsyncRetryFailedResponse>,
      LROsDeleteAsyncRetryFailedResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsDeleteAsyncRetryFailedResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginDeleteAsyncRetryFailed",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsDeleteAsyncRetryFailedResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: deleteAsyncRetryFailedOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsDeleteAsyncRetryFailedResponse,
      OperationState<LROsDeleteAsyncRetryFailedResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Poll the endpoint
   * indicated in the Azure-AsyncOperation header for operation status
   * @param options The options parameters.
   */
  async beginDeleteAsyncRetryFailedAndWait(
    options?: LROsDeleteAsyncRetryFailedOptionalParams,
  ): Promise<LROsDeleteAsyncRetryFailedResponse> {
    const poller = await this.beginDeleteAsyncRetryFailed(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Poll the endpoint
   * indicated in the Azure-AsyncOperation header for operation status
   * @param options The options parameters.
   */
  async beginDeleteAsyncRetrycanceled(
    options?: LROsDeleteAsyncRetrycanceledOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsDeleteAsyncRetrycanceledResponse>,
      LROsDeleteAsyncRetrycanceledResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsDeleteAsyncRetrycanceledResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginDeleteAsyncRetrycanceled",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsDeleteAsyncRetrycanceledResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: deleteAsyncRetrycanceledOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsDeleteAsyncRetrycanceledResponse,
      OperationState<LROsDeleteAsyncRetrycanceledResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Poll the endpoint
   * indicated in the Azure-AsyncOperation header for operation status
   * @param options The options parameters.
   */
  async beginDeleteAsyncRetrycanceledAndWait(
    options?: LROsDeleteAsyncRetrycanceledOptionalParams,
  ): Promise<LROsDeleteAsyncRetrycanceledResponse> {
    const poller = await this.beginDeleteAsyncRetrycanceled(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with 'Location' header.
   * Poll returns a 200 with a response body after success.
   * @param options The options parameters.
   */
  async beginPost200WithPayload(
    options?: LROsPost200WithPayloadOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPost200WithPayloadResponse>,
      LROsPost200WithPayloadResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPost200WithPayloadResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPost200WithPayload",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPost200WithPayloadResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: post200WithPayloadOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPost200WithPayloadResponse,
      OperationState<LROsPost200WithPayloadResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with 'Location' header.
   * Poll returns a 200 with a response body after success.
   * @param options The options parameters.
   */
  async beginPost200WithPayloadAndWait(
    options?: LROsPost200WithPayloadOptionalParams,
  ): Promise<LROsPost200WithPayloadResponse> {
    const poller = await this.beginPost200WithPayload(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with 'Location' and
   * 'Retry-After' headers, Polls return a 200 with a response body after success
   * @param options The options parameters.
   */
  async beginPost202Retry200(
    options?: LROsPost202Retry200OptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPost202Retry200Response>,
      LROsPost202Retry200Response
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPost202Retry200Response> => {
      return tracingClient.withSpan(
        "LROClient.beginPost202Retry200",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPost202Retry200Response>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: post202Retry200OperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPost202Retry200Response,
      OperationState<LROsPost202Retry200Response>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with 'Location' and
   * 'Retry-After' headers, Polls return a 200 with a response body after success
   * @param options The options parameters.
   */
  async beginPost202Retry200AndWait(
    options?: LROsPost202Retry200OptionalParams,
  ): Promise<LROsPost202Retry200Response> {
    const poller = await this.beginPost202Retry200(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with 'Location' header, 204
   * with noresponse body after success
   * @param options The options parameters.
   */
  async beginPost202NoRetry204(
    options?: LROsPost202NoRetry204OptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPost202NoRetry204Response>,
      LROsPost202NoRetry204Response
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPost202NoRetry204Response> => {
      return tracingClient.withSpan(
        "LROClient.beginPost202NoRetry204",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPost202NoRetry204Response>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: post202NoRetry204OperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPost202NoRetry204Response,
      OperationState<LROsPost202NoRetry204Response>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with 'Location' header, 204
   * with noresponse body after success
   * @param options The options parameters.
   */
  async beginPost202NoRetry204AndWait(
    options?: LROsPost202NoRetry204OptionalParams,
  ): Promise<LROsPost202NoRetry204Response> {
    const poller = await this.beginPost202NoRetry204(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running post request, service returns a 202 to the initial request with both Location and
   * Azure-Async header. Poll Azure-Async and it's success. Should poll Location to get the final object
   * @param options The options parameters.
   */
  async beginPostDoubleHeadersFinalLocationGet(
    options?: LROsPostDoubleHeadersFinalLocationGetOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPostDoubleHeadersFinalLocationGetResponse>,
      LROsPostDoubleHeadersFinalLocationGetResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPostDoubleHeadersFinalLocationGetResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPostDoubleHeadersFinalLocationGet",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPostDoubleHeadersFinalLocationGetResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: postDoubleHeadersFinalLocationGetOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPostDoubleHeadersFinalLocationGetResponse,
      OperationState<LROsPostDoubleHeadersFinalLocationGetResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      resourceLocationConfig: "location",
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running post request, service returns a 202 to the initial request with both Location and
   * Azure-Async header. Poll Azure-Async and it's success. Should poll Location to get the final object
   * @param options The options parameters.
   */
  async beginPostDoubleHeadersFinalLocationGetAndWait(
    options?: LROsPostDoubleHeadersFinalLocationGetOptionalParams,
  ): Promise<LROsPostDoubleHeadersFinalLocationGetResponse> {
    const poller = await this.beginPostDoubleHeadersFinalLocationGet(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running post request, service returns a 202 to the initial request with both Location and
   * Azure-Async header. Poll Azure-Async and it's success. Should NOT poll Location to get the final
   * object
   * @param options The options parameters.
   */
  async beginPostDoubleHeadersFinalAzureHeaderGet(
    options?: LROsPostDoubleHeadersFinalAzureHeaderGetOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPostDoubleHeadersFinalAzureHeaderGetResponse>,
      LROsPostDoubleHeadersFinalAzureHeaderGetResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPostDoubleHeadersFinalAzureHeaderGetResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPostDoubleHeadersFinalAzureHeaderGet",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPostDoubleHeadersFinalAzureHeaderGetResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: postDoubleHeadersFinalAzureHeaderGetOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPostDoubleHeadersFinalAzureHeaderGetResponse,
      OperationState<LROsPostDoubleHeadersFinalAzureHeaderGetResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      resourceLocationConfig: "azure-async-operation",
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running post request, service returns a 202 to the initial request with both Location and
   * Azure-Async header. Poll Azure-Async and it's success. Should NOT poll Location to get the final
   * object
   * @param options The options parameters.
   */
  async beginPostDoubleHeadersFinalAzureHeaderGetAndWait(
    options?: LROsPostDoubleHeadersFinalAzureHeaderGetOptionalParams,
  ): Promise<LROsPostDoubleHeadersFinalAzureHeaderGetResponse> {
    const poller =
      await this.beginPostDoubleHeadersFinalAzureHeaderGet(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running post request, service returns a 202 to the initial request with both Location and
   * Azure-Async header. Poll Azure-Async and it's success. Should NOT poll Location to get the final
   * object if you support initial Autorest behavior.
   * @param options The options parameters.
   */
  async beginPostDoubleHeadersFinalAzureHeaderGetDefault(
    options?: LROsPostDoubleHeadersFinalAzureHeaderGetDefaultOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPostDoubleHeadersFinalAzureHeaderGetDefaultResponse>,
      LROsPostDoubleHeadersFinalAzureHeaderGetDefaultResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPostDoubleHeadersFinalAzureHeaderGetDefaultResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPostDoubleHeadersFinalAzureHeaderGetDefault",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPostDoubleHeadersFinalAzureHeaderGetDefaultResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: postDoubleHeadersFinalAzureHeaderGetDefaultOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPostDoubleHeadersFinalAzureHeaderGetDefaultResponse,
      OperationState<LROsPostDoubleHeadersFinalAzureHeaderGetDefaultResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running post request, service returns a 202 to the initial request with both Location and
   * Azure-Async header. Poll Azure-Async and it's success. Should NOT poll Location to get the final
   * object if you support initial Autorest behavior.
   * @param options The options parameters.
   */
  async beginPostDoubleHeadersFinalAzureHeaderGetDefaultAndWait(
    options?: LROsPostDoubleHeadersFinalAzureHeaderGetDefaultOptionalParams,
  ): Promise<LROsPostDoubleHeadersFinalAzureHeaderGetDefaultResponse> {
    const poller =
      await this.beginPostDoubleHeadersFinalAzureHeaderGetDefault(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation
   * header for operation status
   * @param options The options parameters.
   */
  async beginPostAsyncRetrySucceeded(
    options?: LROsPostAsyncRetrySucceededOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPostAsyncRetrySucceededResponse>,
      LROsPostAsyncRetrySucceededResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPostAsyncRetrySucceededResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPostAsyncRetrySucceeded",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPostAsyncRetrySucceededResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: postAsyncRetrySucceededOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPostAsyncRetrySucceededResponse,
      OperationState<LROsPostAsyncRetrySucceededResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation
   * header for operation status
   * @param options The options parameters.
   */
  async beginPostAsyncRetrySucceededAndWait(
    options?: LROsPostAsyncRetrySucceededOptionalParams,
  ): Promise<LROsPostAsyncRetrySucceededResponse> {
    const poller = await this.beginPostAsyncRetrySucceeded(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation
   * header for operation status
   * @param options The options parameters.
   */
  async beginPostAsyncNoRetrySucceeded(
    options?: LROsPostAsyncNoRetrySucceededOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPostAsyncNoRetrySucceededResponse>,
      LROsPostAsyncNoRetrySucceededResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPostAsyncNoRetrySucceededResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPostAsyncNoRetrySucceeded",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPostAsyncNoRetrySucceededResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: postAsyncNoRetrySucceededOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPostAsyncNoRetrySucceededResponse,
      OperationState<LROsPostAsyncNoRetrySucceededResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation
   * header for operation status
   * @param options The options parameters.
   */
  async beginPostAsyncNoRetrySucceededAndWait(
    options?: LROsPostAsyncNoRetrySucceededOptionalParams,
  ): Promise<LROsPostAsyncNoRetrySucceededResponse> {
    const poller = await this.beginPostAsyncNoRetrySucceeded(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation
   * header for operation status
   * @param options The options parameters.
   */
  async beginPostAsyncRetryFailed(
    options?: LROsPostAsyncRetryFailedOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPostAsyncRetryFailedResponse>,
      LROsPostAsyncRetryFailedResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPostAsyncRetryFailedResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPostAsyncRetryFailed",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPostAsyncRetryFailedResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: postAsyncRetryFailedOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPostAsyncRetryFailedResponse,
      OperationState<LROsPostAsyncRetryFailedResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation
   * header for operation status
   * @param options The options parameters.
   */
  async beginPostAsyncRetryFailedAndWait(
    options?: LROsPostAsyncRetryFailedOptionalParams,
  ): Promise<LROsPostAsyncRetryFailedResponse> {
    const poller = await this.beginPostAsyncRetryFailed(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation
   * header for operation status
   * @param options The options parameters.
   */
  async beginPostAsyncRetrycanceled(
    options?: LROsPostAsyncRetrycanceledOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<LROsPostAsyncRetrycanceledResponse>,
      LROsPostAsyncRetrycanceledResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<LROsPostAsyncRetrycanceledResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPostAsyncRetrycanceled",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<LROsPostAsyncRetrycanceledResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: postAsyncRetrycanceledOperationSpec,
    });
    const poller = await createHttpPoller<
      LROsPostAsyncRetrycanceledResponse,
      OperationState<LROsPostAsyncRetrycanceledResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation
   * header for operation status
   * @param options The options parameters.
   */
  async beginPostAsyncRetrycanceledAndWait(
    options?: LROsPostAsyncRetrycanceledOptionalParams,
  ): Promise<LROsPostAsyncRetrycanceledResponse> {
    const poller = await this.beginPostAsyncRetrycanceled(options);
    return poller.pollUntilDone();
  }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);

const put200SucceededOperationSpec: coreClient.OperationSpec = {
  path: "/lro/put/200/succeeded",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
    },
    201: {
      bodyMapper: Mappers.Product,
    },
    202: {
      bodyMapper: Mappers.Product,
    },
    204: {
      bodyMapper: Mappers.Product,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer,
};
const patch200SucceededIgnoreHeadersOperationSpec: coreClient.OperationSpec = {
  path: "/lro/patch/200/succeeded/ignoreheaders",
  httpMethod: "PATCH",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPatch200SucceededIgnoreHeadersHeaders,
    },
    201: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPatch200SucceededIgnoreHeadersHeaders,
    },
    202: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPatch200SucceededIgnoreHeadersHeaders,
    },
    204: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPatch200SucceededIgnoreHeadersHeaders,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer,
};
const patch201RetryWithAsyncHeaderOperationSpec: coreClient.OperationSpec = {
  path: "/lro/patch/201/retry/onlyAsyncHeader",
  httpMethod: "PATCH",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
    },
    201: {
      bodyMapper: Mappers.Product,
    },
    202: {
      bodyMapper: Mappers.Product,
    },
    204: {
      bodyMapper: Mappers.Product,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer,
};
const patch202RetryWithAsyncAndLocationHeaderOperationSpec: coreClient.OperationSpec =
  {
    path: "/lro/patch/202/retry/asyncAndLocationHeader",
    httpMethod: "PATCH",
    responses: {
      200: {
        bodyMapper: Mappers.Product,
      },
      201: {
        bodyMapper: Mappers.Product,
      },
      202: {
        bodyMapper: Mappers.Product,
      },
      204: {
        bodyMapper: Mappers.Product,
      },
      default: {
        bodyMapper: Mappers.CloudError,
      },
    },
    requestBody: Parameters.product,
    urlParameters: [Parameters.$host],
    headerParameters: [Parameters.contentType, Parameters.accept],
    mediaType: "json",
    serializer,
  };
const put201SucceededOperationSpec: coreClient.OperationSpec = {
  path: "/lro/put/201/succeeded",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
    },
    201: {
      bodyMapper: Mappers.Product,
    },
    202: {
      bodyMapper: Mappers.Product,
    },
    204: {
      bodyMapper: Mappers.Product,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer,
};
const post202ListOperationSpec: coreClient.OperationSpec = {
  path: "/lro/list",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: { type: { name: "Composite", className: "Product" } },
        },
      },
    },
    201: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: { type: { name: "Composite", className: "Product" } },
        },
      },
    },
    202: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: { type: { name: "Composite", className: "Product" } },
        },
      },
    },
    204: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: { type: { name: "Composite", className: "Product" } },
        },
      },
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer,
};
const put200SucceededNoStateOperationSpec: coreClient.OperationSpec = {
  path: "/lro/put/200/succeeded/nostate",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
    },
    201: {
      bodyMapper: Mappers.Product,
    },
    202: {
      bodyMapper: Mappers.Product,
    },
    204: {
      bodyMapper: Mappers.Product,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer,
};
const put202Retry200OperationSpec: coreClient.OperationSpec = {
  path: "/lro/put/202/retry/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
    },
    201: {
      bodyMapper: Mappers.Product,
    },
    202: {
      bodyMapper: Mappers.Product,
    },
    204: {
      bodyMapper: Mappers.Product,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer,
};
const put201CreatingSucceeded200OperationSpec: coreClient.OperationSpec = {
  path: "/lro/put/201/creating/succeeded/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
    },
    201: {
      bodyMapper: Mappers.Product,
    },
    202: {
      bodyMapper: Mappers.Product,
    },
    204: {
      bodyMapper: Mappers.Product,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer,
};
const put200UpdatingSucceeded204OperationSpec: coreClient.OperationSpec = {
  path: "/lro/put/200/updating/succeeded/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
    },
    201: {
      bodyMapper: Mappers.Product,
    },
    202: {
      bodyMapper: Mappers.Product,
    },
    204: {
      bodyMapper: Mappers.Product,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer,
};
const put201CreatingFailed200OperationSpec: coreClient.OperationSpec = {
  path: "/lro/put/201/created/failed/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
    },
    201: {
      bodyMapper: Mappers.Product,
    },
    202: {
      bodyMapper: Mappers.Product,
    },
    204: {
      bodyMapper: Mappers.Product,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer,
};
const put200Acceptedcanceled200OperationSpec: coreClient.OperationSpec = {
  path: "/lro/put/200/accepted/canceled/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
    },
    201: {
      bodyMapper: Mappers.Product,
    },
    202: {
      bodyMapper: Mappers.Product,
    },
    204: {
      bodyMapper: Mappers.Product,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer,
};
const putNoHeaderInRetryOperationSpec: coreClient.OperationSpec = {
  path: "/lro/put/noheader/202/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutNoHeaderInRetryHeaders,
    },
    201: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutNoHeaderInRetryHeaders,
    },
    202: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutNoHeaderInRetryHeaders,
    },
    204: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutNoHeaderInRetryHeaders,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer,
};
const putAsyncRetrySucceededOperationSpec: coreClient.OperationSpec = {
  path: "/lro/putasync/retry/succeeded",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncRetrySucceededHeaders,
    },
    201: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncRetrySucceededHeaders,
    },
    202: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncRetrySucceededHeaders,
    },
    204: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncRetrySucceededHeaders,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer,
};
const putAsyncNoRetrySucceededOperationSpec: coreClient.OperationSpec = {
  path: "/lro/putasync/noretry/succeeded",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncNoRetrySucceededHeaders,
    },
    201: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncNoRetrySucceededHeaders,
    },
    202: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncNoRetrySucceededHeaders,
    },
    204: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncNoRetrySucceededHeaders,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer,
};
const putAsyncRetryFailedOperationSpec: coreClient.OperationSpec = {
  path: "/lro/putasync/retry/failed",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncRetryFailedHeaders,
    },
    201: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncRetryFailedHeaders,
    },
    202: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncRetryFailedHeaders,
    },
    204: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncRetryFailedHeaders,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer,
};
const putAsyncNoRetrycanceledOperationSpec: coreClient.OperationSpec = {
  path: "/lro/putasync/noretry/canceled",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncNoRetrycanceledHeaders,
    },
    201: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncNoRetrycanceledHeaders,
    },
    202: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncNoRetrycanceledHeaders,
    },
    204: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncNoRetrycanceledHeaders,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer,
};
const putAsyncNoHeaderInRetryOperationSpec: coreClient.OperationSpec = {
  path: "/lro/putasync/noheader/201/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncNoHeaderInRetryHeaders,
    },
    201: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncNoHeaderInRetryHeaders,
    },
    202: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncNoHeaderInRetryHeaders,
    },
    204: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncNoHeaderInRetryHeaders,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer,
};
const putNonResourceOperationSpec: coreClient.OperationSpec = {
  path: "/lro/putnonresource/202/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Sku,
    },
    201: {
      bodyMapper: Mappers.Sku,
    },
    202: {
      bodyMapper: Mappers.Sku,
    },
    204: {
      bodyMapper: Mappers.Sku,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  requestBody: Parameters.sku,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer,
};
const putAsyncNonResourceOperationSpec: coreClient.OperationSpec = {
  path: "/lro/putnonresourceasync/202/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Sku,
    },
    201: {
      bodyMapper: Mappers.Sku,
    },
    202: {
      bodyMapper: Mappers.Sku,
    },
    204: {
      bodyMapper: Mappers.Sku,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  requestBody: Parameters.sku,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer,
};
const putSubResourceOperationSpec: coreClient.OperationSpec = {
  path: "/lro/putsubresource/202/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.SubProduct,
    },
    201: {
      bodyMapper: Mappers.SubProduct,
    },
    202: {
      bodyMapper: Mappers.SubProduct,
    },
    204: {
      bodyMapper: Mappers.SubProduct,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  requestBody: Parameters.product1,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer,
};
const putAsyncSubResourceOperationSpec: coreClient.OperationSpec = {
  path: "/lro/putsubresourceasync/202/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.SubProduct,
    },
    201: {
      bodyMapper: Mappers.SubProduct,
    },
    202: {
      bodyMapper: Mappers.SubProduct,
    },
    204: {
      bodyMapper: Mappers.SubProduct,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  requestBody: Parameters.product1,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer,
};
const deleteProvisioning202Accepted200SucceededOperationSpec: coreClient.OperationSpec =
  {
    path: "/lro/delete/provisioning/202/accepted/200/succeeded",
    httpMethod: "DELETE",
    responses: {
      200: {
        bodyMapper: Mappers.Product,
      },
      201: {
        bodyMapper: Mappers.Product,
      },
      202: {
        bodyMapper: Mappers.Product,
      },
      204: {
        bodyMapper: Mappers.Product,
      },
      default: {
        bodyMapper: Mappers.CloudError,
      },
    },
    urlParameters: [Parameters.$host],
    headerParameters: [Parameters.accept],
    serializer,
  };
const deleteProvisioning202DeletingFailed200OperationSpec: coreClient.OperationSpec =
  {
    path: "/lro/delete/provisioning/202/deleting/200/failed",
    httpMethod: "DELETE",
    responses: {
      200: {
        bodyMapper: Mappers.Product,
      },
      201: {
        bodyMapper: Mappers.Product,
      },
      202: {
        bodyMapper: Mappers.Product,
      },
      204: {
        bodyMapper: Mappers.Product,
      },
      default: {
        bodyMapper: Mappers.CloudError,
      },
    },
    urlParameters: [Parameters.$host],
    headerParameters: [Parameters.accept],
    serializer,
  };
const deleteProvisioning202Deletingcanceled200OperationSpec: coreClient.OperationSpec =
  {
    path: "/lro/delete/provisioning/202/deleting/200/canceled",
    httpMethod: "DELETE",
    responses: {
      200: {
        bodyMapper: Mappers.Product,
      },
      201: {
        bodyMapper: Mappers.Product,
      },
      202: {
        bodyMapper: Mappers.Product,
      },
      204: {
        bodyMapper: Mappers.Product,
      },
      default: {
        bodyMapper: Mappers.CloudError,
      },
    },
    urlParameters: [Parameters.$host],
    headerParameters: [Parameters.accept],
    serializer,
  };
const delete204SucceededOperationSpec: coreClient.OperationSpec = {
  path: "/lro/delete/204/succeeded",
  httpMethod: "DELETE",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer,
};
const delete202Retry200OperationSpec: coreClient.OperationSpec = {
  path: "/lro/delete/202/retry/200",
  httpMethod: "DELETE",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
    },
    201: {
      bodyMapper: Mappers.Product,
    },
    202: {
      bodyMapper: Mappers.Product,
    },
    204: {
      bodyMapper: Mappers.Product,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer,
};
const delete202NoRetry204OperationSpec: coreClient.OperationSpec = {
  path: "/lro/delete/202/noretry/204",
  httpMethod: "DELETE",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
    },
    201: {
      bodyMapper: Mappers.Product,
    },
    202: {
      bodyMapper: Mappers.Product,
    },
    204: {
      bodyMapper: Mappers.Product,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer,
};
const deleteNoHeaderInRetryOperationSpec: coreClient.OperationSpec = {
  path: "/lro/delete/noheader",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.LROsDeleteNoHeaderInRetryHeaders,
    },
    201: {
      headersMapper: Mappers.LROsDeleteNoHeaderInRetryHeaders,
    },
    202: {
      headersMapper: Mappers.LROsDeleteNoHeaderInRetryHeaders,
    },
    204: {
      headersMapper: Mappers.LROsDeleteNoHeaderInRetryHeaders,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer,
};
const deleteAsyncNoHeaderInRetryOperationSpec: coreClient.OperationSpec = {
  path: "/lro/deleteasync/noheader/202/204",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.LROsDeleteAsyncNoHeaderInRetryHeaders,
    },
    201: {
      headersMapper: Mappers.LROsDeleteAsyncNoHeaderInRetryHeaders,
    },
    202: {
      headersMapper: Mappers.LROsDeleteAsyncNoHeaderInRetryHeaders,
    },
    204: {
      headersMapper: Mappers.LROsDeleteAsyncNoHeaderInRetryHeaders,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer,
};
const deleteAsyncRetrySucceededOperationSpec: coreClient.OperationSpec = {
  path: "/lro/deleteasync/retry/succeeded",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.LROsDeleteAsyncRetrySucceededHeaders,
    },
    201: {
      headersMapper: Mappers.LROsDeleteAsyncRetrySucceededHeaders,
    },
    202: {
      headersMapper: Mappers.LROsDeleteAsyncRetrySucceededHeaders,
    },
    204: {
      headersMapper: Mappers.LROsDeleteAsyncRetrySucceededHeaders,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer,
};
const deleteAsyncNoRetrySucceededOperationSpec: coreClient.OperationSpec = {
  path: "/lro/deleteasync/noretry/succeeded",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.LROsDeleteAsyncNoRetrySucceededHeaders,
    },
    201: {
      headersMapper: Mappers.LROsDeleteAsyncNoRetrySucceededHeaders,
    },
    202: {
      headersMapper: Mappers.LROsDeleteAsyncNoRetrySucceededHeaders,
    },
    204: {
      headersMapper: Mappers.LROsDeleteAsyncNoRetrySucceededHeaders,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer,
};
const deleteAsyncRetryFailedOperationSpec: coreClient.OperationSpec = {
  path: "/lro/deleteasync/retry/failed",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.LROsDeleteAsyncRetryFailedHeaders,
    },
    201: {
      headersMapper: Mappers.LROsDeleteAsyncRetryFailedHeaders,
    },
    202: {
      headersMapper: Mappers.LROsDeleteAsyncRetryFailedHeaders,
    },
    204: {
      headersMapper: Mappers.LROsDeleteAsyncRetryFailedHeaders,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer,
};
const deleteAsyncRetrycanceledOperationSpec: coreClient.OperationSpec = {
  path: "/lro/deleteasync/retry/canceled",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.LROsDeleteAsyncRetrycanceledHeaders,
    },
    201: {
      headersMapper: Mappers.LROsDeleteAsyncRetrycanceledHeaders,
    },
    202: {
      headersMapper: Mappers.LROsDeleteAsyncRetrycanceledHeaders,
    },
    204: {
      headersMapper: Mappers.LROsDeleteAsyncRetrycanceledHeaders,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer,
};
const post200WithPayloadOperationSpec: coreClient.OperationSpec = {
  path: "/lro/post/payload/200",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.Sku,
    },
    201: {
      bodyMapper: Mappers.Sku,
    },
    202: {
      bodyMapper: Mappers.Sku,
    },
    204: {
      bodyMapper: Mappers.Sku,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer,
};
const post202Retry200OperationSpec: coreClient.OperationSpec = {
  path: "/lro/post/202/retry/200",
  httpMethod: "POST",
  responses: {
    200: {
      headersMapper: Mappers.LROsPost202Retry200Headers,
    },
    201: {
      headersMapper: Mappers.LROsPost202Retry200Headers,
    },
    202: {
      headersMapper: Mappers.LROsPost202Retry200Headers,
    },
    204: {
      headersMapper: Mappers.LROsPost202Retry200Headers,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer,
};
const post202NoRetry204OperationSpec: coreClient.OperationSpec = {
  path: "/lro/post/202/noretry/204",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPost202NoRetry204Headers,
    },
    201: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPost202NoRetry204Headers,
    },
    202: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPost202NoRetry204Headers,
    },
    204: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPost202NoRetry204Headers,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer,
};
const postDoubleHeadersFinalLocationGetOperationSpec: coreClient.OperationSpec =
  {
    path: "/lro/LROPostDoubleHeadersFinalLocationGet",
    httpMethod: "POST",
    responses: {
      200: {
        bodyMapper: Mappers.Product,
      },
      201: {
        bodyMapper: Mappers.Product,
      },
      202: {
        bodyMapper: Mappers.Product,
      },
      204: {
        bodyMapper: Mappers.Product,
      },
      default: {
        bodyMapper: Mappers.CloudError,
      },
    },
    urlParameters: [Parameters.$host],
    headerParameters: [Parameters.accept],
    serializer,
  };
const postDoubleHeadersFinalAzureHeaderGetOperationSpec: coreClient.OperationSpec =
  {
    path: "/lro/LROPostDoubleHeadersFinalAzureHeaderGet",
    httpMethod: "POST",
    responses: {
      200: {
        bodyMapper: Mappers.Product,
      },
      201: {
        bodyMapper: Mappers.Product,
      },
      202: {
        bodyMapper: Mappers.Product,
      },
      204: {
        bodyMapper: Mappers.Product,
      },
      default: {
        bodyMapper: Mappers.CloudError,
      },
    },
    urlParameters: [Parameters.$host],
    headerParameters: [Parameters.accept],
    serializer,
  };
const postDoubleHeadersFinalAzureHeaderGetDefaultOperationSpec: coreClient.OperationSpec =
  {
    path: "/lro/LROPostDoubleHeadersFinalAzureHeaderGetDefault",
    httpMethod: "POST",
    responses: {
      200: {
        bodyMapper: Mappers.Product,
      },
      201: {
        bodyMapper: Mappers.Product,
      },
      202: {
        bodyMapper: Mappers.Product,
      },
      204: {
        bodyMapper: Mappers.Product,
      },
      default: {
        bodyMapper: Mappers.CloudError,
      },
    },
    urlParameters: [Parameters.$host],
    headerParameters: [Parameters.accept],
    serializer,
  };
const postAsyncRetrySucceededOperationSpec: coreClient.OperationSpec = {
  path: "/lro/postasync/retry/succeeded",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
    },
    201: {
      bodyMapper: Mappers.Product,
    },
    202: {
      bodyMapper: Mappers.Product,
    },
    204: {
      bodyMapper: Mappers.Product,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer,
};
const postAsyncNoRetrySucceededOperationSpec: coreClient.OperationSpec = {
  path: "/lro/postasync/noretry/succeeded",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
    },
    201: {
      bodyMapper: Mappers.Product,
    },
    202: {
      bodyMapper: Mappers.Product,
    },
    204: {
      bodyMapper: Mappers.Product,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer,
};
const postAsyncRetryFailedOperationSpec: coreClient.OperationSpec = {
  path: "/lro/postasync/retry/failed",
  httpMethod: "POST",
  responses: {
    200: {
      headersMapper: Mappers.LROsPostAsyncRetryFailedHeaders,
    },
    201: {
      headersMapper: Mappers.LROsPostAsyncRetryFailedHeaders,
    },
    202: {
      headersMapper: Mappers.LROsPostAsyncRetryFailedHeaders,
    },
    204: {
      headersMapper: Mappers.LROsPostAsyncRetryFailedHeaders,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer,
};
const postAsyncRetrycanceledOperationSpec: coreClient.OperationSpec = {
  path: "/lro/postasync/retry/canceled",
  httpMethod: "POST",
  responses: {
    200: {
      headersMapper: Mappers.LROsPostAsyncRetrycanceledHeaders,
    },
    201: {
      headersMapper: Mappers.LROsPostAsyncRetrycanceledHeaders,
    },
    202: {
      headersMapper: Mappers.LROsPostAsyncRetrycanceledHeaders,
    },
    204: {
      headersMapper: Mappers.LROsPostAsyncRetrycanceledHeaders,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer,
};
