/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { tracingClient } from "../tracing";
import { PagedAsyncIterableIterator, PageSettings } from "@azure/core-paging";
import { setContinuationToken } from "../pagingHelper";
import { Paging } from "../operationsInterfaces";
import * as coreClient from "@azure/core-client";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
import { PagingClient } from "../pagingClient";
import {
  SimplePollerLike,
  OperationState,
  createHttpPoller,
} from "@azure/core-lro";
import { createLroSpec } from "../lroImpl";
import {
  Product,
  PagingGetNoItemNamePagesNextOptionalParams,
  PagingGetNoItemNamePagesOptionalParams,
  PagingGetNoItemNamePagesResponse,
  PagingGetEmptyNextLinkNamePagesNextOptionalParams,
  PagingGetEmptyNextLinkNamePagesOptionalParams,
  PagingGetEmptyNextLinkNamePagesResponse,
  PagingGetNullNextLinkNamePagesOptionalParams,
  PagingGetNullNextLinkNamePagesResponse,
  PagingGetSinglePagesNextOptionalParams,
  PagingGetSinglePagesOptionalParams,
  PagingGetSinglePagesResponse,
  BodyParam,
  PagingGetSinglePagesWithBodyParamsNextOptionalParams,
  PagingGetSinglePagesWithBodyParamsOptionalParams,
  PagingGetSinglePagesWithBodyParamsResponse,
  PagingFirstResponseEmptyNextOptionalParams,
  PagingFirstResponseEmptyOptionalParams,
  PagingFirstResponseEmptyResponse,
  PagingGetMultiplePagesNextOptionalParams,
  PagingGetMultiplePagesOptionalParams,
  PagingGetMultiplePagesResponse,
  PagingNextOperationWithQueryParamsOptionalParams,
  PagingGetWithQueryParamsOptionalParams,
  PagingGetWithQueryParamsResponse,
  PagingDuplicateParamsNextOptionalParams,
  PagingDuplicateParamsOptionalParams,
  PagingDuplicateParamsResponse,
  PagingPageWithMaxPageSizeNextOptionalParams,
  PagingPageWithMaxPageSizeOptionalParams,
  PagingPageWithMaxPageSizeResponse,
  PagingGetOdataMultiplePagesNextOptionalParams,
  PagingGetOdataMultiplePagesOptionalParams,
  PagingGetOdataMultiplePagesResponse,
  PagingGetMultiplePagesWithOffsetOptions,
  PagingGetMultiplePagesWithOffsetNextOptionalParams,
  PagingGetMultiplePagesWithOffsetOptionalParams,
  PagingGetMultiplePagesWithOffsetResponse,
  PagingGetMultiplePagesRetryFirstNextOptionalParams,
  PagingGetMultiplePagesRetryFirstOptionalParams,
  PagingGetMultiplePagesRetryFirstResponse,
  PagingGetMultiplePagesRetrySecondNextOptionalParams,
  PagingGetMultiplePagesRetrySecondOptionalParams,
  PagingGetMultiplePagesRetrySecondResponse,
  PagingGetSinglePagesFailureNextOptionalParams,
  PagingGetSinglePagesFailureOptionalParams,
  PagingGetSinglePagesFailureResponse,
  PagingGetMultiplePagesFailureNextOptionalParams,
  PagingGetMultiplePagesFailureOptionalParams,
  PagingGetMultiplePagesFailureResponse,
  PagingGetMultiplePagesFailureUriNextOptionalParams,
  PagingGetMultiplePagesFailureUriOptionalParams,
  PagingGetMultiplePagesFailureUriResponse,
  PagingNextFragmentOptionalParams,
  PagingGetMultiplePagesFragmentNextLinkOptionalParams,
  PagingGetMultiplePagesFragmentNextLinkResponse,
  CustomParameterGroup,
  PagingNextFragmentWithGroupingOptionalParams,
  PagingGetMultiplePagesFragmentWithGroupingNextLinkOptionalParams,
  PagingGetMultiplePagesFragmentWithGroupingNextLinkResponse,
  PagingGetMultiplePagesLRONextOptionalParams,
  PagingGetMultiplePagesLROOptionalParams,
  PagingGetMultiplePagesLROResponse,
  PagingAppendApiVersionNextOptionalParams,
  PagingAppendApiVersionOptionalParams,
  PagingAppendApiVersionResponse,
  PagingReplaceApiVersionNextOptionalParams,
  PagingReplaceApiVersionOptionalParams,
  PagingReplaceApiVersionResponse,
  PagingNextFragmentResponse,
  PagingNextFragmentWithGroupingResponse,
  PagingGetPagingModelWithItemNameWithXMSClientNameNextOptionalParams,
  PagingGetPagingModelWithItemNameWithXMSClientNameOptionalParams,
  PagingGetPagingModelWithItemNameWithXMSClientNameResponse,
  PagingNextOperationWithQueryParamsResponse,
  PagingGetNoItemNamePagesNextResponse,
  PagingGetEmptyNextLinkNamePagesNextResponse,
  PagingGetSinglePagesNextResponse,
  PagingGetSinglePagesWithBodyParamsNextResponse,
  PagingFirstResponseEmptyNextResponse,
  PagingGetMultiplePagesNextResponse,
  PagingDuplicateParamsNextResponse,
  PagingPageWithMaxPageSizeNextResponse,
  PagingGetOdataMultiplePagesNextResponse,
  PagingGetMultiplePagesWithOffsetNextResponse,
  PagingGetMultiplePagesRetryFirstNextResponse,
  PagingGetMultiplePagesRetrySecondNextResponse,
  PagingGetSinglePagesFailureNextResponse,
  PagingGetMultiplePagesFailureNextResponse,
  PagingGetMultiplePagesFailureUriNextResponse,
  PagingGetMultiplePagesLRONextResponse,
  PagingAppendApiVersionNextResponse,
  PagingReplaceApiVersionNextResponse,
  PagingGetPagingModelWithItemNameWithXMSClientNameNextResponse,
} from "../models";

/// <reference lib="esnext.asynciterable" />
/** Class containing Paging operations. */
export class PagingImpl implements Paging {
  private readonly client: PagingClient;

  /**
   * Initialize a new instance of the class Paging class.
   * @param client Reference to the service client
   */
  constructor(client: PagingClient) {
    this.client = client;
  }

  /**
   * A paging operation that must return result of the default 'value' node.
   * @param options The options parameters.
   */
  public listNoItemNamePages(
    options?: PagingGetNoItemNamePagesOptionalParams,
  ): PagedAsyncIterableIterator<Product> {
    const iter = this.getNoItemNamePagesPagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.getNoItemNamePagesPagingPage(options, settings);
      },
    };
  }

  private async *getNoItemNamePagesPagingPage(
    options?: PagingGetNoItemNamePagesOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<Product[]> {
    let result: PagingGetNoItemNamePagesResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._getNoItemNamePages(options);
      let page = result.value || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._getNoItemNamePagesNext(continuationToken, options);
      continuationToken = result.nextLink;
      let page = result.value || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *getNoItemNamePagesPagingAll(
    options?: PagingGetNoItemNamePagesOptionalParams,
  ): AsyncIterableIterator<Product> {
    for await (const page of this.getNoItemNamePagesPagingPage(options)) {
      yield* page;
    }
  }

  /**
   * A paging operation that gets an empty next link and should stop after page 1.
   * @param options The options parameters.
   */
  public listEmptyNextLinkNamePages(
    options?: PagingGetEmptyNextLinkNamePagesOptionalParams,
  ): PagedAsyncIterableIterator<Product> {
    const iter = this.getEmptyNextLinkNamePagesPagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.getEmptyNextLinkNamePagesPagingPage(options, settings);
      },
    };
  }

  private async *getEmptyNextLinkNamePagesPagingPage(
    options?: PagingGetEmptyNextLinkNamePagesOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<Product[]> {
    let result: PagingGetEmptyNextLinkNamePagesResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._getEmptyNextLinkNamePages(options);
      let page = result.value || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._getEmptyNextLinkNamePagesNext(
        continuationToken,
        options,
      );
      continuationToken = result.nextLink;
      let page = result.value || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *getEmptyNextLinkNamePagesPagingAll(
    options?: PagingGetEmptyNextLinkNamePagesOptionalParams,
  ): AsyncIterableIterator<Product> {
    for await (const page of this.getEmptyNextLinkNamePagesPagingPage(
      options,
    )) {
      yield* page;
    }
  }

  /**
   * A paging operation that must ignore any kind of nextLink, and stop after page 1.
   * @param options The options parameters.
   */
  public listNullNextLinkNamePages(
    options?: PagingGetNullNextLinkNamePagesOptionalParams,
  ): PagedAsyncIterableIterator<Product> {
    const iter = this.getNullNextLinkNamePagesPagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.getNullNextLinkNamePagesPagingPage(options, settings);
      },
    };
  }

  private async *getNullNextLinkNamePagesPagingPage(
    options?: PagingGetNullNextLinkNamePagesOptionalParams,
    _settings?: PageSettings,
  ): AsyncIterableIterator<Product[]> {
    let result: PagingGetNullNextLinkNamePagesResponse;
    result = await this._getNullNextLinkNamePages(options);
    yield result.values || [];
  }

  private async *getNullNextLinkNamePagesPagingAll(
    options?: PagingGetNullNextLinkNamePagesOptionalParams,
  ): AsyncIterableIterator<Product> {
    for await (const page of this.getNullNextLinkNamePagesPagingPage(options)) {
      yield* page;
    }
  }

  /**
   * A paging operation that finishes on the first call without a nextlink
   * @param options The options parameters.
   */
  public listSinglePages(
    options?: PagingGetSinglePagesOptionalParams,
  ): PagedAsyncIterableIterator<Product> {
    const iter = this.getSinglePagesPagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.getSinglePagesPagingPage(options, settings);
      },
    };
  }

  private async *getSinglePagesPagingPage(
    options?: PagingGetSinglePagesOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<Product[]> {
    let result: PagingGetSinglePagesResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._getSinglePages(options);
      let page = result.values || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._getSinglePagesNext(continuationToken, options);
      continuationToken = result.nextLink;
      let page = result.values || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *getSinglePagesPagingAll(
    options?: PagingGetSinglePagesOptionalParams,
  ): AsyncIterableIterator<Product> {
    for await (const page of this.getSinglePagesPagingPage(options)) {
      yield* page;
    }
  }

  /**
   * A paging operation that finishes on the first call with body params without a nextlink
   * @param parameters put {'name': 'body'} to pass the test
   * @param options The options parameters.
   */
  public listSinglePagesWithBodyParams(
    parameters: BodyParam,
    options?: PagingGetSinglePagesWithBodyParamsOptionalParams,
  ): PagedAsyncIterableIterator<Product> {
    const iter = this.getSinglePagesWithBodyParamsPagingAll(
      parameters,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.getSinglePagesWithBodyParamsPagingPage(
          parameters,
          options,
          settings,
        );
      },
    };
  }

  private async *getSinglePagesWithBodyParamsPagingPage(
    parameters: BodyParam,
    options?: PagingGetSinglePagesWithBodyParamsOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<Product[]> {
    let result: PagingGetSinglePagesWithBodyParamsResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._getSinglePagesWithBodyParams(parameters, options);
      let page = result.values || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._getSinglePagesWithBodyParamsNext(
        parameters,
        continuationToken,
        options,
      );
      continuationToken = result.nextLink;
      let page = result.values || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *getSinglePagesWithBodyParamsPagingAll(
    parameters: BodyParam,
    options?: PagingGetSinglePagesWithBodyParamsOptionalParams,
  ): AsyncIterableIterator<Product> {
    for await (const page of this.getSinglePagesWithBodyParamsPagingPage(
      parameters,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * A paging operation whose first response's items list is empty, but still returns a next link. Second
   * (and final) call, will give you an items list of 1.
   * @param options The options parameters.
   */
  public listFirstResponseEmpty(
    options?: PagingFirstResponseEmptyOptionalParams,
  ): PagedAsyncIterableIterator<Product> {
    const iter = this.firstResponseEmptyPagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.firstResponseEmptyPagingPage(options, settings);
      },
    };
  }

  private async *firstResponseEmptyPagingPage(
    options?: PagingFirstResponseEmptyOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<Product[]> {
    let result: PagingFirstResponseEmptyResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._firstResponseEmpty(options);
      let page = result.value || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._firstResponseEmptyNext(continuationToken, options);
      continuationToken = result.nextLink;
      let page = result.value || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *firstResponseEmptyPagingAll(
    options?: PagingFirstResponseEmptyOptionalParams,
  ): AsyncIterableIterator<Product> {
    for await (const page of this.firstResponseEmptyPagingPage(options)) {
      yield* page;
    }
  }

  /**
   * A paging operation that includes a nextLink that has 10 pages
   * @param options The options parameters.
   */
  public listMultiplePages(
    options?: PagingGetMultiplePagesOptionalParams,
  ): PagedAsyncIterableIterator<Product> {
    const iter = this.getMultiplePagesPagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.getMultiplePagesPagingPage(options, settings);
      },
    };
  }

  private async *getMultiplePagesPagingPage(
    options?: PagingGetMultiplePagesOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<Product[]> {
    let result: PagingGetMultiplePagesResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._getMultiplePages(options);
      let page = result.values || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._getMultiplePagesNext(continuationToken, options);
      continuationToken = result.nextLink;
      let page = result.values || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *getMultiplePagesPagingAll(
    options?: PagingGetMultiplePagesOptionalParams,
  ): AsyncIterableIterator<Product> {
    for await (const page of this.getMultiplePagesPagingPage(options)) {
      yield* page;
    }
  }

  /**
   * A paging operation that includes a next operation. It has a different query parameter from it's next
   * operation nextOperationWithQueryParams. Returns a ProductResult
   * @param requiredQueryParameter A required integer query parameter. Put in value '100' to pass test.
   * @param options The options parameters.
   */
  public listWithQueryParams(
    requiredQueryParameter: number,
    options?: PagingGetWithQueryParamsOptionalParams,
  ): PagedAsyncIterableIterator<Product> {
    const iter = this.getWithQueryParamsPagingAll(
      requiredQueryParameter,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.getWithQueryParamsPagingPage(
          requiredQueryParameter,
          options,
          settings,
        );
      },
    };
  }

  private async *getWithQueryParamsPagingPage(
    requiredQueryParameter: number,
    options?: PagingGetWithQueryParamsOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<Product[]> {
    let result: PagingGetWithQueryParamsResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._getWithQueryParams(requiredQueryParameter, options);
      let page = result.values || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._nextOperationWithQueryParams(options);
      continuationToken = result.nextLink;
      let page = result.values || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *getWithQueryParamsPagingAll(
    requiredQueryParameter: number,
    options?: PagingGetWithQueryParamsOptionalParams,
  ): AsyncIterableIterator<Product> {
    for await (const page of this.getWithQueryParamsPagingPage(
      requiredQueryParameter,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * Define `filter` as a query param for all calls. However, the returned next link will also include
   * the `filter` as part of it. Make sure you don't end up duplicating the `filter` param in the url
   * sent.
   * @param options The options parameters.
   */
  public listDuplicateParams(
    options?: PagingDuplicateParamsOptionalParams,
  ): PagedAsyncIterableIterator<Product> {
    const iter = this.duplicateParamsPagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.duplicateParamsPagingPage(options, settings);
      },
    };
  }

  private async *duplicateParamsPagingPage(
    options?: PagingDuplicateParamsOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<Product[]> {
    let result: PagingDuplicateParamsResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._duplicateParams(options);
      let page = result.values || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._duplicateParamsNext(continuationToken, options);
      continuationToken = result.nextLink;
      let page = result.values || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *duplicateParamsPagingAll(
    options?: PagingDuplicateParamsOptionalParams,
  ): AsyncIterableIterator<Product> {
    for await (const page of this.duplicateParamsPagingPage(options)) {
      yield* page;
    }
  }

  /**
   * Paging with max page size. We don't want to
   * @param options The options parameters.
   */
  public listPageWithMaxPageSize(
    options?: PagingPageWithMaxPageSizeOptionalParams,
  ): PagedAsyncIterableIterator<Product> {
    const iter = this.pageWithMaxPageSizePagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.pageWithMaxPageSizePagingPage(options, settings);
      },
    };
  }

  private async *pageWithMaxPageSizePagingPage(
    options?: PagingPageWithMaxPageSizeOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<Product[]> {
    let result: PagingPageWithMaxPageSizeResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._pageWithMaxPageSize(options);
      let page = result.values || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._pageWithMaxPageSizeNext(continuationToken, options);
      continuationToken = result.nextLink;
      let page = result.values || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *pageWithMaxPageSizePagingAll(
    options?: PagingPageWithMaxPageSizeOptionalParams,
  ): AsyncIterableIterator<Product> {
    for await (const page of this.pageWithMaxPageSizePagingPage(options)) {
      yield* page;
    }
  }

  /**
   * A paging operation that includes a nextLink in odata format that has 10 pages
   * @param options The options parameters.
   */
  public listOdataMultiplePages(
    options?: PagingGetOdataMultiplePagesOptionalParams,
  ): PagedAsyncIterableIterator<Product> {
    const iter = this.getOdataMultiplePagesPagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.getOdataMultiplePagesPagingPage(options, settings);
      },
    };
  }

  private async *getOdataMultiplePagesPagingPage(
    options?: PagingGetOdataMultiplePagesOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<Product[]> {
    let result: PagingGetOdataMultiplePagesResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._getOdataMultiplePages(options);
      let page = result.values || [];
      continuationToken = result.odataNextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._getOdataMultiplePagesNext(
        continuationToken,
        options,
      );
      continuationToken = result.odataNextLink;
      let page = result.values || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *getOdataMultiplePagesPagingAll(
    options?: PagingGetOdataMultiplePagesOptionalParams,
  ): AsyncIterableIterator<Product> {
    for await (const page of this.getOdataMultiplePagesPagingPage(options)) {
      yield* page;
    }
  }

  /**
   * A paging operation that includes a nextLink that has 10 pages
   * @param pagingGetMultiplePagesWithOffsetOptions Parameter group
   * @param options The options parameters.
   */
  public listMultiplePagesWithOffset(
    pagingGetMultiplePagesWithOffsetOptions: PagingGetMultiplePagesWithOffsetOptions,
    options?: PagingGetMultiplePagesWithOffsetOptionalParams,
  ): PagedAsyncIterableIterator<Product> {
    const iter = this.getMultiplePagesWithOffsetPagingAll(
      pagingGetMultiplePagesWithOffsetOptions,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.getMultiplePagesWithOffsetPagingPage(
          pagingGetMultiplePagesWithOffsetOptions,
          options,
          settings,
        );
      },
    };
  }

  private async *getMultiplePagesWithOffsetPagingPage(
    pagingGetMultiplePagesWithOffsetOptions: PagingGetMultiplePagesWithOffsetOptions,
    options?: PagingGetMultiplePagesWithOffsetOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<Product[]> {
    let result: PagingGetMultiplePagesWithOffsetResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._getMultiplePagesWithOffset(
        pagingGetMultiplePagesWithOffsetOptions,
        options,
      );
      let page = result.values || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._getMultiplePagesWithOffsetNext(
        pagingGetMultiplePagesWithOffsetOptions,
        continuationToken,
        options,
      );
      continuationToken = result.nextLink;
      let page = result.values || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *getMultiplePagesWithOffsetPagingAll(
    pagingGetMultiplePagesWithOffsetOptions: PagingGetMultiplePagesWithOffsetOptions,
    options?: PagingGetMultiplePagesWithOffsetOptionalParams,
  ): AsyncIterableIterator<Product> {
    for await (const page of this.getMultiplePagesWithOffsetPagingPage(
      pagingGetMultiplePagesWithOffsetOptions,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * A paging operation that fails on the first call with 500 and then retries and then get a response
   * including a nextLink that has 10 pages
   * @param options The options parameters.
   */
  public listMultiplePagesRetryFirst(
    options?: PagingGetMultiplePagesRetryFirstOptionalParams,
  ): PagedAsyncIterableIterator<Product> {
    const iter = this.getMultiplePagesRetryFirstPagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.getMultiplePagesRetryFirstPagingPage(options, settings);
      },
    };
  }

  private async *getMultiplePagesRetryFirstPagingPage(
    options?: PagingGetMultiplePagesRetryFirstOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<Product[]> {
    let result: PagingGetMultiplePagesRetryFirstResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._getMultiplePagesRetryFirst(options);
      let page = result.values || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._getMultiplePagesRetryFirstNext(
        continuationToken,
        options,
      );
      continuationToken = result.nextLink;
      let page = result.values || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *getMultiplePagesRetryFirstPagingAll(
    options?: PagingGetMultiplePagesRetryFirstOptionalParams,
  ): AsyncIterableIterator<Product> {
    for await (const page of this.getMultiplePagesRetryFirstPagingPage(
      options,
    )) {
      yield* page;
    }
  }

  /**
   * A paging operation that includes a nextLink that has 10 pages, of which the 2nd call fails first
   * with 500. The client should retry and finish all 10 pages eventually.
   * @param options The options parameters.
   */
  public listMultiplePagesRetrySecond(
    options?: PagingGetMultiplePagesRetrySecondOptionalParams,
  ): PagedAsyncIterableIterator<Product> {
    const iter = this.getMultiplePagesRetrySecondPagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.getMultiplePagesRetrySecondPagingPage(options, settings);
      },
    };
  }

  private async *getMultiplePagesRetrySecondPagingPage(
    options?: PagingGetMultiplePagesRetrySecondOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<Product[]> {
    let result: PagingGetMultiplePagesRetrySecondResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._getMultiplePagesRetrySecond(options);
      let page = result.values || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._getMultiplePagesRetrySecondNext(
        continuationToken,
        options,
      );
      continuationToken = result.nextLink;
      let page = result.values || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *getMultiplePagesRetrySecondPagingAll(
    options?: PagingGetMultiplePagesRetrySecondOptionalParams,
  ): AsyncIterableIterator<Product> {
    for await (const page of this.getMultiplePagesRetrySecondPagingPage(
      options,
    )) {
      yield* page;
    }
  }

  /**
   * A paging operation that receives a 400 on the first call
   * @param options The options parameters.
   */
  public listSinglePagesFailure(
    options?: PagingGetSinglePagesFailureOptionalParams,
  ): PagedAsyncIterableIterator<Product> {
    const iter = this.getSinglePagesFailurePagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.getSinglePagesFailurePagingPage(options, settings);
      },
    };
  }

  private async *getSinglePagesFailurePagingPage(
    options?: PagingGetSinglePagesFailureOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<Product[]> {
    let result: PagingGetSinglePagesFailureResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._getSinglePagesFailure(options);
      let page = result.values || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._getSinglePagesFailureNext(
        continuationToken,
        options,
      );
      continuationToken = result.nextLink;
      let page = result.values || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *getSinglePagesFailurePagingAll(
    options?: PagingGetSinglePagesFailureOptionalParams,
  ): AsyncIterableIterator<Product> {
    for await (const page of this.getSinglePagesFailurePagingPage(options)) {
      yield* page;
    }
  }

  /**
   * A paging operation that receives a 400 on the second call
   * @param options The options parameters.
   */
  public listMultiplePagesFailure(
    options?: PagingGetMultiplePagesFailureOptionalParams,
  ): PagedAsyncIterableIterator<Product> {
    const iter = this.getMultiplePagesFailurePagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.getMultiplePagesFailurePagingPage(options, settings);
      },
    };
  }

  private async *getMultiplePagesFailurePagingPage(
    options?: PagingGetMultiplePagesFailureOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<Product[]> {
    let result: PagingGetMultiplePagesFailureResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._getMultiplePagesFailure(options);
      let page = result.values || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._getMultiplePagesFailureNext(
        continuationToken,
        options,
      );
      continuationToken = result.nextLink;
      let page = result.values || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *getMultiplePagesFailurePagingAll(
    options?: PagingGetMultiplePagesFailureOptionalParams,
  ): AsyncIterableIterator<Product> {
    for await (const page of this.getMultiplePagesFailurePagingPage(options)) {
      yield* page;
    }
  }

  /**
   * A paging operation that receives an invalid nextLink
   * @param options The options parameters.
   */
  public listMultiplePagesFailureUri(
    options?: PagingGetMultiplePagesFailureUriOptionalParams,
  ): PagedAsyncIterableIterator<Product> {
    const iter = this.getMultiplePagesFailureUriPagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.getMultiplePagesFailureUriPagingPage(options, settings);
      },
    };
  }

  private async *getMultiplePagesFailureUriPagingPage(
    options?: PagingGetMultiplePagesFailureUriOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<Product[]> {
    let result: PagingGetMultiplePagesFailureUriResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._getMultiplePagesFailureUri(options);
      let page = result.values || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._getMultiplePagesFailureUriNext(
        continuationToken,
        options,
      );
      continuationToken = result.nextLink;
      let page = result.values || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *getMultiplePagesFailureUriPagingAll(
    options?: PagingGetMultiplePagesFailureUriOptionalParams,
  ): AsyncIterableIterator<Product> {
    for await (const page of this.getMultiplePagesFailureUriPagingPage(
      options,
    )) {
      yield* page;
    }
  }

  /**
   * A paging operation that doesn't return a full URL, just a fragment
   * @param apiVersion Sets the api version to use.
   * @param tenant Sets the tenant to use.
   * @param options The options parameters.
   */
  public listMultiplePagesFragmentNextLink(
    apiVersion: string,
    tenant: string,
    options?: PagingGetMultiplePagesFragmentNextLinkOptionalParams,
  ): PagedAsyncIterableIterator<Product> {
    const iter = this.getMultiplePagesFragmentNextLinkPagingAll(
      apiVersion,
      tenant,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.getMultiplePagesFragmentNextLinkPagingPage(
          apiVersion,
          tenant,
          options,
          settings,
        );
      },
    };
  }

  private async *getMultiplePagesFragmentNextLinkPagingPage(
    apiVersion: string,
    tenant: string,
    options?: PagingGetMultiplePagesFragmentNextLinkOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<Product[]> {
    let result: PagingGetMultiplePagesFragmentNextLinkResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._getMultiplePagesFragmentNextLink(
        apiVersion,
        tenant,
        options,
      );
      let page = result.values || [];
      continuationToken = result.odataNextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._nextFragment(
        apiVersion,
        tenant,
        continuationToken,
        options,
      );
      continuationToken = result.odataNextLink;
      let page = result.values || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *getMultiplePagesFragmentNextLinkPagingAll(
    apiVersion: string,
    tenant: string,
    options?: PagingGetMultiplePagesFragmentNextLinkOptionalParams,
  ): AsyncIterableIterator<Product> {
    for await (const page of this.getMultiplePagesFragmentNextLinkPagingPage(
      apiVersion,
      tenant,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * A paging operation that doesn't return a full URL, just a fragment with parameters grouped
   * @param customParameterGroup Parameter group
   * @param options The options parameters.
   */
  public listMultiplePagesFragmentWithGroupingNextLink(
    customParameterGroup: CustomParameterGroup,
    options?: PagingGetMultiplePagesFragmentWithGroupingNextLinkOptionalParams,
  ): PagedAsyncIterableIterator<Product> {
    const iter = this.getMultiplePagesFragmentWithGroupingNextLinkPagingAll(
      customParameterGroup,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.getMultiplePagesFragmentWithGroupingNextLinkPagingPage(
          customParameterGroup,
          options,
          settings,
        );
      },
    };
  }

  private async *getMultiplePagesFragmentWithGroupingNextLinkPagingPage(
    customParameterGroup: CustomParameterGroup,
    options?: PagingGetMultiplePagesFragmentWithGroupingNextLinkOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<Product[]> {
    let result: PagingGetMultiplePagesFragmentWithGroupingNextLinkResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._getMultiplePagesFragmentWithGroupingNextLink(
        customParameterGroup,
        options,
      );
      let page = result.values || [];
      continuationToken = result.odataNextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._nextFragmentWithGrouping(
        continuationToken,
        customParameterGroup,
        options,
      );
      continuationToken = result.odataNextLink;
      let page = result.values || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *getMultiplePagesFragmentWithGroupingNextLinkPagingAll(
    customParameterGroup: CustomParameterGroup,
    options?: PagingGetMultiplePagesFragmentWithGroupingNextLinkOptionalParams,
  ): AsyncIterableIterator<Product> {
    for await (const page of this.getMultiplePagesFragmentWithGroupingNextLinkPagingPage(
      customParameterGroup,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * A long-running paging operation that includes a nextLink that has 10 pages
   * @param options The options parameters.
   */
  public beginListMultiplePagesLROAndWait(
    options?: PagingGetMultiplePagesLROOptionalParams,
  ): PagedAsyncIterableIterator<Product> {
    const iter = this.getMultiplePagesLROPagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.getMultiplePagesLROPagingPage(options, settings);
      },
    };
  }

  private async *getMultiplePagesLROPagingPage(
    options?: PagingGetMultiplePagesLROOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<Product[]> {
    let result: PagingGetMultiplePagesLROResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      const poller = await this._getMultiplePagesLRO(options);
      result = await poller.pollUntilDone();
      let page = result.values || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._getMultiplePagesLRONext(continuationToken, options);
      continuationToken = result.nextLink;
      let page = result.values || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *getMultiplePagesLROPagingAll(
    options?: PagingGetMultiplePagesLROOptionalParams,
  ): AsyncIterableIterator<Product> {
    for await (const page of this.getMultiplePagesLROPagingPage(options)) {
      yield* page;
    }
  }

  /**
   * A paging operation with api version. When calling the next link, you want to append your client's
   * api version to the next link
   * @param options The options parameters.
   */
  public listAppendApiVersion(
    options?: PagingAppendApiVersionOptionalParams,
  ): PagedAsyncIterableIterator<Product> {
    const iter = this.appendApiVersionPagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.appendApiVersionPagingPage(options, settings);
      },
    };
  }

  private async *appendApiVersionPagingPage(
    options?: PagingAppendApiVersionOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<Product[]> {
    let result: PagingAppendApiVersionResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._appendApiVersion(options);
      let page = result.values || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._appendApiVersionNext(continuationToken, options);
      continuationToken = result.nextLink;
      let page = result.values || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *appendApiVersionPagingAll(
    options?: PagingAppendApiVersionOptionalParams,
  ): AsyncIterableIterator<Product> {
    for await (const page of this.appendApiVersionPagingPage(options)) {
      yield* page;
    }
  }

  /**
   * A paging operation with api version. When calling the next link, you want to reformat it and
   * override the returned api version with your client's api version
   * @param options The options parameters.
   */
  public listReplaceApiVersion(
    options?: PagingReplaceApiVersionOptionalParams,
  ): PagedAsyncIterableIterator<Product> {
    const iter = this.replaceApiVersionPagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.replaceApiVersionPagingPage(options, settings);
      },
    };
  }

  private async *replaceApiVersionPagingPage(
    options?: PagingReplaceApiVersionOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<Product[]> {
    let result: PagingReplaceApiVersionResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._replaceApiVersion(options);
      let page = result.values || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._replaceApiVersionNext(continuationToken, options);
      continuationToken = result.nextLink;
      let page = result.values || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *replaceApiVersionPagingAll(
    options?: PagingReplaceApiVersionOptionalParams,
  ): AsyncIterableIterator<Product> {
    for await (const page of this.replaceApiVersionPagingPage(options)) {
      yield* page;
    }
  }

  /**
   * A paging operation that doesn't return a full URL, just a fragment
   * @param apiVersion Sets the api version to use.
   * @param tenant Sets the tenant to use.
   * @param nextLink Next link for list operation.
   * @param options The options parameters.
   */
  public listNextFragment(
    apiVersion: string,
    tenant: string,
    nextLink: string,
    options?: PagingNextFragmentOptionalParams,
  ): PagedAsyncIterableIterator<Product> {
    const iter = this.nextFragmentPagingAll(
      apiVersion,
      tenant,
      nextLink,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.nextFragmentPagingPage(
          apiVersion,
          tenant,
          nextLink,
          options,
          settings,
        );
      },
    };
  }

  private async *nextFragmentPagingPage(
    apiVersion: string,
    tenant: string,
    nextLink: string,
    options?: PagingNextFragmentOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<Product[]> {
    let result: PagingNextFragmentResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._nextFragment(apiVersion, tenant, nextLink, options);
      let page = result.values || [];
      continuationToken = result.odataNextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._nextFragment(
        apiVersion,
        tenant,
        continuationToken,
        options,
      );
      continuationToken = result.odataNextLink;
      let page = result.values || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *nextFragmentPagingAll(
    apiVersion: string,
    tenant: string,
    nextLink: string,
    options?: PagingNextFragmentOptionalParams,
  ): AsyncIterableIterator<Product> {
    for await (const page of this.nextFragmentPagingPage(
      apiVersion,
      tenant,
      nextLink,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * A paging operation that doesn't return a full URL, just a fragment
   * @param nextLink Next link for list operation.
   * @param customParameterGroup Parameter group
   * @param options The options parameters.
   */
  public listNextFragmentWithGrouping(
    nextLink: string,
    customParameterGroup: CustomParameterGroup,
    options?: PagingNextFragmentWithGroupingOptionalParams,
  ): PagedAsyncIterableIterator<Product> {
    const iter = this.nextFragmentWithGroupingPagingAll(
      nextLink,
      customParameterGroup,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.nextFragmentWithGroupingPagingPage(
          nextLink,
          customParameterGroup,
          options,
          settings,
        );
      },
    };
  }

  private async *nextFragmentWithGroupingPagingPage(
    nextLink: string,
    customParameterGroup: CustomParameterGroup,
    options?: PagingNextFragmentWithGroupingOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<Product[]> {
    let result: PagingNextFragmentWithGroupingResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._nextFragmentWithGrouping(
        nextLink,
        customParameterGroup,
        options,
      );
      let page = result.values || [];
      continuationToken = result.odataNextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._nextFragmentWithGrouping(
        continuationToken,
        customParameterGroup,
        options,
      );
      continuationToken = result.odataNextLink;
      let page = result.values || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *nextFragmentWithGroupingPagingAll(
    nextLink: string,
    customParameterGroup: CustomParameterGroup,
    options?: PagingNextFragmentWithGroupingOptionalParams,
  ): AsyncIterableIterator<Product> {
    for await (const page of this.nextFragmentWithGroupingPagingPage(
      nextLink,
      customParameterGroup,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * A paging operation that returns a paging model whose item name is is overriden by x-ms-client-name
   * 'indexes'.
   * @param options The options parameters.
   */
  public listPagingModelWithItemNameWithXMSClientName(
    options?: PagingGetPagingModelWithItemNameWithXMSClientNameOptionalParams,
  ): PagedAsyncIterableIterator<Product> {
    const iter =
      this.getPagingModelWithItemNameWithXMSClientNamePagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.getPagingModelWithItemNameWithXMSClientNamePagingPage(
          options,
          settings,
        );
      },
    };
  }

  private async *getPagingModelWithItemNameWithXMSClientNamePagingPage(
    options?: PagingGetPagingModelWithItemNameWithXMSClientNameOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<Product[]> {
    let result: PagingGetPagingModelWithItemNameWithXMSClientNameResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._getPagingModelWithItemNameWithXMSClientName(options);
      let page = result.indexes || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._getPagingModelWithItemNameWithXMSClientNameNext(
        continuationToken,
        options,
      );
      continuationToken = result.nextLink;
      let page = result.indexes || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *getPagingModelWithItemNameWithXMSClientNamePagingAll(
    options?: PagingGetPagingModelWithItemNameWithXMSClientNameOptionalParams,
  ): AsyncIterableIterator<Product> {
    for await (const page of this.getPagingModelWithItemNameWithXMSClientNamePagingPage(
      options,
    )) {
      yield* page;
    }
  }

  /**
   * A paging operation that must return result of the default 'value' node.
   * @param options The options parameters.
   */
  private async _getNoItemNamePages(
    options?: PagingGetNoItemNamePagesOptionalParams,
  ): Promise<PagingGetNoItemNamePagesResponse> {
    return tracingClient.withSpan(
      "PagingClient._getNoItemNamePages",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { options },
          getNoItemNamePagesOperationSpec,
        ) as Promise<PagingGetNoItemNamePagesResponse>;
      },
    );
  }

  /**
   * A paging operation that gets an empty next link and should stop after page 1.
   * @param options The options parameters.
   */
  private async _getEmptyNextLinkNamePages(
    options?: PagingGetEmptyNextLinkNamePagesOptionalParams,
  ): Promise<PagingGetEmptyNextLinkNamePagesResponse> {
    return tracingClient.withSpan(
      "PagingClient._getEmptyNextLinkNamePages",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { options },
          getEmptyNextLinkNamePagesOperationSpec,
        ) as Promise<PagingGetEmptyNextLinkNamePagesResponse>;
      },
    );
  }

  /**
   * A paging operation that must ignore any kind of nextLink, and stop after page 1.
   * @param options The options parameters.
   */
  private async _getNullNextLinkNamePages(
    options?: PagingGetNullNextLinkNamePagesOptionalParams,
  ): Promise<PagingGetNullNextLinkNamePagesResponse> {
    return tracingClient.withSpan(
      "PagingClient._getNullNextLinkNamePages",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { options },
          getNullNextLinkNamePagesOperationSpec,
        ) as Promise<PagingGetNullNextLinkNamePagesResponse>;
      },
    );
  }

  /**
   * A paging operation that finishes on the first call without a nextlink
   * @param options The options parameters.
   */
  private async _getSinglePages(
    options?: PagingGetSinglePagesOptionalParams,
  ): Promise<PagingGetSinglePagesResponse> {
    return tracingClient.withSpan(
      "PagingClient._getSinglePages",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { options },
          getSinglePagesOperationSpec,
        ) as Promise<PagingGetSinglePagesResponse>;
      },
    );
  }

  /**
   * A paging operation that finishes on the first call with body params without a nextlink
   * @param parameters put {'name': 'body'} to pass the test
   * @param options The options parameters.
   */
  private async _getSinglePagesWithBodyParams(
    parameters: BodyParam,
    options?: PagingGetSinglePagesWithBodyParamsOptionalParams,
  ): Promise<PagingGetSinglePagesWithBodyParamsResponse> {
    return tracingClient.withSpan(
      "PagingClient._getSinglePagesWithBodyParams",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { parameters, options },
          getSinglePagesWithBodyParamsOperationSpec,
        ) as Promise<PagingGetSinglePagesWithBodyParamsResponse>;
      },
    );
  }

  /**
   * A paging operation whose first response's items list is empty, but still returns a next link. Second
   * (and final) call, will give you an items list of 1.
   * @param options The options parameters.
   */
  private async _firstResponseEmpty(
    options?: PagingFirstResponseEmptyOptionalParams,
  ): Promise<PagingFirstResponseEmptyResponse> {
    return tracingClient.withSpan(
      "PagingClient._firstResponseEmpty",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { options },
          firstResponseEmptyOperationSpec,
        ) as Promise<PagingFirstResponseEmptyResponse>;
      },
    );
  }

  /**
   * A paging operation that includes a nextLink that has 10 pages
   * @param options The options parameters.
   */
  private async _getMultiplePages(
    options?: PagingGetMultiplePagesOptionalParams,
  ): Promise<PagingGetMultiplePagesResponse> {
    return tracingClient.withSpan(
      "PagingClient._getMultiplePages",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { options },
          getMultiplePagesOperationSpec,
        ) as Promise<PagingGetMultiplePagesResponse>;
      },
    );
  }

  /**
   * A paging operation that includes a next operation. It has a different query parameter from it's next
   * operation nextOperationWithQueryParams. Returns a ProductResult
   * @param requiredQueryParameter A required integer query parameter. Put in value '100' to pass test.
   * @param options The options parameters.
   */
  private async _getWithQueryParams(
    requiredQueryParameter: number,
    options?: PagingGetWithQueryParamsOptionalParams,
  ): Promise<PagingGetWithQueryParamsResponse> {
    return tracingClient.withSpan(
      "PagingClient._getWithQueryParams",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { requiredQueryParameter, options },
          getWithQueryParamsOperationSpec,
        ) as Promise<PagingGetWithQueryParamsResponse>;
      },
    );
  }

  /**
   * Define `filter` as a query param for all calls. However, the returned next link will also include
   * the `filter` as part of it. Make sure you don't end up duplicating the `filter` param in the url
   * sent.
   * @param options The options parameters.
   */
  private async _duplicateParams(
    options?: PagingDuplicateParamsOptionalParams,
  ): Promise<PagingDuplicateParamsResponse> {
    return tracingClient.withSpan(
      "PagingClient._duplicateParams",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { options },
          duplicateParamsOperationSpec,
        ) as Promise<PagingDuplicateParamsResponse>;
      },
    );
  }

  /**
   * Paging with max page size. We don't want to
   * @param options The options parameters.
   */
  private async _pageWithMaxPageSize(
    options?: PagingPageWithMaxPageSizeOptionalParams,
  ): Promise<PagingPageWithMaxPageSizeResponse> {
    return tracingClient.withSpan(
      "PagingClient._pageWithMaxPageSize",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { options },
          pageWithMaxPageSizeOperationSpec,
        ) as Promise<PagingPageWithMaxPageSizeResponse>;
      },
    );
  }

  /**
   * Next operation for getWithQueryParams. Pass in next=True to pass test. Returns a ProductResult
   * @param options The options parameters.
   */
  private async _nextOperationWithQueryParams(
    options?: PagingNextOperationWithQueryParamsOptionalParams,
  ): Promise<PagingNextOperationWithQueryParamsResponse> {
    return tracingClient.withSpan(
      "PagingClient._nextOperationWithQueryParams",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { options },
          nextOperationWithQueryParamsOperationSpec,
        ) as Promise<PagingNextOperationWithQueryParamsResponse>;
      },
    );
  }

  /**
   * A paging operation that includes a nextLink in odata format that has 10 pages
   * @param options The options parameters.
   */
  private async _getOdataMultiplePages(
    options?: PagingGetOdataMultiplePagesOptionalParams,
  ): Promise<PagingGetOdataMultiplePagesResponse> {
    return tracingClient.withSpan(
      "PagingClient._getOdataMultiplePages",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { options },
          getOdataMultiplePagesOperationSpec,
        ) as Promise<PagingGetOdataMultiplePagesResponse>;
      },
    );
  }

  /**
   * A paging operation that includes a nextLink that has 10 pages
   * @param pagingGetMultiplePagesWithOffsetOptions Parameter group
   * @param options The options parameters.
   */
  private async _getMultiplePagesWithOffset(
    pagingGetMultiplePagesWithOffsetOptions: PagingGetMultiplePagesWithOffsetOptions,
    options?: PagingGetMultiplePagesWithOffsetOptionalParams,
  ): Promise<PagingGetMultiplePagesWithOffsetResponse> {
    return tracingClient.withSpan(
      "PagingClient._getMultiplePagesWithOffset",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { pagingGetMultiplePagesWithOffsetOptions, options },
          getMultiplePagesWithOffsetOperationSpec,
        ) as Promise<PagingGetMultiplePagesWithOffsetResponse>;
      },
    );
  }

  /**
   * A paging operation that fails on the first call with 500 and then retries and then get a response
   * including a nextLink that has 10 pages
   * @param options The options parameters.
   */
  private async _getMultiplePagesRetryFirst(
    options?: PagingGetMultiplePagesRetryFirstOptionalParams,
  ): Promise<PagingGetMultiplePagesRetryFirstResponse> {
    return tracingClient.withSpan(
      "PagingClient._getMultiplePagesRetryFirst",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { options },
          getMultiplePagesRetryFirstOperationSpec,
        ) as Promise<PagingGetMultiplePagesRetryFirstResponse>;
      },
    );
  }

  /**
   * A paging operation that includes a nextLink that has 10 pages, of which the 2nd call fails first
   * with 500. The client should retry and finish all 10 pages eventually.
   * @param options The options parameters.
   */
  private async _getMultiplePagesRetrySecond(
    options?: PagingGetMultiplePagesRetrySecondOptionalParams,
  ): Promise<PagingGetMultiplePagesRetrySecondResponse> {
    return tracingClient.withSpan(
      "PagingClient._getMultiplePagesRetrySecond",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { options },
          getMultiplePagesRetrySecondOperationSpec,
        ) as Promise<PagingGetMultiplePagesRetrySecondResponse>;
      },
    );
  }

  /**
   * A paging operation that receives a 400 on the first call
   * @param options The options parameters.
   */
  private async _getSinglePagesFailure(
    options?: PagingGetSinglePagesFailureOptionalParams,
  ): Promise<PagingGetSinglePagesFailureResponse> {
    return tracingClient.withSpan(
      "PagingClient._getSinglePagesFailure",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { options },
          getSinglePagesFailureOperationSpec,
        ) as Promise<PagingGetSinglePagesFailureResponse>;
      },
    );
  }

  /**
   * A paging operation that receives a 400 on the second call
   * @param options The options parameters.
   */
  private async _getMultiplePagesFailure(
    options?: PagingGetMultiplePagesFailureOptionalParams,
  ): Promise<PagingGetMultiplePagesFailureResponse> {
    return tracingClient.withSpan(
      "PagingClient._getMultiplePagesFailure",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { options },
          getMultiplePagesFailureOperationSpec,
        ) as Promise<PagingGetMultiplePagesFailureResponse>;
      },
    );
  }

  /**
   * A paging operation that receives an invalid nextLink
   * @param options The options parameters.
   */
  private async _getMultiplePagesFailureUri(
    options?: PagingGetMultiplePagesFailureUriOptionalParams,
  ): Promise<PagingGetMultiplePagesFailureUriResponse> {
    return tracingClient.withSpan(
      "PagingClient._getMultiplePagesFailureUri",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { options },
          getMultiplePagesFailureUriOperationSpec,
        ) as Promise<PagingGetMultiplePagesFailureUriResponse>;
      },
    );
  }

  /**
   * A paging operation that doesn't return a full URL, just a fragment
   * @param apiVersion Sets the api version to use.
   * @param tenant Sets the tenant to use.
   * @param options The options parameters.
   */
  private async _getMultiplePagesFragmentNextLink(
    apiVersion: string,
    tenant: string,
    options?: PagingGetMultiplePagesFragmentNextLinkOptionalParams,
  ): Promise<PagingGetMultiplePagesFragmentNextLinkResponse> {
    return tracingClient.withSpan(
      "PagingClient._getMultiplePagesFragmentNextLink",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { apiVersion, tenant, options },
          getMultiplePagesFragmentNextLinkOperationSpec,
        ) as Promise<PagingGetMultiplePagesFragmentNextLinkResponse>;
      },
    );
  }

  /**
   * A paging operation that doesn't return a full URL, just a fragment with parameters grouped
   * @param customParameterGroup Parameter group
   * @param options The options parameters.
   */
  private async _getMultiplePagesFragmentWithGroupingNextLink(
    customParameterGroup: CustomParameterGroup,
    options?: PagingGetMultiplePagesFragmentWithGroupingNextLinkOptionalParams,
  ): Promise<PagingGetMultiplePagesFragmentWithGroupingNextLinkResponse> {
    return tracingClient.withSpan(
      "PagingClient._getMultiplePagesFragmentWithGroupingNextLink",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { customParameterGroup, options },
          getMultiplePagesFragmentWithGroupingNextLinkOperationSpec,
        ) as Promise<PagingGetMultiplePagesFragmentWithGroupingNextLinkResponse>;
      },
    );
  }

  /**
   * A long-running paging operation that includes a nextLink that has 10 pages
   * @param options The options parameters.
   */
  private async _getMultiplePagesLRO(
    options?: PagingGetMultiplePagesLROOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<PagingGetMultiplePagesLROResponse>,
      PagingGetMultiplePagesLROResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<PagingGetMultiplePagesLROResponse> => {
      return tracingClient.withSpan(
        "PagingClient._getMultiplePagesLRO",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(
            args,
            spec,
          ) as Promise<PagingGetMultiplePagesLROResponse>;
        },
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { options },
      spec: getMultiplePagesLROOperationSpec,
    });
    const poller = await createHttpPoller<
      PagingGetMultiplePagesLROResponse,
      OperationState<PagingGetMultiplePagesLROResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * A paging operation with api version. When calling the next link, you want to append your client's
   * api version to the next link
   * @param options The options parameters.
   */
  private async _appendApiVersion(
    options?: PagingAppendApiVersionOptionalParams,
  ): Promise<PagingAppendApiVersionResponse> {
    return tracingClient.withSpan(
      "PagingClient._appendApiVersion",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { options },
          appendApiVersionOperationSpec,
        ) as Promise<PagingAppendApiVersionResponse>;
      },
    );
  }

  /**
   * A paging operation with api version. When calling the next link, you want to reformat it and
   * override the returned api version with your client's api version
   * @param options The options parameters.
   */
  private async _replaceApiVersion(
    options?: PagingReplaceApiVersionOptionalParams,
  ): Promise<PagingReplaceApiVersionResponse> {
    return tracingClient.withSpan(
      "PagingClient._replaceApiVersion",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { options },
          replaceApiVersionOperationSpec,
        ) as Promise<PagingReplaceApiVersionResponse>;
      },
    );
  }

  /**
   * A paging operation that doesn't return a full URL, just a fragment
   * @param apiVersion Sets the api version to use.
   * @param tenant Sets the tenant to use.
   * @param nextLink Next link for list operation.
   * @param options The options parameters.
   */
  private async _nextFragment(
    apiVersion: string,
    tenant: string,
    nextLink: string,
    options?: PagingNextFragmentOptionalParams,
  ): Promise<PagingNextFragmentResponse> {
    return tracingClient.withSpan(
      "PagingClient._nextFragment",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { apiVersion, tenant, nextLink, options },
          nextFragmentOperationSpec,
        ) as Promise<PagingNextFragmentResponse>;
      },
    );
  }

  /**
   * A paging operation that doesn't return a full URL, just a fragment
   * @param nextLink Next link for list operation.
   * @param customParameterGroup Parameter group
   * @param options The options parameters.
   */
  private async _nextFragmentWithGrouping(
    nextLink: string,
    customParameterGroup: CustomParameterGroup,
    options?: PagingNextFragmentWithGroupingOptionalParams,
  ): Promise<PagingNextFragmentWithGroupingResponse> {
    return tracingClient.withSpan(
      "PagingClient._nextFragmentWithGrouping",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { nextLink, customParameterGroup, options },
          nextFragmentWithGroupingOperationSpec,
        ) as Promise<PagingNextFragmentWithGroupingResponse>;
      },
    );
  }

  /**
   * A paging operation that returns a paging model whose item name is is overriden by x-ms-client-name
   * 'indexes'.
   * @param options The options parameters.
   */
  private async _getPagingModelWithItemNameWithXMSClientName(
    options?: PagingGetPagingModelWithItemNameWithXMSClientNameOptionalParams,
  ): Promise<PagingGetPagingModelWithItemNameWithXMSClientNameResponse> {
    return tracingClient.withSpan(
      "PagingClient._getPagingModelWithItemNameWithXMSClientName",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { options },
          getPagingModelWithItemNameWithXMSClientNameOperationSpec,
        ) as Promise<PagingGetPagingModelWithItemNameWithXMSClientNameResponse>;
      },
    );
  }

  /**
   * GetNoItemNamePagesNext
   * @param nextLink The nextLink from the previous successful call to the GetNoItemNamePages method.
   * @param options The options parameters.
   */
  private async _getNoItemNamePagesNext(
    nextLink: string,
    options?: PagingGetNoItemNamePagesNextOptionalParams,
  ): Promise<PagingGetNoItemNamePagesNextResponse> {
    return tracingClient.withSpan(
      "PagingClient._getNoItemNamePagesNext",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { nextLink, options },
          getNoItemNamePagesNextOperationSpec,
        ) as Promise<PagingGetNoItemNamePagesNextResponse>;
      },
    );
  }

  /**
   * GetEmptyNextLinkNamePagesNext
   * @param nextLink The nextLink from the previous successful call to the GetEmptyNextLinkNamePages
   *                 method.
   * @param options The options parameters.
   */
  private async _getEmptyNextLinkNamePagesNext(
    nextLink: string,
    options?: PagingGetEmptyNextLinkNamePagesNextOptionalParams,
  ): Promise<PagingGetEmptyNextLinkNamePagesNextResponse> {
    return tracingClient.withSpan(
      "PagingClient._getEmptyNextLinkNamePagesNext",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { nextLink, options },
          getEmptyNextLinkNamePagesNextOperationSpec,
        ) as Promise<PagingGetEmptyNextLinkNamePagesNextResponse>;
      },
    );
  }

  /**
   * GetSinglePagesNext
   * @param nextLink The nextLink from the previous successful call to the GetSinglePages method.
   * @param options The options parameters.
   */
  private async _getSinglePagesNext(
    nextLink: string,
    options?: PagingGetSinglePagesNextOptionalParams,
  ): Promise<PagingGetSinglePagesNextResponse> {
    return tracingClient.withSpan(
      "PagingClient._getSinglePagesNext",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { nextLink, options },
          getSinglePagesNextOperationSpec,
        ) as Promise<PagingGetSinglePagesNextResponse>;
      },
    );
  }

  /**
   * GetSinglePagesWithBodyParamsNext
   * @param parameters put {'name': 'body'} to pass the test
   * @param nextLink The nextLink from the previous successful call to the GetSinglePagesWithBodyParams
   *                 method.
   * @param options The options parameters.
   */
  private async _getSinglePagesWithBodyParamsNext(
    parameters: BodyParam,
    nextLink: string,
    options?: PagingGetSinglePagesWithBodyParamsNextOptionalParams,
  ): Promise<PagingGetSinglePagesWithBodyParamsNextResponse> {
    return tracingClient.withSpan(
      "PagingClient._getSinglePagesWithBodyParamsNext",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { parameters, nextLink, options },
          getSinglePagesWithBodyParamsNextOperationSpec,
        ) as Promise<PagingGetSinglePagesWithBodyParamsNextResponse>;
      },
    );
  }

  /**
   * FirstResponseEmptyNext
   * @param nextLink The nextLink from the previous successful call to the FirstResponseEmpty method.
   * @param options The options parameters.
   */
  private async _firstResponseEmptyNext(
    nextLink: string,
    options?: PagingFirstResponseEmptyNextOptionalParams,
  ): Promise<PagingFirstResponseEmptyNextResponse> {
    return tracingClient.withSpan(
      "PagingClient._firstResponseEmptyNext",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { nextLink, options },
          firstResponseEmptyNextOperationSpec,
        ) as Promise<PagingFirstResponseEmptyNextResponse>;
      },
    );
  }

  /**
   * GetMultiplePagesNext
   * @param nextLink The nextLink from the previous successful call to the GetMultiplePages method.
   * @param options The options parameters.
   */
  private async _getMultiplePagesNext(
    nextLink: string,
    options?: PagingGetMultiplePagesNextOptionalParams,
  ): Promise<PagingGetMultiplePagesNextResponse> {
    return tracingClient.withSpan(
      "PagingClient._getMultiplePagesNext",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { nextLink, options },
          getMultiplePagesNextOperationSpec,
        ) as Promise<PagingGetMultiplePagesNextResponse>;
      },
    );
  }

  /**
   * DuplicateParamsNext
   * @param nextLink The nextLink from the previous successful call to the DuplicateParams method.
   * @param options The options parameters.
   */
  private async _duplicateParamsNext(
    nextLink: string,
    options?: PagingDuplicateParamsNextOptionalParams,
  ): Promise<PagingDuplicateParamsNextResponse> {
    return tracingClient.withSpan(
      "PagingClient._duplicateParamsNext",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { nextLink, options },
          duplicateParamsNextOperationSpec,
        ) as Promise<PagingDuplicateParamsNextResponse>;
      },
    );
  }

  /**
   * PageWithMaxPageSizeNext
   * @param nextLink The nextLink from the previous successful call to the PageWithMaxPageSize method.
   * @param options The options parameters.
   */
  private async _pageWithMaxPageSizeNext(
    nextLink: string,
    options?: PagingPageWithMaxPageSizeNextOptionalParams,
  ): Promise<PagingPageWithMaxPageSizeNextResponse> {
    return tracingClient.withSpan(
      "PagingClient._pageWithMaxPageSizeNext",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { nextLink, options },
          pageWithMaxPageSizeNextOperationSpec,
        ) as Promise<PagingPageWithMaxPageSizeNextResponse>;
      },
    );
  }

  /**
   * GetOdataMultiplePagesNext
   * @param nextLink The nextLink from the previous successful call to the GetOdataMultiplePages method.
   * @param options The options parameters.
   */
  private async _getOdataMultiplePagesNext(
    nextLink: string,
    options?: PagingGetOdataMultiplePagesNextOptionalParams,
  ): Promise<PagingGetOdataMultiplePagesNextResponse> {
    return tracingClient.withSpan(
      "PagingClient._getOdataMultiplePagesNext",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { nextLink, options },
          getOdataMultiplePagesNextOperationSpec,
        ) as Promise<PagingGetOdataMultiplePagesNextResponse>;
      },
    );
  }

  /**
   * GetMultiplePagesWithOffsetNext
   * @param pagingGetMultiplePagesWithOffsetOptions Parameter group
   * @param nextLink The nextLink from the previous successful call to the GetMultiplePagesWithOffset
   *                 method.
   * @param options The options parameters.
   */
  private async _getMultiplePagesWithOffsetNext(
    pagingGetMultiplePagesWithOffsetOptions: PagingGetMultiplePagesWithOffsetOptions,
    nextLink: string,
    options?: PagingGetMultiplePagesWithOffsetNextOptionalParams,
  ): Promise<PagingGetMultiplePagesWithOffsetNextResponse> {
    return tracingClient.withSpan(
      "PagingClient._getMultiplePagesWithOffsetNext",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { pagingGetMultiplePagesWithOffsetOptions, nextLink, options },
          getMultiplePagesWithOffsetNextOperationSpec,
        ) as Promise<PagingGetMultiplePagesWithOffsetNextResponse>;
      },
    );
  }

  /**
   * GetMultiplePagesRetryFirstNext
   * @param nextLink The nextLink from the previous successful call to the GetMultiplePagesRetryFirst
   *                 method.
   * @param options The options parameters.
   */
  private async _getMultiplePagesRetryFirstNext(
    nextLink: string,
    options?: PagingGetMultiplePagesRetryFirstNextOptionalParams,
  ): Promise<PagingGetMultiplePagesRetryFirstNextResponse> {
    return tracingClient.withSpan(
      "PagingClient._getMultiplePagesRetryFirstNext",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { nextLink, options },
          getMultiplePagesRetryFirstNextOperationSpec,
        ) as Promise<PagingGetMultiplePagesRetryFirstNextResponse>;
      },
    );
  }

  /**
   * GetMultiplePagesRetrySecondNext
   * @param nextLink The nextLink from the previous successful call to the GetMultiplePagesRetrySecond
   *                 method.
   * @param options The options parameters.
   */
  private async _getMultiplePagesRetrySecondNext(
    nextLink: string,
    options?: PagingGetMultiplePagesRetrySecondNextOptionalParams,
  ): Promise<PagingGetMultiplePagesRetrySecondNextResponse> {
    return tracingClient.withSpan(
      "PagingClient._getMultiplePagesRetrySecondNext",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { nextLink, options },
          getMultiplePagesRetrySecondNextOperationSpec,
        ) as Promise<PagingGetMultiplePagesRetrySecondNextResponse>;
      },
    );
  }

  /**
   * GetSinglePagesFailureNext
   * @param nextLink The nextLink from the previous successful call to the GetSinglePagesFailure method.
   * @param options The options parameters.
   */
  private async _getSinglePagesFailureNext(
    nextLink: string,
    options?: PagingGetSinglePagesFailureNextOptionalParams,
  ): Promise<PagingGetSinglePagesFailureNextResponse> {
    return tracingClient.withSpan(
      "PagingClient._getSinglePagesFailureNext",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { nextLink, options },
          getSinglePagesFailureNextOperationSpec,
        ) as Promise<PagingGetSinglePagesFailureNextResponse>;
      },
    );
  }

  /**
   * GetMultiplePagesFailureNext
   * @param nextLink The nextLink from the previous successful call to the GetMultiplePagesFailure
   *                 method.
   * @param options The options parameters.
   */
  private async _getMultiplePagesFailureNext(
    nextLink: string,
    options?: PagingGetMultiplePagesFailureNextOptionalParams,
  ): Promise<PagingGetMultiplePagesFailureNextResponse> {
    return tracingClient.withSpan(
      "PagingClient._getMultiplePagesFailureNext",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { nextLink, options },
          getMultiplePagesFailureNextOperationSpec,
        ) as Promise<PagingGetMultiplePagesFailureNextResponse>;
      },
    );
  }

  /**
   * GetMultiplePagesFailureUriNext
   * @param nextLink The nextLink from the previous successful call to the GetMultiplePagesFailureUri
   *                 method.
   * @param options The options parameters.
   */
  private async _getMultiplePagesFailureUriNext(
    nextLink: string,
    options?: PagingGetMultiplePagesFailureUriNextOptionalParams,
  ): Promise<PagingGetMultiplePagesFailureUriNextResponse> {
    return tracingClient.withSpan(
      "PagingClient._getMultiplePagesFailureUriNext",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { nextLink, options },
          getMultiplePagesFailureUriNextOperationSpec,
        ) as Promise<PagingGetMultiplePagesFailureUriNextResponse>;
      },
    );
  }

  /**
   * GetMultiplePagesLRONext
   * @param nextLink The nextLink from the previous successful call to the GetMultiplePagesLRO method.
   * @param options The options parameters.
   */
  private async _getMultiplePagesLRONext(
    nextLink: string,
    options?: PagingGetMultiplePagesLRONextOptionalParams,
  ): Promise<PagingGetMultiplePagesLRONextResponse> {
    return tracingClient.withSpan(
      "PagingClient._getMultiplePagesLRONext",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { nextLink, options },
          getMultiplePagesLRONextOperationSpec,
        ) as Promise<PagingGetMultiplePagesLRONextResponse>;
      },
    );
  }

  /**
   * AppendApiVersionNext
   * @param nextLink The nextLink from the previous successful call to the AppendApiVersion method.
   * @param options The options parameters.
   */
  private async _appendApiVersionNext(
    nextLink: string,
    options?: PagingAppendApiVersionNextOptionalParams,
  ): Promise<PagingAppendApiVersionNextResponse> {
    return tracingClient.withSpan(
      "PagingClient._appendApiVersionNext",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { nextLink, options },
          appendApiVersionNextOperationSpec,
        ) as Promise<PagingAppendApiVersionNextResponse>;
      },
    );
  }

  /**
   * ReplaceApiVersionNext
   * @param nextLink The nextLink from the previous successful call to the ReplaceApiVersion method.
   * @param options The options parameters.
   */
  private async _replaceApiVersionNext(
    nextLink: string,
    options?: PagingReplaceApiVersionNextOptionalParams,
  ): Promise<PagingReplaceApiVersionNextResponse> {
    return tracingClient.withSpan(
      "PagingClient._replaceApiVersionNext",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { nextLink, options },
          replaceApiVersionNextOperationSpec,
        ) as Promise<PagingReplaceApiVersionNextResponse>;
      },
    );
  }

  /**
   * GetPagingModelWithItemNameWithXMSClientNameNext
   * @param nextLink The nextLink from the previous successful call to the
   *                 GetPagingModelWithItemNameWithXMSClientName method.
   * @param options The options parameters.
   */
  private async _getPagingModelWithItemNameWithXMSClientNameNext(
    nextLink: string,
    options?: PagingGetPagingModelWithItemNameWithXMSClientNameNextOptionalParams,
  ): Promise<PagingGetPagingModelWithItemNameWithXMSClientNameNextResponse> {
    return tracingClient.withSpan(
      "PagingClient._getPagingModelWithItemNameWithXMSClientNameNext",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { nextLink, options },
          getPagingModelWithItemNameWithXMSClientNameNextOperationSpec,
        ) as Promise<PagingGetPagingModelWithItemNameWithXMSClientNameNextResponse>;
      },
    );
  }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);

const getNoItemNamePagesOperationSpec: coreClient.OperationSpec = {
  path: "/paging/noitemname",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResultValue,
    },
    default: {},
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer,
};
const getEmptyNextLinkNamePagesOperationSpec: coreClient.OperationSpec = {
  path: "/paging/emptynextlink",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResultValue,
    },
    default: {},
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer,
};
const getNullNextLinkNamePagesOperationSpec: coreClient.OperationSpec = {
  path: "/paging/nullnextlink",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResult,
    },
    default: {},
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer,
};
const getSinglePagesOperationSpec: coreClient.OperationSpec = {
  path: "/paging/single",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResult,
    },
    default: {},
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer,
};
const getSinglePagesWithBodyParamsOperationSpec: coreClient.OperationSpec = {
  path: "/paging/single/getWithBodyParams",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResult,
    },
    default: {},
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const firstResponseEmptyOperationSpec: coreClient.OperationSpec = {
  path: "/paging/firstResponseEmpty/1",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResultValue,
    },
    default: {},
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer,
};
const getMultiplePagesOperationSpec: coreClient.OperationSpec = {
  path: "/paging/multiple",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResult,
    },
    default: {},
  },
  urlParameters: [Parameters.$host],
  headerParameters: [
    Parameters.accept,
    Parameters.clientRequestId,
    Parameters.maxresults,
    Parameters.timeout,
  ],
  serializer,
};
const getWithQueryParamsOperationSpec: coreClient.OperationSpec = {
  path: "/paging/multiple/getWithQueryParams",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResult,
    },
    default: {},
  },
  queryParameters: [
    Parameters.requiredQueryParameter,
    Parameters.queryConstant,
  ],
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer,
};
const duplicateParamsOperationSpec: coreClient.OperationSpec = {
  path: "/paging/multiple/duplicateParams/1",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResult,
    },
    default: {},
  },
  queryParameters: [Parameters.filter],
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer,
};
const pageWithMaxPageSizeOperationSpec: coreClient.OperationSpec = {
  path: "/paging/maxPageSize",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResult,
    },
    default: {},
  },
  queryParameters: [Parameters.maxpagesize],
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer,
};
const nextOperationWithQueryParamsOperationSpec: coreClient.OperationSpec = {
  path: "/paging/multiple/nextOperationWithQueryParams",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResult,
    },
    default: {},
  },
  queryParameters: [Parameters.queryConstant],
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer,
};
const getOdataMultiplePagesOperationSpec: coreClient.OperationSpec = {
  path: "/paging/multiple/odata",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.OdataProductResult,
    },
    default: {},
  },
  urlParameters: [Parameters.$host],
  headerParameters: [
    Parameters.accept,
    Parameters.clientRequestId,
    Parameters.maxresults1,
    Parameters.timeout1,
  ],
  serializer,
};
const getMultiplePagesWithOffsetOperationSpec: coreClient.OperationSpec = {
  path: "/paging/multiple/withpath/{offset}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResult,
    },
    default: {},
  },
  urlParameters: [Parameters.$host, Parameters.offset],
  headerParameters: [
    Parameters.accept,
    Parameters.clientRequestId,
    Parameters.maxresults2,
    Parameters.timeout2,
  ],
  serializer,
};
const getMultiplePagesRetryFirstOperationSpec: coreClient.OperationSpec = {
  path: "/paging/multiple/retryfirst",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResult,
    },
    default: {},
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer,
};
const getMultiplePagesRetrySecondOperationSpec: coreClient.OperationSpec = {
  path: "/paging/multiple/retrysecond",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResult,
    },
    default: {},
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer,
};
const getSinglePagesFailureOperationSpec: coreClient.OperationSpec = {
  path: "/paging/single/failure",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResult,
    },
    default: {},
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer,
};
const getMultiplePagesFailureOperationSpec: coreClient.OperationSpec = {
  path: "/paging/multiple/failure",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResult,
    },
    default: {},
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer,
};
const getMultiplePagesFailureUriOperationSpec: coreClient.OperationSpec = {
  path: "/paging/multiple/failureuri",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResult,
    },
    default: {},
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer,
};
const getMultiplePagesFragmentNextLinkOperationSpec: coreClient.OperationSpec =
  {
    path: "/paging/multiple/fragment/{tenant}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.OdataProductResult,
      },
      default: {},
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.$host, Parameters.tenant],
    headerParameters: [Parameters.accept],
    serializer,
  };
const getMultiplePagesFragmentWithGroupingNextLinkOperationSpec: coreClient.OperationSpec =
  {
    path: "/paging/multiple/fragmentwithgrouping/{tenant}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.OdataProductResult,
      },
      default: {},
    },
    queryParameters: [Parameters.apiVersion1],
    urlParameters: [Parameters.$host, Parameters.tenant1],
    headerParameters: [Parameters.accept],
    serializer,
  };
const getMultiplePagesLROOperationSpec: coreClient.OperationSpec = {
  path: "/paging/multiple/lro",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResult,
    },
    201: {
      bodyMapper: Mappers.ProductResult,
    },
    202: {
      bodyMapper: Mappers.ProductResult,
    },
    204: {
      bodyMapper: Mappers.ProductResult,
    },
    default: {},
  },
  urlParameters: [Parameters.$host],
  headerParameters: [
    Parameters.accept,
    Parameters.clientRequestId,
    Parameters.maxresults3,
    Parameters.timeout3,
  ],
  serializer,
};
const appendApiVersionOperationSpec: coreClient.OperationSpec = {
  path: "/paging/apiVersion/append/1",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResult,
    },
    default: {},
  },
  queryParameters: [Parameters.apiVersion2],
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer,
};
const replaceApiVersionOperationSpec: coreClient.OperationSpec = {
  path: "/paging/apiVersion/replace/1",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResult,
    },
    default: {},
  },
  queryParameters: [Parameters.apiVersion2],
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer,
};
const nextFragmentOperationSpec: coreClient.OperationSpec = {
  path: "/paging/multiple/fragment/{tenant}/{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.OdataProductResult,
    },
    default: {},
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.$host, Parameters.tenant, Parameters.nextLink],
  headerParameters: [Parameters.accept],
  serializer,
};
const nextFragmentWithGroupingOperationSpec: coreClient.OperationSpec = {
  path: "/paging/multiple/fragmentwithgrouping/{tenant}/{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.OdataProductResult,
    },
    default: {},
  },
  queryParameters: [Parameters.apiVersion1],
  urlParameters: [Parameters.$host, Parameters.tenant1, Parameters.nextLink],
  headerParameters: [Parameters.accept],
  serializer,
};
const getPagingModelWithItemNameWithXMSClientNameOperationSpec: coreClient.OperationSpec =
  {
    path: "/paging/itemNameWithXMSClientName",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.ProductResultValueWithXMSClientName,
      },
      default: {},
    },
    urlParameters: [Parameters.$host],
    headerParameters: [Parameters.accept],
    serializer,
  };
const getNoItemNamePagesNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResultValue,
    },
    default: {},
  },
  urlParameters: [Parameters.$host, Parameters.nextLink],
  headerParameters: [Parameters.accept],
  serializer,
};
const getEmptyNextLinkNamePagesNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResultValue,
    },
    default: {},
  },
  urlParameters: [Parameters.$host, Parameters.nextLink],
  headerParameters: [Parameters.accept],
  serializer,
};
const getSinglePagesNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResult,
    },
    default: {},
  },
  urlParameters: [Parameters.$host, Parameters.nextLink],
  headerParameters: [Parameters.accept],
  serializer,
};
const getSinglePagesWithBodyParamsNextOperationSpec: coreClient.OperationSpec =
  {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.ProductResult,
      },
      default: {},
    },
    urlParameters: [Parameters.$host, Parameters.nextLink],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
  };
const firstResponseEmptyNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResultValue,
    },
    default: {},
  },
  urlParameters: [Parameters.$host, Parameters.nextLink],
  headerParameters: [Parameters.accept],
  serializer,
};
const getMultiplePagesNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResult,
    },
    default: {},
  },
  urlParameters: [Parameters.$host, Parameters.nextLink],
  headerParameters: [
    Parameters.accept,
    Parameters.clientRequestId,
    Parameters.maxresults,
    Parameters.timeout,
  ],
  serializer,
};
const duplicateParamsNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResult,
    },
    default: {},
  },
  urlParameters: [Parameters.$host, Parameters.nextLink],
  headerParameters: [Parameters.accept],
  serializer,
};
const pageWithMaxPageSizeNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResult,
    },
    default: {},
  },
  urlParameters: [Parameters.$host, Parameters.nextLink],
  headerParameters: [Parameters.accept],
  serializer,
};
const getOdataMultiplePagesNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.OdataProductResult,
    },
    default: {},
  },
  urlParameters: [Parameters.$host, Parameters.nextLink],
  headerParameters: [
    Parameters.accept,
    Parameters.clientRequestId,
    Parameters.maxresults1,
    Parameters.timeout1,
  ],
  serializer,
};
const getMultiplePagesWithOffsetNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResult,
    },
    default: {},
  },
  urlParameters: [Parameters.$host, Parameters.offset, Parameters.nextLink],
  headerParameters: [
    Parameters.accept,
    Parameters.clientRequestId,
    Parameters.maxresults2,
    Parameters.timeout2,
  ],
  serializer,
};
const getMultiplePagesRetryFirstNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResult,
    },
    default: {},
  },
  urlParameters: [Parameters.$host, Parameters.nextLink],
  headerParameters: [Parameters.accept],
  serializer,
};
const getMultiplePagesRetrySecondNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResult,
    },
    default: {},
  },
  urlParameters: [Parameters.$host, Parameters.nextLink],
  headerParameters: [Parameters.accept],
  serializer,
};
const getSinglePagesFailureNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResult,
    },
    default: {},
  },
  urlParameters: [Parameters.$host, Parameters.nextLink],
  headerParameters: [Parameters.accept],
  serializer,
};
const getMultiplePagesFailureNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResult,
    },
    default: {},
  },
  urlParameters: [Parameters.$host, Parameters.nextLink],
  headerParameters: [Parameters.accept],
  serializer,
};
const getMultiplePagesFailureUriNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResult,
    },
    default: {},
  },
  urlParameters: [Parameters.$host, Parameters.nextLink],
  headerParameters: [Parameters.accept],
  serializer,
};
const getMultiplePagesLRONextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResult,
    },
    202: {
      bodyMapper: Mappers.ProductResult,
    },
    default: {},
  },
  urlParameters: [Parameters.$host, Parameters.nextLink],
  headerParameters: [
    Parameters.accept,
    Parameters.clientRequestId,
    Parameters.maxresults3,
    Parameters.timeout3,
  ],
  serializer,
};
const appendApiVersionNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResult,
    },
    default: {},
  },
  urlParameters: [Parameters.$host, Parameters.nextLink],
  headerParameters: [Parameters.accept],
  serializer,
};
const replaceApiVersionNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ProductResult,
    },
    default: {},
  },
  urlParameters: [Parameters.$host, Parameters.nextLink],
  headerParameters: [Parameters.accept],
  serializer,
};
const getPagingModelWithItemNameWithXMSClientNameNextOperationSpec: coreClient.OperationSpec =
  {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.ProductResultValueWithXMSClientName,
      },
      default: {},
    },
    urlParameters: [Parameters.$host, Parameters.nextLink],
    headerParameters: [Parameters.accept],
    serializer,
  };
