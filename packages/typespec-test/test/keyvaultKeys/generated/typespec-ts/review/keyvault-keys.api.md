## API Report File for "@azure/keyvault-keys"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ClientOptions } from '@azure-rest/core-client';
import { OperationOptions } from '@azure-rest/core-client';
import { Pipeline } from '@azure/core-rest-pipeline';
import { TokenCredential } from '@azure/core-auth';

// @public
export interface BackupKeyOptionalParams extends OperationOptions {
}

// @public
export interface BackupKeyResult {
    readonly value?: Uint8Array;
}

// @public
export type ContinuablePage<TElement, TPage = TElement[]> = TPage & {
    continuationToken?: string;
};

// @public
export interface CreateKeyOptionalParams extends OperationOptions {
}

// @public
export interface DecryptOptionalParams extends OperationOptions {
}

// @public
export interface DeletedKeyBundle {
    attributes?: KeyAttributes;
    readonly deletedDate?: Date;
    key?: JsonWebKey;
    readonly managed?: boolean;
    recoveryId?: string;
    releasePolicy?: KeyReleasePolicy;
    readonly scheduledPurgeDate?: Date;
    tags?: Record<string, string>;
}

// @public
export interface DeletedKeyItem {
    attributes?: KeyAttributes;
    readonly deletedDate?: Date;
    kid?: string;
    readonly managed?: boolean;
    recoveryId?: string;
    readonly scheduledPurgeDate?: Date;
    tags?: Record<string, string>;
}

// @public
export interface DeleteKeyOptionalParams extends OperationOptions {
}

// @public
export type DeletionRecoveryLevel = string;

// @public
export interface EncryptOptionalParams extends OperationOptions {
}

// @public
export type ErrorModel = {
    code?: string;
    message?: string;
    innerError?: ErrorModel;
} | null;

// @public
export interface GetDeletedKeyOptionalParams extends OperationOptions {
}

// @public
export interface GetDeletedKeysOptionalParams extends OperationOptions {
    maxresults?: number;
}

// @public
export interface GetKeyAttestationOptionalParams extends OperationOptions {
}

// @public
export interface GetKeyOptionalParams extends OperationOptions {
}

// @public
export interface GetKeyRotationPolicyOptionalParams extends OperationOptions {
}

// @public
export interface GetKeysOptionalParams extends OperationOptions {
    maxresults?: number;
}

// @public
export interface GetKeyVersionsOptionalParams extends OperationOptions {
    maxresults?: number;
}

// @public
export interface GetRandomBytesOptionalParams extends OperationOptions {
}

// @public
export interface GetRandomBytesRequest {
    count: number;
}

// @public
export interface ImportKeyOptionalParams extends OperationOptions {
}

// @public
export interface JsonWebKey {
    crv?: JsonWebKeyCurveName;
    d?: Uint8Array;
    dp?: Uint8Array;
    dq?: Uint8Array;
    e?: Uint8Array;
    k?: Uint8Array;
    keyOps?: string[];
    kid?: string;
    kty?: JsonWebKeyType;
    n?: Uint8Array;
    p?: Uint8Array;
    q?: Uint8Array;
    qi?: Uint8Array;
    t?: Uint8Array;
    x?: Uint8Array;
    y?: Uint8Array;
}

// @public
export type JsonWebKeyCurveName = string;

// @public
export type JsonWebKeyEncryptionAlgorithm = string;

// @public
export type JsonWebKeyOperation = string;

// @public
export type JsonWebKeySignatureAlgorithm = string;

// @public
export type JsonWebKeyType = string;

// @public
export interface KeyAttestation {
    certificatePemFile?: Uint8Array;
    privateKeyAttestation?: Uint8Array;
    publicKeyAttestation?: Uint8Array;
    version?: string;
}

// @public
export interface KeyAttributes {
    attestation?: KeyAttestation;
    readonly created?: Date;
    enabled?: boolean;
    expires?: Date;
    exportable?: boolean;
    readonly hsmPlatform?: string;
    notBefore?: Date;
    readonly recoverableDays?: number;
    readonly recoveryLevel?: DeletionRecoveryLevel;
    readonly updated?: Date;
}

// @public
export interface KeyBundle {
    attributes?: KeyAttributes;
    key?: JsonWebKey;
    readonly managed?: boolean;
    releasePolicy?: KeyReleasePolicy;
    tags?: Record<string, string>;
}

// @public
export interface KeyCreateParameters {
    curve?: JsonWebKeyCurveName;
    keyAttributes?: KeyAttributes;
    keyOps?: JsonWebKeyOperation[];
    keySize?: number;
    kty: JsonWebKeyType;
    publicExponent?: number;
    releasePolicy?: KeyReleasePolicy;
    tags?: Record<string, string>;
}

// @public
export type KeyEncryptionAlgorithm = string;

// @public
export interface KeyImportParameters {
    hsm?: boolean;
    key: JsonWebKey;
    keyAttributes?: KeyAttributes;
    releasePolicy?: KeyReleasePolicy;
    tags?: Record<string, string>;
}

// @public
export interface KeyItem {
    attributes?: KeyAttributes;
    kid?: string;
    readonly managed?: boolean;
    tags?: Record<string, string>;
}

// @public
export interface KeyOperationResult {
    readonly additionalAuthenticatedData?: Uint8Array;
    readonly authenticationTag?: Uint8Array;
    readonly iv?: Uint8Array;
    readonly kid?: string;
    readonly result?: Uint8Array;
}

// @public
export interface KeyOperationsParameters {
    aad?: Uint8Array;
    algorithm: JsonWebKeyEncryptionAlgorithm;
    iv?: Uint8Array;
    tag?: Uint8Array;
    value: Uint8Array;
}

// @public
export interface KeyReleaseParameters {
    enc?: KeyEncryptionAlgorithm;
    nonce?: string;
    targetAttestationToken: string;
}

// @public
export interface KeyReleasePolicy {
    contentType?: string;
    encodedPolicy?: Uint8Array;
    immutable?: boolean;
}

// @public
export interface KeyReleaseResult {
    readonly value?: string;
}

// @public
export interface KeyRestoreParameters {
    keyBundleBackup: Uint8Array;
}

// @public
export interface KeyRotationPolicy {
    attributes?: KeyRotationPolicyAttributes;
    readonly id?: string;
    lifetimeActions?: LifetimeActions[];
}

// @public
export type KeyRotationPolicyAction = "Rotate" | "Notify";

// @public
export interface KeyRotationPolicyAttributes {
    readonly created?: Date;
    expiryTime?: string;
    readonly updated?: Date;
}

// @public
export interface KeySignParameters {
    algorithm: JsonWebKeySignatureAlgorithm;
    value: Uint8Array;
}

// @public
export interface KeyUpdateParameters {
    keyAttributes?: KeyAttributes;
    keyOps?: JsonWebKeyOperation[];
    releasePolicy?: KeyReleasePolicy;
    tags?: Record<string, string>;
}

// @public (undocumented)
export class KeyVaultClient {
    constructor(endpointParam: string, credential: TokenCredential, options?: KeyVaultClientOptionalParams);
    backupKey(keyName: string, options?: BackupKeyOptionalParams): Promise<BackupKeyResult>;
    createKey(keyName: string, parameters: KeyCreateParameters, options?: CreateKeyOptionalParams): Promise<KeyBundle>;
    decrypt(keyName: string, keyVersion: string, parameters: KeyOperationsParameters, options?: DecryptOptionalParams): Promise<KeyOperationResult>;
    deleteKey(keyName: string, options?: DeleteKeyOptionalParams): Promise<DeletedKeyBundle>;
    encrypt(keyName: string, keyVersion: string, parameters: KeyOperationsParameters, options?: EncryptOptionalParams): Promise<KeyOperationResult>;
    getDeletedKey(keyName: string, options?: GetDeletedKeyOptionalParams): Promise<DeletedKeyBundle>;
    getDeletedKeys(options?: GetDeletedKeysOptionalParams): PagedAsyncIterableIterator<DeletedKeyItem>;
    getKey(keyName: string, keyVersion: string, options?: GetKeyOptionalParams): Promise<KeyBundle>;
    getKeyAttestation(keyName: string, keyVersion: string, options?: GetKeyAttestationOptionalParams): Promise<KeyBundle>;
    getKeyRotationPolicy(keyName: string, options?: GetKeyRotationPolicyOptionalParams): Promise<KeyRotationPolicy>;
    getKeys(options?: GetKeysOptionalParams): PagedAsyncIterableIterator<KeyItem>;
    getKeyVersions(keyName: string, options?: GetKeyVersionsOptionalParams): PagedAsyncIterableIterator<KeyItem>;
    getRandomBytes(parameters: GetRandomBytesRequest, options?: GetRandomBytesOptionalParams): Promise<RandomBytes>;
    importKey(keyName: string, parameters: KeyImportParameters, options?: ImportKeyOptionalParams): Promise<KeyBundle>;
    readonly pipeline: Pipeline;
    purgeDeletedKey(keyName: string, options?: PurgeDeletedKeyOptionalParams): Promise<void>;
    recoverDeletedKey(keyName: string, options?: RecoverDeletedKeyOptionalParams): Promise<KeyBundle>;
    release(keyName: string, keyVersion: string, parameters: KeyReleaseParameters, options?: ReleaseOptionalParams): Promise<KeyReleaseResult>;
    restoreKey(parameters: KeyRestoreParameters, options?: RestoreKeyOptionalParams): Promise<KeyBundle>;
    rotateKey(keyName: string, options?: RotateKeyOptionalParams): Promise<KeyBundle>;
    sign(keyName: string, keyVersion: string, parameters: KeySignParameters, options?: SignOptionalParams): Promise<KeyOperationResult>;
    unwrapKey(keyName: string, keyVersion: string, parameters: KeyOperationsParameters, options?: UnwrapKeyOptionalParams): Promise<KeyOperationResult>;
    updateKey(keyName: string, keyVersion: string, parameters: KeyUpdateParameters, options?: UpdateKeyOptionalParams): Promise<KeyBundle>;
    updateKeyRotationPolicy(keyName: string, keyRotationPolicy: KeyRotationPolicy, options?: UpdateKeyRotationPolicyOptionalParams): Promise<KeyRotationPolicy>;
    verify(keyName: string, keyVersion: string, parameters: KeyVerifyParameters, options?: VerifyOptionalParams): Promise<KeyVerifyResult>;
    wrapKey(keyName: string, keyVersion: string, parameters: KeyOperationsParameters, options?: WrapKeyOptionalParams): Promise<KeyOperationResult>;
}

// @public
export interface KeyVaultClientOptionalParams extends ClientOptions {
    apiVersion?: string;
}

// @public
export interface KeyVaultError {
    readonly error?: ErrorModel;
}

// @public
export interface KeyVerifyParameters {
    algorithm: JsonWebKeySignatureAlgorithm;
    digest: Uint8Array;
    signature: Uint8Array;
}

// @public
export interface KeyVerifyResult {
    readonly value?: boolean;
}

// @public
export enum KnownDeletionRecoveryLevel {
    CustomizedRecoverable = "CustomizedRecoverable",
    CustomizedRecoverableProtectedSubscription = "CustomizedRecoverable+ProtectedSubscription",
    CustomizedRecoverablePurgeable = "CustomizedRecoverable+Purgeable",
    Purgeable = "Purgeable",
    Recoverable = "Recoverable",
    RecoverableProtectedSubscription = "Recoverable+ProtectedSubscription",
    RecoverablePurgeable = "Recoverable+Purgeable"
}

// @public
export enum KnownJsonWebKeyCurveName {
    P256 = "P-256",
    P256K = "P-256K",
    P384 = "P-384",
    P521 = "P-521"
}

// @public
export enum KnownJsonWebKeyEncryptionAlgorithm {
    A128CBC = "A128CBC",
    A128Cbcpad = "A128CBCPAD",
    A128GCM = "A128GCM",
    A128KW = "A128KW",
    A192CBC = "A192CBC",
    A192Cbcpad = "A192CBCPAD",
    A192GCM = "A192GCM",
    A192KW = "A192KW",
    A256CBC = "A256CBC",
    A256Cbcpad = "A256CBCPAD",
    A256GCM = "A256GCM",
    A256KW = "A256KW",
    CkmAesKeyWrap = "CKM_AES_KEY_WRAP",
    CkmAesKeyWrapPad = "CKM_AES_KEY_WRAP_PAD",
    RSA15 = "RSA1_5",
    RSAOaep = "RSA-OAEP",
    RSAOaep256 = "RSA-OAEP-256"
}

// @public
export enum KnownJsonWebKeyOperation {
    Decrypt = "decrypt",
    Encrypt = "encrypt",
    Export = "export",
    Import = "import",
    Sign = "sign",
    UnwrapKey = "unwrapKey",
    Verify = "verify",
    WrapKey = "wrapKey"
}

// @public
export enum KnownJsonWebKeySignatureAlgorithm {
    ES256 = "ES256",
    ES256K = "ES256K",
    ES384 = "ES384",
    ES512 = "ES512",
    HS256 = "HS256",
    HS384 = "HS384",
    HS512 = "HS512",
    PS256 = "PS256",
    PS384 = "PS384",
    PS512 = "PS512",
    RS256 = "RS256",
    RS384 = "RS384",
    RS512 = "RS512",
    Rsnull = "RSNULL"
}

// @public
export enum KnownJsonWebKeyType {
    EC = "EC",
    Echsm = "EC-HSM",
    Oct = "oct",
    OctHSM = "oct-HSM",
    RSA = "RSA",
    Rsahsm = "RSA-HSM"
}

// @public
export enum KnownKeyEncryptionAlgorithm {
    CkmRsaAesKeyWrap = "CKM_RSA_AES_KEY_WRAP",
    RsaAesKeyWrap256 = "RSA_AES_KEY_WRAP_256",
    RsaAesKeyWrap384 = "RSA_AES_KEY_WRAP_384"
}

// @public
export enum KnownVersions {
    V75 = "7.5",
    V76Preview2 = "7.6-preview.2"
}

// @public
export interface LifetimeActions {
    action?: LifetimeActionsType;
    trigger?: LifetimeActionsTrigger;
}

// @public
export interface LifetimeActionsTrigger {
    timeAfterCreate?: string;
    timeBeforeExpiry?: string;
}

// @public
export interface LifetimeActionsType {
    type?: KeyRotationPolicyAction;
}

// @public
export interface PagedAsyncIterableIterator<TElement, TPage = TElement[], TPageSettings extends PageSettings = PageSettings> {
    [Symbol.asyncIterator](): PagedAsyncIterableIterator<TElement, TPage, TPageSettings>;
    byPage: (settings?: TPageSettings) => AsyncIterableIterator<ContinuablePage<TElement, TPage>>;
    next(): Promise<IteratorResult<TElement>>;
}

// @public
export interface PageSettings {
    continuationToken?: string;
}

// @public
export interface PurgeDeletedKeyOptionalParams extends OperationOptions {
}

// @public
export interface RandomBytes {
    value: Uint8Array;
}

// @public
export interface RecoverDeletedKeyOptionalParams extends OperationOptions {
}

// @public
export interface ReleaseOptionalParams extends OperationOptions {
}

// @public
export interface RestoreKeyOptionalParams extends OperationOptions {
}

// @public
export interface RotateKeyOptionalParams extends OperationOptions {
}

// @public
export interface SignOptionalParams extends OperationOptions {
}

// @public
export interface UnwrapKeyOptionalParams extends OperationOptions {
}

// @public
export interface UpdateKeyOptionalParams extends OperationOptions {
}

// @public
export interface UpdateKeyRotationPolicyOptionalParams extends OperationOptions {
}

// @public
export interface VerifyOptionalParams extends OperationOptions {
}

// @public
export interface WrapKeyOptionalParams extends OperationOptions {
}

// (No @packageDocumentation comment for this package)

```
