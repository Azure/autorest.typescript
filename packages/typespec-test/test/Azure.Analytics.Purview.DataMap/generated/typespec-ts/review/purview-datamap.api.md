## API Report File for "@azure/purview-datamap"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ClientOptions } from '@azure-rest/core-client';
import { OperationOptions } from '@azure-rest/core-client';
import { Pipeline } from '@azure/core-rest-pipeline';
import { TokenCredential } from '@azure/core-auth';

// @public
export interface AtlasAttributeDef {
    cardinality?: CardinalityValue;
    constraints?: AtlasConstraintDef[];
    defaultValue?: string;
    description?: string;
    includeInNotification?: boolean;
    isIndexable?: boolean;
    isOptional?: boolean;
    isUnique?: boolean;
    name?: string;
    options?: Record<string, string>;
    typeName?: string;
    valuesMaxCount?: number;
    valuesMinCount?: number;
}

// @public
export interface AtlasBusinessMetadataDef {
    attributeDefs?: AtlasAttributeDef[];
    category?: TypeCategory;
    createdBy?: string;
    createTime?: number;
    dateFormatter?: DateFormat;
    description?: string;
    guid?: string;
    lastModifiedTS?: string;
    name?: string;
    options?: Record<string, string>;
    serviceType?: string;
    typeVersion?: string;
    updatedBy?: string;
    updateTime?: number;
    version?: number;
}

// @public
export interface AtlasClassification {
    attributes?: Record<string, any>;
    entityGuid?: string;
    entityStatus?: EntityStatus;
    lastModifiedTS?: string;
    removePropagationsOnEntityDelete?: boolean;
    typeName?: string;
    validityPeriods?: TimeBoundary[];
}

// @public
export interface AtlasClassificationDef {
    attributeDefs?: AtlasAttributeDef[];
    category?: TypeCategory;
    createdBy?: string;
    createTime?: number;
    dateFormatter?: DateFormat;
    description?: string;
    entityTypes?: string[];
    guid?: string;
    lastModifiedTS?: string;
    name?: string;
    options?: Record<string, string>;
    serviceType?: string;
    subTypes?: string[];
    superTypes?: string[];
    typeVersion?: string;
    updatedBy?: string;
    updateTime?: number;
    version?: number;
}

// @public
export interface AtlasClassifications {
    list?: any[];
    pageSize?: number;
    sortBy?: string;
    sortType?: SortType;
    startIndex?: number;
    totalCount?: number;
}

// @public
export interface AtlasConstraintDef {
    params?: Record<string, any>;
    type?: string;
}

// @public
export interface AtlasEntitiesWithExtInfo {
    entities?: AtlasEntity[];
    referredEntities?: Record<string, AtlasEntity>;
}

// @public
export interface AtlasEntity {
    attributes?: Record<string, any>;
    businessAttributes?: Record<string, any>;
    classifications?: AtlasClassification[];
    readonly collectionId?: string;
    contacts?: Record<string, ContactInfo[]>;
    createdBy?: string;
    createTime?: number;
    customAttributes?: Record<string, string>;
    guid?: string;
    homeId?: string;
    isIncomplete?: boolean;
    labels?: string[];
    lastModifiedTS?: string;
    meanings?: AtlasTermAssignmentHeader[];
    provenanceType?: number;
    proxy?: boolean;
    relationshipAttributes?: Record<string, any>;
    status?: EntityStatus;
    typeName?: string;
    updatedBy?: string;
    updateTime?: number;
    version?: number;
}

// @public
export interface AtlasEntityDef {
    attributeDefs?: AtlasAttributeDef[];
    category?: TypeCategory;
    createdBy?: string;
    createTime?: number;
    dateFormatter?: DateFormat;
    description?: string;
    guid?: string;
    lastModifiedTS?: string;
    name?: string;
    options?: Record<string, string>;
    relationshipAttributeDefs?: AtlasRelationshipAttributeDef[];
    serviceType?: string;
    subTypes?: string[];
    superTypes?: string[];
    typeVersion?: string;
    updatedBy?: string;
    updateTime?: number;
    version?: number;
}

// @public
export interface AtlasEntityHeader {
    attributes?: Record<string, any>;
    classificationNames?: string[];
    classifications?: AtlasClassification[];
    displayText?: string;
    guid?: string;
    isIncomplete?: boolean;
    labels?: string[];
    lastModifiedTS?: string;
    meaningNames?: string[];
    meanings?: AtlasTermAssignmentHeader[];
    status?: EntityStatus;
    typeName?: string;
}

// @public
export interface AtlasEntityHeaders {
    guidHeaderMap?: Record<string, AtlasEntityHeader>;
}

// @public
export interface AtlasEntityWithExtInfo {
    entity?: AtlasEntity;
    referredEntities?: Record<string, AtlasEntity>;
}

// @public
export interface AtlasEnumDef {
    category?: TypeCategory;
    createdBy?: string;
    createTime?: number;
    dateFormatter?: DateFormat;
    defaultValue?: string;
    description?: string;
    elementDefs?: AtlasEnumElementDef[];
    guid?: string;
    lastModifiedTS?: string;
    name?: string;
    options?: Record<string, string>;
    serviceType?: string;
    typeVersion?: string;
    updatedBy?: string;
    updateTime?: number;
    version?: number;
}

// @public
export interface AtlasEnumElementDef {
    description?: string;
    ordinal?: number;
    value?: string;
}

// @public
export interface AtlasErrorResponse {
    errorCode?: string;
    errorMessage?: string;
    requestId?: string;
}

// @public
export interface AtlasGlossary {
    categories?: AtlasRelatedCategoryHeader[];
    classifications?: AtlasClassification[];
    createdBy?: string;
    createTime?: number;
    guid?: string;
    language?: string;
    lastModifiedTS?: string;
    longDescription?: string;
    name?: string;
    qualifiedName?: string;
    shortDescription?: string;
    terms?: AtlasRelatedTermHeader[];
    updatedBy?: string;
    updateTime?: number;
    usage?: string;
}

// @public
export interface AtlasGlossaryCategory {
    anchor?: AtlasGlossaryHeader;
    childrenCategories?: AtlasRelatedCategoryHeader[];
    classifications?: AtlasClassification[];
    createdBy?: string;
    createTime?: number;
    guid?: string;
    lastModifiedTS?: string;
    longDescription?: string;
    name?: string;
    parentCategory?: AtlasRelatedCategoryHeader;
    qualifiedName?: string;
    shortDescription?: string;
    terms?: AtlasRelatedTermHeader[];
    updatedBy?: string;
    updateTime?: number;
}

// @public
export interface AtlasGlossaryExtInfo {
    categories?: AtlasRelatedCategoryHeader[];
    categoryInfo?: Record<string, AtlasGlossaryCategory>;
    classifications?: AtlasClassification[];
    createdBy?: string;
    createTime?: number;
    guid?: string;
    language?: string;
    lastModifiedTS?: string;
    longDescription?: string;
    name?: string;
    qualifiedName?: string;
    shortDescription?: string;
    termInfo?: Record<string, AtlasGlossaryTerm>;
    terms?: AtlasRelatedTermHeader[];
    updatedBy?: string;
    updateTime?: number;
    usage?: string;
}

// @public
export interface AtlasGlossaryHeader {
    displayText?: string;
    glossaryGuid?: string;
    relationGuid?: string;
}

// @public
export interface AtlasGlossaryTerm {
    abbreviation?: string;
    anchor?: AtlasGlossaryHeader;
    antonyms?: AtlasRelatedTermHeader[];
    assignedEntities?: AtlasRelatedObjectId[];
    attributes?: Record<string, Record<string, any>>;
    categories?: AtlasTermCategorizationHeader[];
    classifications?: AtlasClassification[];
    classifies?: AtlasRelatedTermHeader[];
    contacts?: Record<string, ContactInfo[]>;
    createdBy?: string;
    createTime?: number;
    examples?: string[];
    guid?: string;
    hierarchyInfo?: PurviewObjectId[];
    isA?: AtlasRelatedTermHeader[];
    lastModifiedTS?: string;
    longDescription?: string;
    name?: string;
    nickName?: string;
    preferredTerms?: AtlasRelatedTermHeader[];
    preferredToTerms?: AtlasRelatedTermHeader[];
    qualifiedName?: string;
    replacedBy?: AtlasRelatedTermHeader[];
    replacementTerms?: AtlasRelatedTermHeader[];
    resources?: ResourceLink[];
    seeAlso?: AtlasRelatedTermHeader[];
    shortDescription?: string;
    status?: TermStatus;
    synonyms?: AtlasRelatedTermHeader[];
    templateName?: any[];
    translatedTerms?: AtlasRelatedTermHeader[];
    translationTerms?: AtlasRelatedTermHeader[];
    updatedBy?: string;
    updateTime?: number;
    usage?: string;
    validValues?: AtlasRelatedTermHeader[];
    validValuesFor?: AtlasRelatedTermHeader[];
}

// @public
export interface AtlasLineageInfo {
    baseEntityGuid?: string;
    childrenCount?: number;
    guidEntityMap?: Record<string, AtlasEntityHeader>;
    lineageDepth?: number;
    lineageDirection?: LineageDirection;
    lineageWidth?: number;
    parentRelations?: ParentRelation[];
    relations?: LineageRelation[];
    widthCounts?: Record<string, Record<string, any>>;
}

// @public
export interface AtlasObjectId {
    guid?: string;
    typeName?: string;
    uniqueAttributes?: Record<string, any>;
}

// @public
export interface AtlasRelatedCategoryHeader {
    categoryGuid?: string;
    description?: string;
    displayText?: string;
    parentCategoryGuid?: string;
    relationGuid?: string;
}

// @public
export interface AtlasRelatedObjectId {
    displayText?: string;
    entityStatus?: EntityStatus;
    guid?: string;
    relationshipAttributes?: AtlasStruct;
    relationshipGuid?: string;
    relationshipStatus?: StatusAtlasRelationship;
    relationshipType?: string;
    typeName?: string;
    uniqueAttributes?: Record<string, any>;
}

// @public
export interface AtlasRelatedTermHeader {
    description?: string;
    displayText?: string;
    expression?: string;
    relationGuid?: string;
    status?: AtlasTermRelationshipStatus;
    steward?: string;
    termGuid?: string;
}

// @public
export interface AtlasRelationship {
    attributes?: Record<string, any>;
    createdBy?: string;
    createTime?: number;
    end1?: AtlasObjectId;
    end2?: AtlasObjectId;
    guid?: string;
    homeId?: string;
    label?: string;
    lastModifiedTS?: string;
    provenanceType?: number;
    status?: StatusAtlasRelationship;
    typeName?: string;
    updatedBy?: string;
    updateTime?: number;
    version?: number;
}

// @public
export interface AtlasRelationshipAttributeDef {
    cardinality?: CardinalityValue;
    constraints?: AtlasConstraintDef[];
    defaultValue?: string;
    description?: string;
    includeInNotification?: boolean;
    isIndexable?: boolean;
    isLegacyAttribute?: boolean;
    isOptional?: boolean;
    isUnique?: boolean;
    name?: string;
    options?: Record<string, string>;
    relationshipTypeName?: string;
    typeName?: string;
    valuesMaxCount?: number;
    valuesMinCount?: number;
}

// @public
export interface AtlasRelationshipDef {
    attributeDefs?: AtlasAttributeDef[];
    category?: TypeCategory;
    createdBy?: string;
    createTime?: number;
    dateFormatter?: DateFormat;
    description?: string;
    endDef1?: AtlasRelationshipEndDef;
    endDef2?: AtlasRelationshipEndDef;
    guid?: string;
    lastModifiedTS?: string;
    name?: string;
    options?: Record<string, string>;
    relationshipCategory?: RelationshipCategory;
    relationshipLabel?: string;
    serviceType?: string;
    typeVersion?: string;
    updatedBy?: string;
    updateTime?: number;
    version?: number;
}

// @public
export interface AtlasRelationshipEndDef {
    cardinality?: CardinalityValue;
    description?: string;
    isContainer?: boolean;
    isLegacyAttribute?: boolean;
    name?: string;
    type?: string;
}

// @public
export interface AtlasRelationshipWithExtInfo {
    referredEntities?: Record<string, AtlasEntityHeader>;
    relationship?: AtlasRelationship;
}

// @public
export interface AtlasStruct {
    attributes?: Record<string, any>;
    lastModifiedTS?: string;
    typeName?: string;
}

// @public
export interface AtlasStructDef {
    attributeDefs?: AtlasAttributeDef[];
    category?: TypeCategory;
    createdBy?: string;
    createTime?: number;
    dateFormatter?: DateFormat;
    description?: string;
    guid?: string;
    lastModifiedTS?: string;
    name?: string;
    options?: Record<string, string>;
    serviceType?: string;
    typeVersion?: string;
    updatedBy?: string;
    updateTime?: number;
    version?: number;
}

// @public
export interface AtlasTermAssignmentHeader {
    confidence?: number;
    createdBy?: string;
    description?: string;
    displayText?: string;
    expression?: string;
    relationGuid?: string;
    status?: AtlasTermAssignmentStatus;
    steward?: string;
    termGuid?: string;
}

// @public
export type AtlasTermAssignmentStatus = "DISCOVERED" | "PROPOSED" | "IMPORTED" | "VALIDATED" | "DEPRECATED" | "OBSOLETE" | "OTHER";

// @public
export interface AtlasTermCategorizationHeader {
    categoryGuid?: string;
    description?: string;
    displayText?: string;
    relationGuid?: string;
    status?: AtlasTermRelationshipStatus;
}

// @public
export type AtlasTermRelationshipStatus = "DRAFT" | "ACTIVE" | "DEPRECATED" | "OBSOLETE" | "OTHER";

// @public
export interface AtlasTypeDef {
    attributeDefs?: AtlasAttributeDef[];
    category?: TypeCategory;
    createdBy?: string;
    createTime?: number;
    dateFormatter?: DateFormat;
    defaultValue?: string;
    description?: string;
    elementDefs?: AtlasEnumElementDef[];
    endDef1?: AtlasRelationshipEndDef;
    endDef2?: AtlasRelationshipEndDef;
    entityTypes?: string[];
    guid?: string;
    lastModifiedTS?: string;
    name?: string;
    options?: Record<string, string>;
    relationshipAttributeDefs?: AtlasRelationshipAttributeDef[];
    relationshipCategory?: RelationshipCategory;
    relationshipLabel?: string;
    serviceType?: string;
    subTypes?: string[];
    superTypes?: string[];
    typeVersion?: string;
    updatedBy?: string;
    updateTime?: number;
    version?: number;
}

// @public
export interface AtlasTypeDefHeader {
    category?: TypeCategory;
    guid?: string;
    name?: string;
}

// @public
export interface AtlasTypesDef {
    businessMetadataDefs?: AtlasBusinessMetadataDef[];
    classificationDefs?: AtlasClassificationDef[];
    entityDefs?: AtlasEntityDef[];
    enumDefs?: AtlasEnumDef[];
    relationshipDefs?: AtlasRelationshipDef[];
    structDefs?: AtlasStructDef[];
    termTemplateDefs?: TermTemplateDef[];
}

// @public
export interface AutoCompleteOptions {
    filter?: any;
    keywords?: string;
    limit?: number;
}

// @public
export interface AutoCompleteResult {
    value?: AutoCompleteResultValue[];
}

// @public
export interface AutoCompleteResultValue {
    queryPlusText?: string;
    text?: string;
}

// @public
export interface BulkImportResult {
    failedImportInfoList?: ImportInfo[];
    successImportInfoList?: ImportInfo[];
}

// @public
export type BusinessAttributeUpdateBehavior = "ignore" | "replace" | "merge";

// @public
export interface BusinessMetadataOptions {
    file: FileContents | {
        contents: FileContents;
        contentType?: string;
        filename?: string;
    };
}

// @public
export type CardinalityValue = "SINGLE" | "LIST" | "SET";

// @public
export interface ClassificationAssociateOptions {
    classification?: AtlasClassification;
    entityGuids?: string[];
}

// @public
export interface ContactInfo {
    id?: string;
    info?: string;
}

// @public
export interface ContactSearchResultValue {
    contactType?: string;
    id?: string;
    info?: string;
}

// @public (undocumented)
export class DataMapClient {
    constructor(endpointParam: string, credential: TokenCredential, options?: DataMapClientOptionalParams);
    readonly discovery: DiscoveryOperations;
    readonly entity: EntityOperations;
    readonly glossary: GlossaryOperations;
    readonly lineage: LineageOperations;
    readonly pipeline: Pipeline;
    readonly relationship: RelationshipOperations;
    readonly typeDefinition: TypeDefinitionOperations;
}

// @public
export interface DataMapClientOptionalParams extends ClientOptions {
    apiVersion?: string;
}

// @public
export interface DateFormat {
    availableLocales?: string[];
    calendar?: number;
    dateInstance?: DateFormat;
    dateTimeInstance?: DateFormat;
    instance?: DateFormat;
    lenient?: boolean;
    numberFormat?: NumberFormat;
    timeInstance?: DateFormat;
    timeZone?: TimeZone;
}

// @public
export interface DiscoveryAutoCompleteOptionalParams extends OperationOptions {
}

// @public
export interface DiscoveryOperations {
    autoComplete: (body: AutoCompleteOptions, options?: DiscoveryAutoCompleteOptionalParams) => Promise<AutoCompleteResult>;
    query: (body: QueryOptions, options?: DiscoveryQueryOptionalParams) => Promise<QueryResult>;
    suggest: (body: SuggestOptions, options?: DiscoverySuggestOptionalParams) => Promise<SuggestResult>;
}

// @public
export interface DiscoveryQueryOptionalParams extends OperationOptions {
}

// @public
export interface DiscoverySuggestOptionalParams extends OperationOptions {
}

// @public
export interface EntityAddClassificationOptionalParams extends OperationOptions {
}

// @public
export interface EntityAddClassificationsByUniqueAttributeOptionalParams extends OperationOptions {
    attribute?: string;
}

// @public
export interface EntityAddClassificationsOptionalParams extends OperationOptions {
}

// @public
export interface EntityAddLabelOptionalParams extends OperationOptions {
    body?: string[];
}

// @public
export interface EntityAddLabelsByUniqueAttributeOptionalParams extends OperationOptions {
    attribute?: string;
    body?: string[];
}

// @public
export interface EntityAddOrUpdateBusinessMetadataAttributesOptionalParams extends OperationOptions {
}

// @public
export interface EntityAddOrUpdateBusinessMetadataOptionalParams extends OperationOptions {
    overwrite?: boolean;
}

// @public
export interface EntityBatchCreateOrUpdateOptionalParams extends OperationOptions {
    businessAttributeUpdateBehavior?: BusinessAttributeUpdateBehavior;
    collectionId?: string;
}

// @public
export interface EntityBatchDeleteOptionalParams extends OperationOptions {
}

// @public
export interface EntityBatchGetByUniqueAttributesOptionalParams extends OperationOptions {
    attrNQualifiedName?: string;
    ignoreRelationships?: boolean;
    minExtInfo?: boolean;
}

// @public
export interface EntityBatchSetClassificationsOptionalParams extends OperationOptions {
}

// @public
export interface EntityCreateOrUpdateOptionalParams extends OperationOptions {
    businessAttributeUpdateBehavior?: BusinessAttributeUpdateBehavior;
    collectionId?: string;
}

// @public
export interface EntityDeleteByUniqueAttributeOptionalParams extends OperationOptions {
    attribute?: string;
}

// @public
export interface EntityDeleteOptionalParams extends OperationOptions {
}

// @public
export interface EntityGetBusinessMetadataTemplateOptionalParams extends OperationOptions {
}

// @public
export interface EntityGetByIdsOptionalParams extends OperationOptions {
    ignoreRelationships?: boolean;
    minExtInfo?: boolean;
}

// @public
export interface EntityGetByUniqueAttributeOptionalParams extends OperationOptions {
    attribute?: string;
    ignoreRelationships?: boolean;
    minExtInfo?: boolean;
}

// @public
export interface EntityGetClassificationOptionalParams extends OperationOptions {
}

// @public
export interface EntityGetClassificationsOptionalParams extends OperationOptions {
}

// @public
export interface EntityGetHeaderOptionalParams extends OperationOptions {
}

// @public
export interface EntityGetOptionalParams extends OperationOptions {
    ignoreRelationships?: boolean;
    minExtInfo?: boolean;
}

// @public
export interface EntityImportBusinessMetadataOptionalParams extends OperationOptions {
}

// @public
export interface EntityMoveEntitiesToCollectionOptionalParams extends OperationOptions {
}

// @public
export interface EntityMutationResult {
    guidAssignments?: Record<string, string>;
    mutatedEntities?: Record<string, AtlasEntityHeader[]>;
    partialUpdatedEntities?: AtlasEntityHeader[];
}

// @public
export interface EntityOperations {
    addClassification: (body: ClassificationAssociateOptions, options?: EntityAddClassificationOptionalParams) => Promise<void>;
    addClassifications: (guid: string, body: AtlasClassification[], options?: EntityAddClassificationsOptionalParams) => Promise<void>;
    addClassificationsByUniqueAttribute: (typeName: string, body: AtlasClassification[], options?: EntityAddClassificationsByUniqueAttributeOptionalParams) => Promise<void>;
    addLabel: (guid: string, options?: EntityAddLabelOptionalParams) => Promise<void>;
    addLabelsByUniqueAttribute: (typeName: string, options?: EntityAddLabelsByUniqueAttributeOptionalParams) => Promise<void>;
    addOrUpdateBusinessMetadata: (guid: string, body: Record<string, Record<string, any>>, options?: EntityAddOrUpdateBusinessMetadataOptionalParams) => Promise<void>;
    addOrUpdateBusinessMetadataAttributes: (businessMetadataName: string, guid: string, body: Record<string, any>, options?: EntityAddOrUpdateBusinessMetadataAttributesOptionalParams) => Promise<void>;
    batchCreateOrUpdate: (body: AtlasEntitiesWithExtInfo, options?: EntityBatchCreateOrUpdateOptionalParams) => Promise<EntityMutationResult>;
    batchDelete: (guid: string[], options?: EntityBatchDeleteOptionalParams) => Promise<EntityMutationResult>;
    batchGetByUniqueAttributes: (typeName: string, options?: EntityBatchGetByUniqueAttributesOptionalParams) => Promise<AtlasEntitiesWithExtInfo>;
    batchSetClassifications: (body: AtlasEntityHeaders, options?: EntityBatchSetClassificationsOptionalParams) => Promise<string[]>;
    createOrUpdate: (body: AtlasEntityWithExtInfo, options?: EntityCreateOrUpdateOptionalParams) => Promise<EntityMutationResult>;
    delete: (guid: string, options?: EntityDeleteOptionalParams) => Promise<EntityMutationResult>;
    deleteByUniqueAttribute: (typeName: string, options?: EntityDeleteByUniqueAttributeOptionalParams) => Promise<EntityMutationResult>;
    get: (guid: string, options?: EntityGetOptionalParams) => Promise<AtlasEntityWithExtInfo>;
    getBusinessMetadataTemplate: (options?: EntityGetBusinessMetadataTemplateOptionalParams) => Promise<Uint8Array>;
    getByIds: (guid: string[], options?: EntityGetByIdsOptionalParams) => Promise<AtlasEntitiesWithExtInfo>;
    getByUniqueAttribute: (typeName: string, options?: EntityGetByUniqueAttributeOptionalParams) => Promise<AtlasEntityWithExtInfo>;
    getClassification: (guid: string, classificationName: string, options?: EntityGetClassificationOptionalParams) => Promise<AtlasClassification>;
    getClassifications: (guid: string, options?: EntityGetClassificationsOptionalParams) => Promise<AtlasClassifications>;
    getHeader: (guid: string, options?: EntityGetHeaderOptionalParams) => Promise<AtlasEntityHeader>;
    importBusinessMetadata: (body: BusinessMetadataOptions, options?: EntityImportBusinessMetadataOptionalParams) => Promise<BulkImportResult>;
    moveEntitiesToCollection: (collectionId: string, body: MoveEntitiesOptions, options?: EntityMoveEntitiesToCollectionOptionalParams) => Promise<EntityMutationResult>;
    removeBusinessMetadata: (guid: string, body: Record<string, Record<string, any>>, options?: EntityRemoveBusinessMetadataOptionalParams) => Promise<void>;
    removeBusinessMetadataAttributes: (businessMetadataName: string, guid: string, body: Record<string, any>, options?: EntityRemoveBusinessMetadataAttributesOptionalParams) => Promise<void>;
    removeClassification: (guid: string, classificationName: string, options?: EntityRemoveClassificationOptionalParams) => Promise<void>;
    removeClassificationByUniqueAttribute: (typeName: string, classificationName: string, options?: EntityRemoveClassificationByUniqueAttributeOptionalParams) => Promise<void>;
    removeLabels: (guid: string, options?: EntityRemoveLabelsOptionalParams) => Promise<void>;
    removeLabelsByUniqueAttribute: (typeName: string, options?: EntityRemoveLabelsByUniqueAttributeOptionalParams) => Promise<void>;
    setLabels: (guid: string, options?: EntitySetLabelsOptionalParams) => Promise<void>;
    setLabelsByUniqueAttribute: (typeName: string, options?: EntitySetLabelsByUniqueAttributeOptionalParams) => Promise<void>;
    updateAttributeById: (guid: string, name: string, body: any, options?: EntityUpdateAttributeByIdOptionalParams) => Promise<EntityMutationResult>;
    updateByUniqueAttribute: (typeName: string, body: AtlasEntityWithExtInfo, options?: EntityUpdateByUniqueAttributeOptionalParams) => Promise<EntityMutationResult>;
    updateClassifications: (guid: string, body: AtlasClassification[], options?: EntityUpdateClassificationsOptionalParams) => Promise<void>;
    updateClassificationsUniqueByAttribute: (typeName: string, body: AtlasClassification[], options?: EntityUpdateClassificationsUniqueByAttributeOptionalParams) => Promise<void>;
}

// @public
export interface EntityRemoveBusinessMetadataAttributesOptionalParams extends OperationOptions {
}

// @public
export interface EntityRemoveBusinessMetadataOptionalParams extends OperationOptions {
}

// @public
export interface EntityRemoveClassificationByUniqueAttributeOptionalParams extends OperationOptions {
    attribute?: string;
}

// @public
export interface EntityRemoveClassificationOptionalParams extends OperationOptions {
}

// @public
export interface EntityRemoveLabelsByUniqueAttributeOptionalParams extends OperationOptions {
    attribute?: string;
    body?: string[];
}

// @public
export interface EntityRemoveLabelsOptionalParams extends OperationOptions {
    body?: string[];
}

// @public
export interface EntitySetLabelsByUniqueAttributeOptionalParams extends OperationOptions {
    attribute?: string;
    body?: string[];
}

// @public
export interface EntitySetLabelsOptionalParams extends OperationOptions {
    body?: string[];
}

// @public
export type EntityStatus = "ACTIVE" | "DELETED";

// @public
export interface EntityUpdateAttributeByIdOptionalParams extends OperationOptions {
}

// @public
export interface EntityUpdateByUniqueAttributeOptionalParams extends OperationOptions {
    attribute?: string;
}

// @public
export interface EntityUpdateClassificationsOptionalParams extends OperationOptions {
}

// @public
export interface EntityUpdateClassificationsUniqueByAttributeOptionalParams extends OperationOptions {
    attribute?: string;
}

// @public
export type FileContents = string | NodeJS.ReadableStream | ReadableStream<Uint8Array> | Uint8Array | Blob;

// @public
export interface GlossaryAssignTermToEntitiesOptionalParams extends OperationOptions {
}

// @public
export interface GlossaryBatchGetOptionalParams extends OperationOptions {
    ignoreTermsAndCategories?: boolean;
    limit?: number;
    offset?: number;
    sort?: string;
}

// @public
export interface GlossaryCreateCategoriesOptionalParams extends OperationOptions {
}

// @public
export interface GlossaryCreateCategoryOptionalParams extends OperationOptions {
}

// @public
export interface GlossaryCreateOptionalParams extends OperationOptions {
}

// @public
export interface GlossaryCreateTermOptionalParams extends OperationOptions {
    includeTermHierarchy?: boolean;
}

// @public
export interface GlossaryCreateTermsOptionalParams extends OperationOptions {
    includeTermHierarchy?: boolean;
}

// @public
export interface GlossaryDeleteCategoryOptionalParams extends OperationOptions {
}

// @public
export interface GlossaryDeleteOptionalParams extends OperationOptions {
}

// @public
export interface GlossaryDeleteTermAssignmentFromEntitiesOptionalParams extends OperationOptions {
}

// @public
export interface GlossaryDeleteTermOptionalParams extends OperationOptions {
}

// @public
export interface GlossaryGetCategoriesHeadersOptionalParams extends OperationOptions {
    limit?: number;
    offset?: number;
    sort?: string;
}

// @public
export interface GlossaryGetCategoriesOptionalParams extends OperationOptions {
    limit?: number;
    offset?: number;
    sort?: string;
}

// @public
export interface GlossaryGetCategoryOptionalParams extends OperationOptions {
}

// @public
export interface GlossaryGetCategoryTermsOptionalParams extends OperationOptions {
    limit?: number;
    offset?: number;
    sort?: string;
}

// @public
export interface GlossaryGetDetailedOptionalParams extends OperationOptions {
}

// @public
export interface GlossaryGetEntitiesAssignedWithTermOptionalParams extends OperationOptions {
    limit?: number;
    offset?: number;
    sort?: string;
}

// @public
export interface GlossaryGetOptionalParams extends OperationOptions {
}

// @public
export interface GlossaryGetRelatedCategoriesOptionalParams extends OperationOptions {
    limit?: number;
    offset?: number;
    sort?: string;
}

// @public
export interface GlossaryGetRelatedTermsOptionalParams extends OperationOptions {
    limit?: number;
    offset?: number;
    sort?: string;
}

// @public
export interface GlossaryGetTermHeadersOptionalParams extends OperationOptions {
    limit?: number;
    offset?: number;
    sort?: string;
}

// @public
export interface GlossaryGetTermOptionalParams extends OperationOptions {
}

// @public
export interface GlossaryGetTermsOptionalParams extends OperationOptions {
    limit?: number;
    offset?: number;
    sort?: string;
}

// @public
export interface GlossaryOperations {
    assignTermToEntities: (termId: string, body: AtlasRelatedObjectId[], options?: GlossaryAssignTermToEntitiesOptionalParams) => Promise<void>;
    batchGet: (options?: GlossaryBatchGetOptionalParams) => Promise<AtlasGlossary[]>;
    create: (body: AtlasGlossary, options?: GlossaryCreateOptionalParams) => Promise<AtlasGlossary>;
    createCategories: (body: AtlasGlossaryCategory[], options?: GlossaryCreateCategoriesOptionalParams) => Promise<AtlasGlossaryCategory[]>;
    createCategory: (body: AtlasGlossaryCategory, options?: GlossaryCreateCategoryOptionalParams) => Promise<AtlasGlossaryCategory>;
    createTerm: (body: AtlasGlossaryTerm, options?: GlossaryCreateTermOptionalParams) => Promise<AtlasGlossaryTerm>;
    createTerms: (body: AtlasGlossaryTerm[], options?: GlossaryCreateTermsOptionalParams) => Promise<AtlasGlossaryTerm[]>;
    delete: (glossaryId: string, options?: GlossaryDeleteOptionalParams) => Promise<void>;
    deleteCategory: (categoryId: string, options?: GlossaryDeleteCategoryOptionalParams) => Promise<void>;
    deleteTerm: (termId: string, options?: GlossaryDeleteTermOptionalParams) => Promise<void>;
    deleteTermAssignmentFromEntities: (termId: string, body: AtlasRelatedObjectId[], options?: GlossaryDeleteTermAssignmentFromEntitiesOptionalParams) => Promise<void>;
    get: (glossaryId: string, options?: GlossaryGetOptionalParams) => Promise<AtlasGlossary>;
    getCategories: (glossaryId: string, options?: GlossaryGetCategoriesOptionalParams) => Promise<AtlasGlossaryCategory[]>;
    getCategoriesHeaders: (glossaryId: string, options?: GlossaryGetCategoriesHeadersOptionalParams) => Promise<AtlasRelatedCategoryHeader[]>;
    getCategory: (categoryId: string, options?: GlossaryGetCategoryOptionalParams) => Promise<AtlasGlossaryCategory>;
    getCategoryTerms: (categoryId: string, options?: GlossaryGetCategoryTermsOptionalParams) => Promise<AtlasRelatedTermHeader[]>;
    getDetailed: (glossaryId: string, options?: GlossaryGetDetailedOptionalParams) => Promise<AtlasGlossaryExtInfo>;
    getEntitiesAssignedWithTerm: (termId: string, options?: GlossaryGetEntitiesAssignedWithTermOptionalParams) => Promise<AtlasRelatedObjectId[]>;
    getRelatedCategories: (categoryId: string, options?: GlossaryGetRelatedCategoriesOptionalParams) => Promise<Record<string, AtlasRelatedCategoryHeader[]>>;
    getRelatedTerms: (termId: string, options?: GlossaryGetRelatedTermsOptionalParams) => Promise<Record<string, AtlasRelatedTermHeader[]>>;
    getTerm: (termId: string, options?: GlossaryGetTermOptionalParams) => Promise<AtlasGlossaryTerm>;
    getTermHeaders: (glossaryId: string, options?: GlossaryGetTermHeadersOptionalParams) => Promise<AtlasRelatedTermHeader[]>;
    getTerms: (glossaryId: string, options?: GlossaryGetTermsOptionalParams) => Promise<AtlasGlossaryTerm[]>;
    partialUpdate: (glossaryId: string, body: Record<string, string>, options?: GlossaryPartialUpdateOptionalParams) => Promise<AtlasGlossary>;
    partialUpdateCategory: (categoryId: string, body: Record<string, string>, options?: GlossaryPartialUpdateCategoryOptionalParams) => Promise<AtlasGlossaryCategory>;
    partialUpdateTerm: (termId: string, body: Record<string, string>, options?: GlossaryPartialUpdateTermOptionalParams) => Promise<AtlasGlossaryTerm>;
    update: (glossaryId: string, body: AtlasGlossary, options?: GlossaryUpdateOptionalParams) => Promise<AtlasGlossary>;
    updateCategory: (categoryId: string, body: AtlasGlossaryCategory, options?: GlossaryUpdateCategoryOptionalParams) => Promise<AtlasGlossaryCategory>;
    updateTerm: (termId: string, body: AtlasGlossaryTerm, options?: GlossaryUpdateTermOptionalParams) => Promise<AtlasGlossaryTerm>;
}

// @public
export interface GlossaryPartialUpdateCategoryOptionalParams extends OperationOptions {
}

// @public
export interface GlossaryPartialUpdateOptionalParams extends OperationOptions {
    ignoreTermsAndCategories?: boolean;
}

// @public
export interface GlossaryPartialUpdateTermOptionalParams extends OperationOptions {
    includeTermHierarchy?: boolean;
}

// @public
export interface GlossaryUpdateCategoryOptionalParams extends OperationOptions {
}

// @public
export interface GlossaryUpdateOptionalParams extends OperationOptions {
    ignoreTermsAndCategories?: boolean;
}

// @public
export interface GlossaryUpdateTermOptionalParams extends OperationOptions {
    includeTermHierarchy?: boolean;
}

// @public
export interface ImportInfo {
    childObjectName?: string;
    importStatus?: ImportStatus;
    parentObjectName?: string;
    remarks?: string;
}

// @public
export type ImportStatus = "SUCCESS" | "FAILED";

// @public
export enum KnownApiVersions {
    V20230901 = "2023-09-01"
}

// @public
export type LineageDirection = "INPUT" | "OUTPUT" | "BOTH";

// @public
export interface LineageGetByUniqueAttributeOptionalParams extends OperationOptions {
    attribute?: string;
    depth?: number;
}

// @public
export interface LineageGetNextPageOptionalParams extends OperationOptions {
    limit?: number;
    offset?: number;
}

// @public
export interface LineageGetOptionalParams extends OperationOptions {
    depth?: number;
}

// @public
export interface LineageOperations {
    get: (guid: string, direction: LineageDirection, options?: LineageGetOptionalParams) => Promise<AtlasLineageInfo>;
    getByUniqueAttribute: (typeName: string, direction: LineageDirection, options?: LineageGetByUniqueAttributeOptionalParams) => Promise<AtlasLineageInfo>;
    getNextPage: (guid: string, direction: LineageDirection, options?: LineageGetNextPageOptionalParams) => Promise<AtlasLineageInfo>;
}

// @public
export interface LineageRelation {
    fromEntityId?: string;
    relationshipId?: string;
    toEntityId?: string;
}

// @public
export interface MoveEntitiesOptions {
    entityGuids?: string[];
}

// @public
export interface NumberFormat {
    availableLocales?: string[];
    currency?: string;
    currencyInstance?: NumberFormat;
    groupingUsed?: boolean;
    instance?: NumberFormat;
    integerInstance?: NumberFormat;
    maximumFractionDigits?: number;
    maximumIntegerDigits?: number;
    minimumFractionDigits?: number;
    minimumIntegerDigits?: number;
    numberInstance?: NumberFormat;
    parseIntegerOnly?: boolean;
    percentInstance?: NumberFormat;
    roundingMode?: RoundingMode;
}

// @public
export interface ParentRelation {
    childEntityId?: string;
    parentEntityId?: string;
    relationshipId?: string;
}

// @public
export interface PurviewObjectId {
    displayText?: string;
    guid?: string;
    itemPath?: string;
    name?: string;
    properties?: Record<string, any>;
    resourceId?: string;
    typeName?: string;
    uniqueAttributes?: Record<string, any>;
}

// @public
export interface QueryOptions {
    continuationToken?: string;
    facets?: SearchFacetItem[];
    filter?: any;
    keywords?: string;
    limit?: number;
    orderby?: any[];
    taxonomySetting?: SearchTaxonomySetting;
}

// @public
export interface QueryResult {
    continuationToken?: string;
    searchCount?: number;
    searchCountApproximate?: boolean;
    searchFacets?: SearchFacetResultValue;
    value?: SearchResultValue[];
}

// @public
export type RelationshipCategory = "ASSOCIATION" | "AGGREGATION" | "COMPOSITION";

// @public
export interface RelationshipCreateOptionalParams extends OperationOptions {
}

// @public
export interface RelationshipDeleteOptionalParams extends OperationOptions {
}

// @public
export interface RelationshipGetOptionalParams extends OperationOptions {
    extendedInfo?: boolean;
}

// @public
export interface RelationshipOperations {
    create: (body: AtlasRelationship, options?: RelationshipCreateOptionalParams) => Promise<AtlasRelationship>;
    delete: (guid: string, options?: RelationshipDeleteOptionalParams) => Promise<void>;
    get: (guid: string, options?: RelationshipGetOptionalParams) => Promise<AtlasRelationshipWithExtInfo>;
    update: (body: AtlasRelationship, options?: RelationshipUpdateOptionalParams) => Promise<AtlasRelationship>;
}

// @public
export interface RelationshipUpdateOptionalParams extends OperationOptions {
}

// @public
export interface ResourceLink {
    displayName?: string;
    url?: string;
}

// @public
export type RoundingMode = "UP" | "DOWN" | "CEILING" | "FLOOR" | "HALF_UP" | "HALF_DOWN" | "HALF_EVEN" | "UNNECESSARY";

// @public
export interface SearchFacetItem {
    count?: number;
    facet?: string;
    sort?: SearchFacetSort;
}

// @public
export interface SearchFacetItemValue {
    count?: number;
    value?: string;
}

// @public
export interface SearchFacetResultValue {
    assetType?: SearchFacetItemValue[];
    classification?: SearchFacetItemValue[];
    contactId?: SearchFacetItemValue[];
    contactType?: SearchFacetItemValue[];
    entityType?: SearchFacetItemValue[];
    glossaryType?: SearchFacetItemValue[];
    label?: SearchFacetItemValue[];
    term?: SearchFacetItemValue[];
    termStatus?: SearchFacetItemValue[];
    termTemplate?: SearchFacetItemValue[];
}

// @public
export interface SearchFacetSort {
    count?: SearchSortOrder;
    value?: SearchSortOrder;
}

// @public
export interface SearchHighlights {
    description?: string[];
    entityType?: string[];
    id?: string[];
    name?: string[];
    qualifiedName?: string[];
}

// @public
export interface SearchResultValue {
    assetType?: string[];
    classification?: string[];
    contact?: ContactSearchResultValue[];
    createTime?: number;
    description?: string;
    endorsement?: string[];
    entityType?: string;
    glossary?: string;
    glossaryType?: string;
    id?: string;
    label?: string[];
    longDescription?: string;
    name?: string;
    objectType?: string;
    owner?: string;
    qualifiedName?: string;
    searchHighlights?: SearchHighlights;
    searchScore?: number;
    term?: TermSearchResultValue[];
    termStatus?: string;
    termTemplate?: string[];
    updateTime?: number;
}

// @public
export type SearchSortOrder = "asc" | "desc";

// @public
export interface SearchTaxonomySetting {
    assetTypes?: string[];
    facet?: SearchFacetItem;
}

// @public
export type SortType = "NONE" | "ASC" | "DESC";

// @public
export type StatusAtlasRelationship = "ACTIVE" | "DELETED";

// @public
export interface SuggestOptions {
    filter?: any;
    keywords?: string;
    limit?: number;
}

// @public
export interface SuggestResult {
    value?: SuggestResultValue[];
}

// @public
export interface SuggestResultValue {
    assetType?: string[];
    classification?: string[];
    contact?: ContactSearchResultValue[];
    createTime?: number;
    description?: string;
    endorsement?: string[];
    entityType?: string;
    glossary?: string;
    glossaryType?: string;
    id?: string;
    label?: string[];
    longDescription?: string;
    name?: string;
    objectType?: string;
    owner?: string;
    qualifiedName?: string;
    searchScore?: number;
    searchText?: string;
    term?: TermSearchResultValue[];
    termStatus?: string;
    termTemplate?: string[];
    updateTime?: number;
}

// @public
export interface TermSearchResultValue {
    glossaryName?: string;
    guid?: string;
    name?: string;
}

// @public
export type TermStatus = "Draft" | "Approved" | "Alert" | "Expired";

// @public
export interface TermTemplateDef {
    attributeDefs?: AtlasAttributeDef[];
    category?: TypeCategory;
    createdBy?: string;
    createTime?: number;
    dateFormatter?: DateFormat;
    description?: string;
    guid?: string;
    lastModifiedTS?: string;
    name?: string;
    options?: Record<string, string>;
    serviceType?: string;
    typeVersion?: string;
    updatedBy?: string;
    updateTime?: number;
    version?: number;
}

// @public
export interface TimeBoundary {
    endTime?: string;
    startTime?: string;
    timeZone?: string;
}

// @public
export interface TimeZone {
    availableIds?: string[];
    default?: TimeZone;
    displayName?: string;
    dstSavings?: number;
    id?: string;
    rawOffset?: number;
}

// @public
export type TypeCategory = "PRIMITIVE" | "OBJECT_ID_TYPE" | "ENUM" | "STRUCT" | "CLASSIFICATION" | "ENTITY" | "ARRAY" | "MAP" | "RELATIONSHIP" | "TERM_TEMPLATE";

// @public
export interface TypeDefinitionBatchCreateOptionalParams extends OperationOptions {
}

// @public
export interface TypeDefinitionBatchDeleteOptionalParams extends OperationOptions {
}

// @public
export interface TypeDefinitionBatchUpdateOptionalParams extends OperationOptions {
}

// @public
export interface TypeDefinitionDeleteOptionalParams extends OperationOptions {
}

// @public
export interface TypeDefinitionGetBusinessMetadataByIdOptionalParams extends OperationOptions {
}

// @public
export interface TypeDefinitionGetBusinessMetadataByNameOptionalParams extends OperationOptions {
}

// @public
export interface TypeDefinitionGetByIdOptionalParams extends OperationOptions {
}

// @public
export interface TypeDefinitionGetByNameOptionalParams extends OperationOptions {
}

// @public
export interface TypeDefinitionGetClassificationByIdOptionalParams extends OperationOptions {
}

// @public
export interface TypeDefinitionGetClassificationByNameOptionalParams extends OperationOptions {
}

// @public
export interface TypeDefinitionGetEntityByIdOptionalParams extends OperationOptions {
}

// @public
export interface TypeDefinitionGetEntityByNameOptionalParams extends OperationOptions {
}

// @public
export interface TypeDefinitionGetEnumByIdOptionalParams extends OperationOptions {
}

// @public
export interface TypeDefinitionGetEnumByNameOptionalParams extends OperationOptions {
}

// @public
export interface TypeDefinitionGetHeadersOptionalParams extends OperationOptions {
    includeTermTemplate?: boolean;
    typeParam?: TypeCategory;
}

// @public
export interface TypeDefinitionGetOptionalParams extends OperationOptions {
    includeTermTemplate?: boolean;
    typeParam?: TypeCategory;
}

// @public
export interface TypeDefinitionGetRelationshipByIdOptionalParams extends OperationOptions {
}

// @public
export interface TypeDefinitionGetRelationshipByNameOptionalParams extends OperationOptions {
}

// @public
export interface TypeDefinitionGetStructByIdOptionalParams extends OperationOptions {
}

// @public
export interface TypeDefinitionGetStructByNameOptionalParams extends OperationOptions {
}

// @public
export interface TypeDefinitionGetTermTemplateByIdOptionalParams extends OperationOptions {
}

// @public
export interface TypeDefinitionGetTermTemplateByNameOptionalParams extends OperationOptions {
}

// @public
export interface TypeDefinitionOperations {
    batchCreate: (body: AtlasTypesDef, options?: TypeDefinitionBatchCreateOptionalParams) => Promise<AtlasTypesDef>;
    batchDelete: (body: AtlasTypesDef, options?: TypeDefinitionBatchDeleteOptionalParams) => Promise<void>;
    batchUpdate: (body: AtlasTypesDef, options?: TypeDefinitionBatchUpdateOptionalParams) => Promise<AtlasTypesDef>;
    delete: (name: string, options?: TypeDefinitionDeleteOptionalParams) => Promise<void>;
    get: (options?: TypeDefinitionGetOptionalParams) => Promise<AtlasTypesDef>;
    getBusinessMetadataById: (guid: string, options?: TypeDefinitionGetBusinessMetadataByIdOptionalParams) => Promise<AtlasBusinessMetadataDef>;
    getBusinessMetadataByName: (name: string, options?: TypeDefinitionGetBusinessMetadataByNameOptionalParams) => Promise<AtlasBusinessMetadataDef>;
    getById: (guid: string, options?: TypeDefinitionGetByIdOptionalParams) => Promise<AtlasTypeDef>;
    getByName: (name: string, options?: TypeDefinitionGetByNameOptionalParams) => Promise<AtlasTypeDef>;
    getClassificationById: (guid: string, options?: TypeDefinitionGetClassificationByIdOptionalParams) => Promise<AtlasClassificationDef>;
    getClassificationByName: (name: string, options?: TypeDefinitionGetClassificationByNameOptionalParams) => Promise<AtlasClassificationDef>;
    getEntityById: (guid: string, options?: TypeDefinitionGetEntityByIdOptionalParams) => Promise<AtlasEntityDef>;
    getEntityByName: (name: string, options?: TypeDefinitionGetEntityByNameOptionalParams) => Promise<AtlasEntityDef>;
    getEnumById: (guid: string, options?: TypeDefinitionGetEnumByIdOptionalParams) => Promise<AtlasEnumDef>;
    getEnumByName: (name: string, options?: TypeDefinitionGetEnumByNameOptionalParams) => Promise<AtlasEnumDef>;
    getHeaders: (options?: TypeDefinitionGetHeadersOptionalParams) => Promise<AtlasTypeDefHeader[]>;
    getRelationshipById: (guid: string, options?: TypeDefinitionGetRelationshipByIdOptionalParams) => Promise<AtlasRelationshipDef>;
    getRelationshipByName: (name: string, options?: TypeDefinitionGetRelationshipByNameOptionalParams) => Promise<AtlasRelationshipDef>;
    getStructById: (guid: string, options?: TypeDefinitionGetStructByIdOptionalParams) => Promise<AtlasStructDef>;
    getStructByName: (name: string, options?: TypeDefinitionGetStructByNameOptionalParams) => Promise<AtlasStructDef>;
    getTermTemplateById: (guid: string, options?: TypeDefinitionGetTermTemplateByIdOptionalParams) => Promise<TermTemplateDef>;
    getTermTemplateByName: (name: string, options?: TypeDefinitionGetTermTemplateByNameOptionalParams) => Promise<TermTemplateDef>;
}

// (No @packageDocumentation comment for this package)

```
