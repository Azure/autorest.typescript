{"version":3,"file":"paginateHelper.js","sourceRoot":"","sources":["../../../src/rest/paginateHelper.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  getPagedAsyncIterator,\n  PagedAsyncIterableIterator,\n  PagedResult,\n} from \"@azure/core-paging\";\nimport {\n  Client,\n  createRestError,\n  PathUncheckedResponse,\n} from \"@azure-rest/core-client\";\n\n/**\n * Helper type to extract the type of an array\n */\nexport type GetArrayType<T> = T extends Array<infer TData> ? TData : never;\n\n/**\n * The type of a custom function that defines how to get a page and a link to the next one if any.\n */\nexport type GetPage<TPage> = (\n  pageLink: string,\n  maxPageSize?: number,\n) => Promise<{\n  page: TPage;\n  nextPageLink?: string;\n}>;\n\n/**\n * Options for the paging helper\n */\nexport interface PagingOptions<TResponse> {\n  /**\n   * Custom function to extract pagination details for crating the PagedAsyncIterableIterator\n   */\n  customGetPage?: GetPage<PaginateReturn<TResponse>[]>;\n}\n\n/**\n * Helper type to infer the Type of the paged elements from the response type\n * This type is generated based on the swagger information for x-ms-pageable\n * specifically on the itemName property which indicates the property of the response\n * where the page items are found. The default value is `value`.\n * This type will allow us to provide strongly typed Iterator based on the response we get as second parameter\n */\nexport type PaginateReturn<TResult> = TResult extends\n  | {\n      body: { value?: infer TPage };\n    }\n  | {\n      body: { models?: infer TPage };\n    }\n  ? GetArrayType<TPage>\n  : Array<unknown>;\n\n/**\n * Helper to paginate results from an initial response that follows the specification of Autorest `x-ms-pageable` extension\n * @param client - Client to use for sending the next page requests\n * @param initialResponse - Initial response containing the nextLink and current page of elements\n * @param customGetPage - Optional - Function to define how to extract the page and next link to be used to paginate the results\n * @returns - PagedAsyncIterableIterator to iterate the elements\n */\nexport function paginate<TResponse extends PathUncheckedResponse>(\n  client: Client,\n  initialResponse: TResponse,\n  options: PagingOptions<TResponse> = {},\n): PagedAsyncIterableIterator<PaginateReturn<TResponse>> {\n  // Extract element type from initial response\n  type TElement = PaginateReturn<TResponse>;\n  let firstRun = true;\n  // We need to check the response for success before trying to inspect it looking for\n  // the properties to use for nextLink and itemName\n  checkPagingRequest(initialResponse);\n  const { itemName, nextLinkName } = getPaginationProperties(initialResponse);\n  const { customGetPage } = options;\n  const pagedResult: PagedResult<TElement[]> = {\n    firstPageLink: \"\",\n    getPage:\n      typeof customGetPage === \"function\"\n        ? customGetPage\n        : async (pageLink: string) => {\n            const result = firstRun\n              ? initialResponse\n              : await client.pathUnchecked(pageLink).get();\n            firstRun = false;\n            checkPagingRequest(result);\n            const nextLink = getNextLink(result.body, nextLinkName);\n            const values = getElements<TElement>(result.body, itemName);\n            return {\n              page: values,\n              nextPageLink: nextLink,\n            };\n          },\n  };\n\n  return getPagedAsyncIterator(pagedResult);\n}\n\n/**\n * Gets for the value of nextLink in the body\n */\nfunction getNextLink(body: unknown, nextLinkName?: string): string | undefined {\n  if (!nextLinkName) {\n    return undefined;\n  }\n\n  const nextLink = (body as Record<string, unknown>)[nextLinkName];\n\n  if (typeof nextLink !== \"string\" && typeof nextLink !== \"undefined\") {\n    throw new Error(\n      `Body Property ${nextLinkName} should be a string or undefined`,\n    );\n  }\n\n  return nextLink;\n}\n\n/**\n * Gets the elements of the current request in the body.\n */\nfunction getElements<T = unknown>(body: unknown, itemName: string): T[] {\n  const value = (body as Record<string, unknown>)[itemName] as T[];\n\n  // value has to be an array according to the x-ms-pageable extension.\n  // The fact that this must be an array is used above to calculate the\n  // type of elements in the page in PaginateReturn\n  if (!Array.isArray(value)) {\n    throw new Error(\n      `Couldn't paginate response\\n Body doesn't contain an array property with name: ${itemName}`,\n    );\n  }\n\n  return value ?? [];\n}\n\n/**\n * Checks if a request failed\n */\nfunction checkPagingRequest(response: PathUncheckedResponse): void {\n  const Http2xxStatusCodes = [\n    \"200\",\n    \"201\",\n    \"202\",\n    \"203\",\n    \"204\",\n    \"205\",\n    \"206\",\n    \"207\",\n    \"208\",\n    \"226\",\n  ];\n  if (!Http2xxStatusCodes.includes(response.status)) {\n    throw createRestError(\n      `Pagination failed with unexpected statusCode ${response.status}`,\n      response,\n    );\n  }\n}\n\n/**\n * Extracts the itemName and nextLinkName from the initial response to use them for pagination\n */\nfunction getPaginationProperties(initialResponse: PathUncheckedResponse) {\n  // Build a set with the passed custom nextLinkNames\n  const nextLinkNames = new Set([\"nextLink\"]);\n\n  // Build a set with the passed custom set of itemNames\n  const itemNames = new Set([\"value\", \"models\"]);\n\n  let nextLinkName: string | undefined;\n  let itemName: string | undefined;\n\n  for (const name of nextLinkNames) {\n    const nextLink = (initialResponse.body as Record<string, unknown>)[\n      name\n    ] as string;\n    if (nextLink) {\n      nextLinkName = name;\n      break;\n    }\n  }\n\n  for (const name of itemNames) {\n    const item = (initialResponse.body as Record<string, unknown>)[\n      name\n    ] as string;\n    if (item) {\n      itemName = name;\n      break;\n    }\n  }\n\n  if (!itemName) {\n    throw new Error(\n      `Couldn't paginate response\\n Body doesn't contain an array property with name: ${[\n        ...itemNames,\n      ].join(\" OR \")}`,\n    );\n  }\n\n  return { itemName, nextLinkName };\n}\n"]}