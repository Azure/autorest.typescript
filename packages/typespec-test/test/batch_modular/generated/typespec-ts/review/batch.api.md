## API Report File for "@azure-rest/batch"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ClientOptions } from '@azure-rest/core-client';
import { OperationOptions } from '@azure-rest/core-client';
import { Pipeline } from '@azure/core-rest-pipeline';
import { TokenCredential } from '@azure/core-auth';

// @public
export type AccessScope = "job";

// @public
export interface AffinityInformation {
    affinityId: string;
}

// @public
export type AllocationState = "steady" | "resizing" | "stopping";

// @public
export interface ApplicationPackageReference {
    applicationId: string;
    version?: string;
}

// @public
export interface AuthenticationTokenSettings {
    access?: AccessScope[];
}

// @public
export interface AutoPoolSpecification {
    autoPoolIdPrefix?: string;
    keepAlive?: boolean;
    pool?: PoolSpecification;
    poolLifetimeOption: PoolLifetimeOption;
}

// @public
export interface AutoScaleRun {
    error?: AutoScaleRunError;
    results?: string;
    timestamp: Date;
}

// @public
export interface AutoScaleRunError {
    code?: string;
    message?: string;
    values?: NameValuePair[];
}

// @public
export type AutoUserScope = "task" | "pool";

// @public
export interface AutoUserSpecification {
    elevationLevel?: ElevationLevel;
    scope?: AutoUserScope;
}

// @public
export interface AzureBlobFileSystemConfiguration {
    accountKey?: string;
    accountName: string;
    blobfuseOptions?: string;
    containerName: string;
    identityReference?: BatchNodeIdentityReference;
    relativeMountPath: string;
    sasKey?: string;
}

// @public
export interface AzureFileShareConfiguration {
    accountKey: string;
    accountName: string;
    azureFileUrl: string;
    mountOptions?: string;
    relativeMountPath: string;
}

// @public
export interface BatchApplication {
    displayName: string;
    id: string;
    versions: string[];
}

// @public
export interface BatchCertificate {
    certificateFormat?: CertificateFormat;
    data: Uint8Array;
    readonly deleteCertificateError?: DeleteCertificateError;
    password?: string;
    readonly previousState?: CertificateState;
    readonly previousStateTransitionTime?: Date;
    readonly publicData?: Uint8Array;
    readonly state?: CertificateState;
    readonly stateTransitionTime?: Date;
    thumbprint: string;
    thumbprintAlgorithm: string;
    readonly url?: string;
}

// @public (undocumented)
export class BatchClient {
    constructor(endpointParam: string, credential: TokenCredential, options?: BatchClientOptionalParams);
    cancelCertificateDeletion(thumbprintAlgorithm: string, thumbprint: string, options?: CancelCertificateDeletionOptionalParams): Promise<void>;
    createCertificate(body: BatchCertificate, options?: CreateCertificateOptionalParams): Promise<void>;
    createJob(body: BatchJobCreateOptions, options?: CreateJobOptionalParams): Promise<void>;
    createJobSchedule(body: BatchJobScheduleCreateOptions, options?: CreateJobScheduleOptionalParams): Promise<void>;
    createNodeUser(poolId: string, nodeId: string, body: BatchNodeUserCreateOptions, options?: CreateNodeUserOptionalParams): Promise<void>;
    createPool(body: BatchPoolCreateOptions, options?: CreatePoolOptionalParams): Promise<void>;
    createTask(jobId: string, body: BatchTaskCreateOptions, options?: CreateTaskOptionalParams): Promise<void>;
    createTaskCollection(jobId: string, collection: BatchTaskCollection, options?: CreateTaskCollectionOptionalParams): Promise<TaskAddCollectionResult>;
    deleteCertificate(thumbprintAlgorithm: string, thumbprint: string, options?: DeleteCertificateOptionalParams): Promise<void>;
    deleteJob(jobId: string, options?: DeleteJobOptionalParams): Promise<void>;
    deleteJobSchedule(jobScheduleId: string, options?: DeleteJobScheduleOptionalParams): Promise<void>;
    deleteNodeFile(poolId: string, nodeId: string, filePath: string, options?: DeleteNodeFileOptionalParams): Promise<void>;
    deleteNodeUser(poolId: string, nodeId: string, userName: string, options?: DeleteNodeUserOptionalParams): Promise<void>;
    deletePool(poolId: string, options?: DeletePoolOptionalParams): Promise<void>;
    deleteTask(jobId: string, taskId: string, options?: DeleteTaskOptionalParams): Promise<void>;
    deleteTaskFile(jobId: string, taskId: string, filePath: string, options?: DeleteTaskFileOptionalParams): Promise<void>;
    disableJob(jobId: string, body: BatchJobDisableOptions, options?: DisableJobOptionalParams): Promise<void>;
    disableJobSchedule(jobScheduleId: string, options?: DisableJobScheduleOptionalParams): Promise<void>;
    disableNodeScheduling(poolId: string, nodeId: string, options?: DisableNodeSchedulingOptionalParams): Promise<void>;
    disablePoolAutoScale(poolId: string, options?: DisablePoolAutoScaleOptionalParams): Promise<void>;
    enableJob(jobId: string, options?: EnableJobOptionalParams): Promise<void>;
    enableJobSchedule(jobScheduleId: string, options?: EnableJobScheduleOptionalParams): Promise<void>;
    enableNodeScheduling(poolId: string, nodeId: string, options?: EnableNodeSchedulingOptionalParams): Promise<void>;
    enablePoolAutoScale(poolId: string, body: BatchPoolEnableAutoScaleOptions, options?: EnablePoolAutoScaleOptionalParams): Promise<void>;
    evaluatePoolAutoScale(poolId: string, body: BatchPoolEvaluateAutoScaleOptions, options?: EvaluatePoolAutoScaleOptionalParams): Promise<AutoScaleRun>;
    getApplication(applicationId: string, options?: GetApplicationOptionalParams): Promise<BatchApplication>;
    getCertificate(thumbprintAlgorithm: string, thumbprint: string, options?: GetCertificateOptionalParams): Promise<BatchCertificate>;
    getJob(jobId: string, options?: GetJobOptionalParams): Promise<BatchJob>;
    getJobSchedule(jobScheduleId: string, options?: GetJobScheduleOptionalParams): Promise<BatchJobSchedule>;
    getJobTaskCounts(jobId: string, options?: GetJobTaskCountsOptionalParams): Promise<TaskCountsResult>;
    getNode(poolId: string, nodeId: string, options?: GetNodeOptionalParams): Promise<BatchNode>;
    getNodeExtension(poolId: string, nodeId: string, extensionName: string, options?: GetNodeExtensionOptionalParams): Promise<NodeVMExtension>;
    getNodeFile(poolId: string, nodeId: string, filePath: string, options?: GetNodeFileOptionalParams): Promise<Uint8Array>;
    getNodeFileProperties(poolId: string, nodeId: string, filePath: string, options?: GetNodeFilePropertiesOptionalParams): Promise<void>;
    getNodeRemoteDesktopFile(poolId: string, nodeId: string, options?: GetNodeRemoteDesktopFileOptionalParams): Promise<Uint8Array>;
    getNodeRemoteLoginSettings(poolId: string, nodeId: string, options?: GetNodeRemoteLoginSettingsOptionalParams): Promise<BatchNodeRemoteLoginSettingsResult>;
    getPool(poolId: string, options?: GetPoolOptionalParams): Promise<BatchPool>;
    getTask(jobId: string, taskId: string, options?: GetTaskOptionalParams): Promise<BatchTask>;
    getTaskFile(jobId: string, taskId: string, filePath: string, options?: GetTaskFileOptionalParams): Promise<Uint8Array>;
    getTaskFileProperties(jobId: string, taskId: string, filePath: string, options?: GetTaskFilePropertiesOptionalParams): Promise<void>;
    jobScheduleExists(jobScheduleId: string, options?: JobScheduleExistsOptionalParams): Promise<void>;
    listApplications(options?: ListApplicationsOptionalParams): PagedAsyncIterableIterator<BatchApplication>;
    listCertificates(options?: ListCertificatesOptionalParams): PagedAsyncIterableIterator<BatchCertificate>;
    listJobPreparationAndReleaseTaskStatus(jobId: string, options?: ListJobPreparationAndReleaseTaskStatusOptionalParams): PagedAsyncIterableIterator<JobPreparationAndReleaseTaskExecutionInformation>;
    listJobs(options?: ListJobsOptionalParams): PagedAsyncIterableIterator<BatchJob>;
    listJobSchedules(options?: ListJobSchedulesOptionalParams): PagedAsyncIterableIterator<BatchJobSchedule>;
    listJobsFromSchedule(jobScheduleId: string, options?: ListJobsFromScheduleOptionalParams): PagedAsyncIterableIterator<BatchJob>;
    listNodeExtensions(poolId: string, nodeId: string, options?: ListNodeExtensionsOptionalParams): PagedAsyncIterableIterator<NodeVMExtension>;
    listNodeFiles(poolId: string, nodeId: string, options?: ListNodeFilesOptionalParams): PagedAsyncIterableIterator<NodeFile>;
    listNodes(poolId: string, options?: ListNodesOptionalParams): PagedAsyncIterableIterator<BatchNode>;
    listPoolNodeCounts(options?: ListPoolNodeCountsOptionalParams): PagedAsyncIterableIterator<PoolNodeCounts>;
    listPools(options?: ListPoolsOptionalParams): PagedAsyncIterableIterator<BatchPool>;
    listPoolUsageMetrics(options?: ListPoolUsageMetricsOptionalParams): PagedAsyncIterableIterator<PoolUsageMetrics>;
    listSubTasks(jobId: string, taskId: string, options?: ListSubTasksOptionalParams): Promise<BatchTaskListSubtasksResult>;
    listSupportedImages(options?: ListSupportedImagesOptionalParams): PagedAsyncIterableIterator<ImageInformation>;
    listTaskFiles(jobId: string, taskId: string, options?: ListTaskFilesOptionalParams): PagedAsyncIterableIterator<NodeFile>;
    listTasks(jobId: string, options?: ListTasksOptionalParams): PagedAsyncIterableIterator<BatchTask>;
    readonly pipeline: Pipeline;
    poolExists(poolId: string, options?: PoolExistsOptionalParams): Promise<void>;
    reactivateTask(jobId: string, taskId: string, options?: ReactivateTaskOptionalParams): Promise<void>;
    rebootNode(poolId: string, nodeId: string, options?: RebootNodeOptionalParams): Promise<void>;
    reimageNode(poolId: string, nodeId: string, options?: ReimageNodeOptionalParams): Promise<void>;
    removeNodes(poolId: string, body: NodeRemoveOptions, options?: RemoveNodesOptionalParams): Promise<void>;
    replaceJob(jobId: string, body: BatchJob, options?: ReplaceJobOptionalParams): Promise<void>;
    replaceJobSchedule(jobScheduleId: string, body: BatchJobSchedule, options?: ReplaceJobScheduleOptionalParams): Promise<void>;
    replaceNodeUser(poolId: string, nodeId: string, userName: string, body: BatchNodeUserUpdateOptions, options?: ReplaceNodeUserOptionalParams): Promise<void>;
    replacePoolProperties(poolId: string, body: BatchPoolReplaceOptions, options?: ReplacePoolPropertiesOptionalParams): Promise<void>;
    replaceTask(jobId: string, taskId: string, body: BatchTask, options?: ReplaceTaskOptionalParams): Promise<void>;
    resizePool(poolId: string, body: BatchPoolResizeOptions, options?: ResizePoolOptionalParams): Promise<void>;
    stopPoolResize(poolId: string, options?: StopPoolResizeOptionalParams): Promise<void>;
    terminateJob(jobId: string, options?: TerminateJobOptionalParams): Promise<void>;
    terminateJobSchedule(jobScheduleId: string, options?: TerminateJobScheduleOptionalParams): Promise<void>;
    terminateTask(jobId: string, taskId: string, options?: TerminateTaskOptionalParams): Promise<void>;
    updateJob(jobId: string, body: BatchJobUpdateOptions, options?: UpdateJobOptionalParams): Promise<void>;
    updateJobSchedule(jobScheduleId: string, body: BatchJobScheduleUpdateOptions, options?: UpdateJobScheduleOptionalParams): Promise<void>;
    updatePool(poolId: string, body: BatchPoolUpdateOptions, options?: UpdatePoolOptionalParams): Promise<void>;
    uploadNodeLogs(poolId: string, nodeId: string, body: UploadBatchServiceLogsOptions, options?: UploadNodeLogsOptionalParams): Promise<UploadBatchServiceLogsResult>;
}

// @public
export interface BatchClientOptionalParams extends ClientOptions {
    apiVersion?: string;
}

// @public
export interface BatchError {
    code: string;
    message?: ErrorMessage;
    values?: BatchErrorDetail[];
}

// @public
export interface BatchErrorDetail {
    key?: string;
    value?: string;
}

// @public
export interface BatchJob {
    allowTaskPreemption?: boolean;
    readonly commonEnvironmentSettings?: EnvironmentSetting[];
    constraints?: JobConstraints;
    readonly creationTime?: Date;
    readonly displayName?: string;
    readonly eTag?: string;
    readonly executionInfo?: JobExecutionInformation;
    readonly id?: string;
    readonly jobManagerTask?: JobManagerTask;
    readonly jobPreparationTask?: JobPreparationTask;
    readonly jobReleaseTask?: JobReleaseTask;
    readonly lastModified?: Date;
    maxParallelTasks?: number;
    metadata?: MetadataItem[];
    readonly networkConfiguration?: JobNetworkConfiguration;
    onAllTasksComplete?: OnAllTasksComplete;
    readonly onTaskFailure?: OnTaskFailure;
    poolInfo: PoolInformation;
    readonly previousState?: JobState;
    readonly previousStateTransitionTime?: Date;
    priority?: number;
    readonly state?: JobState;
    readonly stateTransitionTime?: Date;
    readonly stats?: JobStatistics;
    readonly url?: string;
    readonly usesTaskDependencies?: boolean;
}

// @public
export interface BatchJobCreateOptions {
    allowTaskPreemption?: boolean;
    commonEnvironmentSettings?: EnvironmentSetting[];
    constraints?: JobConstraints;
    displayName?: string;
    id: string;
    jobManagerTask?: JobManagerTask;
    jobPreparationTask?: JobPreparationTask;
    jobReleaseTask?: JobReleaseTask;
    maxParallelTasks?: number;
    metadata?: MetadataItem[];
    networkConfiguration?: JobNetworkConfiguration;
    onAllTasksComplete?: OnAllTasksComplete;
    onTaskFailure?: OnTaskFailure;
    poolInfo: PoolInformation;
    priority?: number;
    usesTaskDependencies?: boolean;
}

// @public
export interface BatchJobDisableOptions {
    disableTasks: DisableJobOption;
}

// @public
export interface BatchJobSchedule {
    readonly creationTime?: Date;
    readonly displayName?: string;
    readonly eTag?: string;
    readonly executionInfo?: JobScheduleExecutionInformation;
    readonly id?: string;
    jobSpecification: JobSpecification;
    readonly lastModified?: Date;
    metadata?: MetadataItem[];
    readonly previousState?: JobScheduleState;
    readonly previousStateTransitionTime?: Date;
    schedule: Schedule;
    readonly state?: JobScheduleState;
    readonly stateTransitionTime?: Date;
    readonly stats?: JobScheduleStatistics;
    readonly url?: string;
}

// @public
export interface BatchJobScheduleCreateOptions {
    displayName?: string;
    id: string;
    jobSpecification: JobSpecification;
    metadata?: MetadataItem[];
    schedule: Schedule;
}

// @public
export interface BatchJobScheduleUpdateOptions {
    jobSpecification?: JobSpecification;
    metadata?: MetadataItem[];
    schedule?: Schedule;
}

// @public
export interface BatchJobTerminateOptions {
    terminateReason?: string;
}

// @public
export interface BatchJobUpdateOptions {
    allowTaskPreemption?: boolean;
    constraints?: JobConstraints;
    maxParallelTasks?: number;
    metadata?: MetadataItem[];
    onAllTasksComplete?: OnAllTasksComplete;
    poolInfo?: PoolInformation;
    priority?: number;
}

// @public
export interface BatchNode {
    affinityId?: string;
    allocationTime?: Date;
    certificateReferences?: CertificateReference[];
    endpointConfiguration?: BatchNodeEndpointConfiguration;
    errors?: BatchNodeError[];
    id?: string;
    ipAddress?: string;
    isDedicated?: boolean;
    lastBootTime?: Date;
    nodeAgentInfo?: NodeAgentInformation;
    recentTasks?: TaskInformation[];
    runningTasksCount?: number;
    runningTaskSlotsCount?: number;
    schedulingState?: SchedulingState;
    startTask?: StartTask;
    startTaskInfo?: StartTaskInformation;
    state?: BatchNodeState;
    stateTransitionTime?: Date;
    totalTasksRun?: number;
    totalTasksSucceeded?: number;
    url?: string;
    virtualMachineInfo?: VirtualMachineInfo;
    vmSize?: string;
}

// @public
export type BatchNodeDeallocationOption = "requeue" | "terminate" | "taskcompletion" | "retaineddata";

// @public
export interface BatchNodeEndpointConfiguration {
    inboundEndpoints: InboundEndpoint[];
}

// @public
export interface BatchNodeError {
    code?: string;
    errorDetails?: NameValuePair[];
    message?: string;
}

// @public
export type BatchNodeFillType = "spread" | "pack";

// @public
export interface BatchNodeIdentityReference {
    resourceId?: string;
}

// @public
export interface BatchNodeInformation {
    affinityId?: string;
    nodeId?: string;
    nodeUrl?: string;
    poolId?: string;
    taskRootDirectory?: string;
    taskRootDirectoryUrl?: string;
}

// @public
export type BatchNodeRebootOption = "requeue" | "terminate" | "taskcompletion" | "retaineddata";

// @public
export type BatchNodeReimageOption = "requeue" | "terminate" | "taskcompletion" | "retaineddata";

// @public
export interface BatchNodeRemoteLoginSettingsResult {
    remoteLoginIpAddress: string;
    remoteLoginPort: number;
}

// @public
export type BatchNodeState = "idle" | "rebooting" | "reimaging" | "running" | "unusable" | "creating" | "starting" | "waitingforstarttask" | "starttaskfailed" | "unknown" | "leavingpool" | "offline" | "preempted";

// @public
export interface BatchNodeUserCreateOptions {
    expiryTime?: Date;
    isAdmin?: boolean;
    name: string;
    password?: string;
    sshPublicKey?: string;
}

// @public
export interface BatchNodeUserUpdateOptions {
    expiryTime?: Date;
    password?: string;
    sshPublicKey?: string;
}

// @public
export interface BatchPool {
    readonly allocationState?: AllocationState;
    readonly allocationStateTransitionTime?: Date;
    readonly applicationLicenses?: string[];
    readonly applicationPackageReferences?: ApplicationPackageReference[];
    readonly autoScaleEvaluationInterval?: string;
    readonly autoScaleFormula?: string;
    readonly autoScaleRun?: AutoScaleRun;
    readonly certificateReferences?: CertificateReference[];
    readonly cloudServiceConfiguration?: CloudServiceConfiguration;
    readonly creationTime?: Date;
    readonly currentDedicatedNodes?: number;
    readonly currentLowPriorityNodes?: number;
    readonly currentNodeCommunicationMode?: NodeCommunicationMode;
    readonly displayName?: string;
    readonly enableAutoScale?: boolean;
    readonly enableInterNodeCommunication?: boolean;
    readonly eTag?: string;
    readonly id?: string;
    readonly identity?: BatchPoolIdentity;
    readonly lastModified?: Date;
    readonly metadata?: MetadataItem[];
    readonly mountConfiguration?: MountConfiguration[];
    readonly networkConfiguration?: NetworkConfiguration;
    readonly resizeErrors?: ResizeError[];
    readonly resizeTimeout?: string;
    startTask?: StartTask;
    readonly state?: PoolState;
    readonly stateTransitionTime?: Date;
    readonly stats?: PoolStatistics;
    readonly targetDedicatedNodes?: number;
    readonly targetLowPriorityNodes?: number;
    targetNodeCommunicationMode?: NodeCommunicationMode;
    readonly taskSchedulingPolicy?: TaskSchedulingPolicy;
    readonly taskSlotsPerNode?: number;
    readonly url?: string;
    readonly userAccounts?: UserAccount[];
    readonly virtualMachineConfiguration?: VirtualMachineConfiguration;
    readonly vmSize?: string;
}

// @public
export interface BatchPoolCreateOptions {
    applicationLicenses?: string[];
    applicationPackageReferences?: ApplicationPackageReference[];
    autoScaleEvaluationInterval?: string;
    autoScaleFormula?: string;
    certificateReferences?: CertificateReference[];
    cloudServiceConfiguration?: CloudServiceConfiguration;
    displayName?: string;
    enableAutoScale?: boolean;
    enableInterNodeCommunication?: boolean;
    id: string;
    metadata?: MetadataItem[];
    mountConfiguration?: MountConfiguration[];
    networkConfiguration?: NetworkConfiguration;
    resizeTimeout?: string;
    startTask?: StartTask;
    targetDedicatedNodes?: number;
    targetLowPriorityNodes?: number;
    targetNodeCommunicationMode?: NodeCommunicationMode;
    taskSchedulingPolicy?: TaskSchedulingPolicy;
    taskSlotsPerNode?: number;
    userAccounts?: UserAccount[];
    virtualMachineConfiguration?: VirtualMachineConfiguration;
    vmSize: string;
}

// @public
export interface BatchPoolEnableAutoScaleOptions {
    autoScaleEvaluationInterval?: string;
    autoScaleFormula?: string;
}

// @public
export interface BatchPoolEvaluateAutoScaleOptions {
    autoScaleFormula: string;
}

// @public
export interface BatchPoolIdentity {
    type: PoolIdentityType;
    userAssignedIdentities?: UserAssignedIdentity[];
}

// @public
export interface BatchPoolReplaceOptions {
    applicationPackageReferences: ApplicationPackageReference[];
    certificateReferences: CertificateReference[];
    metadata: MetadataItem[];
    startTask?: StartTask;
    targetNodeCommunicationMode?: NodeCommunicationMode;
}

// @public
export interface BatchPoolResizeOptions {
    nodeDeallocationOption?: BatchNodeDeallocationOption;
    resizeTimeout?: string;
    targetDedicatedNodes?: number;
    targetLowPriorityNodes?: number;
}

// @public
export interface BatchPoolUpdateOptions {
    applicationPackageReferences?: ApplicationPackageReference[];
    certificateReferences?: CertificateReference[];
    metadata?: MetadataItem[];
    startTask?: StartTask;
    targetNodeCommunicationMode?: NodeCommunicationMode;
}

// @public
export interface BatchTask {
    readonly affinityInfo?: AffinityInformation;
    readonly applicationPackageReferences?: ApplicationPackageReference[];
    readonly authenticationTokenSettings?: AuthenticationTokenSettings;
    readonly commandLine?: string;
    constraints?: TaskConstraints;
    readonly containerSettings?: TaskContainerSettings;
    readonly creationTime?: Date;
    readonly dependsOn?: TaskDependencies;
    readonly displayName?: string;
    readonly environmentSettings?: EnvironmentSetting[];
    readonly eTag?: string;
    readonly executionInfo?: TaskExecutionInformation;
    readonly exitConditions?: ExitConditions;
    readonly id?: string;
    readonly lastModified?: Date;
    readonly multiInstanceSettings?: MultiInstanceSettings;
    readonly nodeInfo?: BatchNodeInformation;
    readonly outputFiles?: OutputFile[];
    readonly previousState?: TaskState;
    readonly previousStateTransitionTime?: Date;
    readonly requiredSlots?: number;
    readonly resourceFiles?: ResourceFile[];
    readonly state?: TaskState;
    readonly stateTransitionTime?: Date;
    readonly stats?: TaskStatistics;
    readonly url?: string;
    readonly userIdentity?: UserIdentity;
}

// @public
export interface BatchTaskCollection {
    value: BatchTaskCreateOptions[];
}

// @public
export interface BatchTaskCreateOptions {
    affinityInfo?: AffinityInformation;
    applicationPackageReferences?: ApplicationPackageReference[];
    authenticationTokenSettings?: AuthenticationTokenSettings;
    commandLine: string;
    constraints?: TaskConstraints;
    containerSettings?: TaskContainerSettings;
    dependsOn?: TaskDependencies;
    displayName?: string;
    environmentSettings?: EnvironmentSetting[];
    exitConditions?: ExitConditions;
    id: string;
    multiInstanceSettings?: MultiInstanceSettings;
    outputFiles?: OutputFile[];
    requiredSlots?: number;
    resourceFiles?: ResourceFile[];
    userIdentity?: UserIdentity;
}

// @public
export interface BatchTaskListSubtasksResult {
    value?: SubtaskInformation[];
}

// @public
export type CachingType = "none" | "readonly" | "readwrite";

// @public
export interface CancelCertificateDeletionOptionalParams extends OperationOptions {
    apiVersion?: string;
    timeOutInSeconds?: number;
}

// @public
export type CertificateFormat = "pfx" | "cer";

// @public
export interface CertificateReference {
    storeLocation?: CertificateStoreLocation;
    storeName?: string;
    thumbprint: string;
    thumbprintAlgorithm: string;
    visibility?: CertificateVisibility[];
}

// @public
export type CertificateState = "active" | "deleting" | "deletefailed";

// @public
export type CertificateStoreLocation = "currentuser" | "localmachine";

// @public
export type CertificateVisibility = "starttask" | "task" | "remoteuser";

// @public
export interface CifsMountConfiguration {
    mountOptions?: string;
    password: string;
    relativeMountPath: string;
    source: string;
    username: string;
}

// @public
export interface CloudServiceConfiguration {
    osFamily: string;
    osVersion?: string;
}

// @public
export interface ContainerConfiguration {
    containerImageNames?: string[];
    containerRegistries?: ContainerRegistry[];
    type: ContainerType;
}

// @public
export interface ContainerRegistry {
    identityReference?: BatchNodeIdentityReference;
    password?: string;
    registryServer?: string;
    username?: string;
}

// @public
export type ContainerType = "dockerCompatible" | "criCompatible";

// @public
export type ContainerWorkingDirectory = "taskWorkingDirectory" | "containerImageDefault";

// @public
export type ContinuablePage<TElement, TPage = TElement[]> = TPage & {
    continuationToken?: string;
};

// @public
export interface CreateCertificateOptionalParams extends OperationOptions {
    apiVersion?: string;
    contentType?: string;
    timeOutInSeconds?: number;
}

// @public
export interface CreateJobOptionalParams extends OperationOptions {
    apiVersion?: string;
    contentType?: string;
    timeOutInSeconds?: number;
}

// @public
export interface CreateJobScheduleOptionalParams extends OperationOptions {
    apiVersion?: string;
    contentType?: string;
    timeOutInSeconds?: number;
}

// @public
export interface CreateNodeUserOptionalParams extends OperationOptions {
    apiVersion?: string;
    contentType?: string;
    timeOutInSeconds?: number;
}

// @public
export interface CreatePoolOptionalParams extends OperationOptions {
    apiVersion?: string;
    contentType?: string;
    timeOutInSeconds?: number;
}

// @public
export interface CreateTaskCollectionOptionalParams extends OperationOptions {
    apiVersion?: string;
    contentType?: string;
    timeOutInSeconds?: number;
}

// @public
export interface CreateTaskOptionalParams extends OperationOptions {
    apiVersion?: string;
    contentType?: string;
    timeOutInSeconds?: number;
}

// @public
export interface DataDisk {
    caching?: CachingType;
    diskSizeGb: number;
    lun: number;
    storageAccountType?: StorageAccountType;
}

// @public
export interface DeleteCertificateError {
    code?: string;
    message?: string;
    values?: NameValuePair[];
}

// @public
export interface DeleteCertificateOptionalParams extends OperationOptions {
    apiVersion?: string;
    timeOutInSeconds?: number;
}

// @public
export interface DeleteJobOptionalParams extends OperationOptions {
    apiVersion?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOutInSeconds?: number;
}

// @public
export interface DeleteJobScheduleOptionalParams extends OperationOptions {
    apiVersion?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOutInSeconds?: number;
}

// @public
export interface DeleteNodeFileOptionalParams extends OperationOptions {
    apiVersion?: string;
    recursive?: boolean;
    timeOutInSeconds?: number;
}

// @public
export interface DeleteNodeUserOptionalParams extends OperationOptions {
    apiVersion?: string;
    timeOutInSeconds?: number;
}

// @public
export interface DeletePoolOptionalParams extends OperationOptions {
    apiVersion?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOutInSeconds?: number;
}

// @public
export interface DeleteTaskFileOptionalParams extends OperationOptions {
    apiVersion?: string;
    recursive?: boolean;
    timeOutInSeconds?: number;
}

// @public
export interface DeleteTaskOptionalParams extends OperationOptions {
    apiVersion?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOutInSeconds?: number;
}

// @public
export type DependencyAction = "satisfy" | "block";

// @public
export type DiffDiskPlacement = "cachedisk";

// @public
export interface DiffDiskSettings {
    placement?: DiffDiskPlacement;
}

// @public
export type DisableBatchNodeSchedulingOption = "requeue" | "terminate" | "taskcompletion";

// @public
export type DisableJobOption = "requeue" | "terminate" | "wait";

// @public
export interface DisableJobOptionalParams extends OperationOptions {
    apiVersion?: string;
    contentType?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOutInSeconds?: number;
}

// @public
export interface DisableJobScheduleOptionalParams extends OperationOptions {
    apiVersion?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOutInSeconds?: number;
}

// @public
export interface DisableNodeSchedulingOptionalParams extends OperationOptions {
    apiVersion?: string;
    body?: NodeDisableSchedulingOptions;
    contentType?: string;
    timeOutInSeconds?: number;
}

// @public
export interface DisablePoolAutoScaleOptionalParams extends OperationOptions {
    apiVersion?: string;
    timeOutInSeconds?: number;
}

// @public
export interface DiskEncryptionConfiguration {
    targets?: DiskEncryptionTarget[];
}

// @public
export type DiskEncryptionTarget = "osdisk" | "temporarydisk";

// @public
export type DynamicVNetAssignmentScope = "none" | "job";

// @public
export type ElevationLevel = "nonadmin" | "admin";

// @public
export interface EnableJobOptionalParams extends OperationOptions {
    apiVersion?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOutInSeconds?: number;
}

// @public
export interface EnableJobScheduleOptionalParams extends OperationOptions {
    apiVersion?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOutInSeconds?: number;
}

// @public
export interface EnableNodeSchedulingOptionalParams extends OperationOptions {
    apiVersion?: string;
    timeOutInSeconds?: number;
}

// @public
export interface EnablePoolAutoScaleOptionalParams extends OperationOptions {
    apiVersion?: string;
    contentType?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOutInSeconds?: number;
}

// @public
export interface EnvironmentSetting {
    name: string;
    value?: string;
}

// @public
export type ErrorCategory = "usererror" | "servererror";

// @public
export interface ErrorMessage {
    lang?: string;
    value?: string;
}

// @public
export interface EvaluatePoolAutoScaleOptionalParams extends OperationOptions {
    apiVersion?: string;
    contentType?: string;
    timeOutInSeconds?: number;
}

// @public
export interface ExitCodeMapping {
    code: number;
    exitOptions: ExitOptions;
}

// @public
export interface ExitCodeRangeMapping {
    end: number;
    exitOptions: ExitOptions;
    start: number;
}

// @public
export interface ExitConditions {
    default?: ExitOptions;
    exitCodeRanges?: ExitCodeRangeMapping[];
    exitCodes?: ExitCodeMapping[];
    fileUploadError?: ExitOptions;
    preProcessingError?: ExitOptions;
}

// @public
export interface ExitOptions {
    dependencyAction?: DependencyAction;
    jobAction?: JobAction;
}

// @public
export interface FileProperties {
    contentLength: number;
    contentType?: string;
    creationTime?: Date;
    fileMode?: string;
    lastModified: Date;
}

// @public
export interface GetApplicationOptionalParams extends OperationOptions {
    apiVersion?: string;
    timeOutInSeconds?: number;
}

// @public
export interface GetCertificateOptionalParams extends OperationOptions {
    apiVersion?: string;
    select?: string[];
    timeOutInSeconds?: number;
}

// @public
export interface GetJobOptionalParams extends OperationOptions {
    apiVersion?: string;
    expand?: string[];
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    select?: string[];
    timeOutInSeconds?: number;
}

// @public
export interface GetJobScheduleOptionalParams extends OperationOptions {
    apiVersion?: string;
    expand?: string[];
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    select?: string[];
    timeOutInSeconds?: number;
}

// @public
export interface GetJobTaskCountsOptionalParams extends OperationOptions {
    apiVersion?: string;
    timeOutInSeconds?: number;
}

// @public
export interface GetNodeExtensionOptionalParams extends OperationOptions {
    apiVersion?: string;
    select?: string[];
    timeOutInSeconds?: number;
}

// @public
export interface GetNodeFileOptionalParams extends OperationOptions {
    apiVersion?: string;
    ifModifiedSince?: Date;
    ifUnmodifiedSince?: Date;
    ocpRange?: string;
    timeOutInSeconds?: number;
}

// @public
export interface GetNodeFilePropertiesOptionalParams extends OperationOptions {
    apiVersion?: string;
    ifModifiedSince?: Date;
    ifUnmodifiedSince?: Date;
    timeOutInSeconds?: number;
}

// @public
export interface GetNodeOptionalParams extends OperationOptions {
    apiVersion?: string;
    select?: string[];
    timeOutInSeconds?: number;
}

// @public
export interface GetNodeRemoteDesktopFileOptionalParams extends OperationOptions {
    apiVersion?: string;
    timeOutInSeconds?: number;
}

// @public
export interface GetNodeRemoteLoginSettingsOptionalParams extends OperationOptions {
    apiVersion?: string;
    timeOutInSeconds?: number;
}

// @public
export interface GetPoolOptionalParams extends OperationOptions {
    apiVersion?: string;
    expand?: string[];
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    select?: string[];
    timeOutInSeconds?: number;
}

// @public
export interface GetTaskFileOptionalParams extends OperationOptions {
    apiVersion?: string;
    ifModifiedSince?: Date;
    ifUnmodifiedSince?: Date;
    ocpRange?: string;
    timeOutInSeconds?: number;
}

// @public
export interface GetTaskFilePropertiesOptionalParams extends OperationOptions {
    apiVersion?: string;
    ifModifiedSince?: Date;
    ifUnmodifiedSince?: Date;
    timeOutInSeconds?: number;
}

// @public
export interface GetTaskOptionalParams extends OperationOptions {
    apiVersion?: string;
    expand?: string[];
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    select?: string[];
    timeOutInSeconds?: number;
}

// @public
export interface HttpHeader {
    name: string;
    value?: string;
}

// @public
export interface ImageInformation {
    batchSupportEndOfLife?: Date;
    capabilities?: string[];
    imageReference: ImageReference;
    nodeAgentSkuId: string;
    osType: OSType;
    verificationType: VerificationType;
}

// @public
export interface ImageReference {
    readonly exactVersion?: string;
    offer?: string;
    publisher?: string;
    sku?: string;
    version?: string;
    virtualMachineImageId?: string;
}

// @public
export interface InboundEndpoint {
    backendPort: number;
    frontendPort: number;
    name: string;
    protocol: InboundEndpointProtocol;
    publicFQDN?: string;
    publicIpAddress?: string;
}

// @public
export type InboundEndpointProtocol = "tcp" | "udp";

// @public
export interface InboundNATPool {
    backendPort: number;
    frontendPortRangeEnd: number;
    frontendPortRangeStart: number;
    name: string;
    networkSecurityGroupRules?: NetworkSecurityGroupRule[];
    protocol: InboundEndpointProtocol;
}

// @public
export interface InstanceViewStatus {
    code?: string;
    displayStatus?: string;
    level?: StatusLevelTypes;
    message?: string;
    time?: string;
}

// @public
export type IpAddressProvisioningType = "batchmanaged" | "usermanaged" | "nopublicipaddresses";

// @public
export type JobAction = "none" | "disable" | "terminate";

// @public
export interface JobConstraints {
    maxTaskRetryCount?: number;
    maxWallClockTime?: string;
}

// @public
export interface JobExecutionInformation {
    endTime?: Date;
    poolId?: string;
    schedulingError?: JobSchedulingError;
    startTime: Date;
    terminateReason?: string;
}

// @public
export interface JobManagerTask {
    allowLowPriorityNode?: boolean;
    applicationPackageReferences?: ApplicationPackageReference[];
    authenticationTokenSettings?: AuthenticationTokenSettings;
    commandLine: string;
    constraints?: TaskConstraints;
    containerSettings?: TaskContainerSettings;
    displayName?: string;
    environmentSettings?: EnvironmentSetting[];
    id: string;
    killJobOnCompletion?: boolean;
    outputFiles?: OutputFile[];
    requiredSlots?: number;
    resourceFiles?: ResourceFile[];
    runExclusive?: boolean;
    userIdentity?: UserIdentity;
}

// @public
export interface JobNetworkConfiguration {
    subnetId: string;
}

// @public
export interface JobPreparationAndReleaseTaskExecutionInformation {
    jobPreparationTaskExecutionInfo?: JobPreparationTaskExecutionInformation;
    jobReleaseTaskExecutionInfo?: JobReleaseTaskExecutionInformation;
    nodeId?: string;
    nodeUrl?: string;
    poolId?: string;
}

// @public
export interface JobPreparationTask {
    commandLine: string;
    constraints?: TaskConstraints;
    containerSettings?: TaskContainerSettings;
    environmentSettings?: EnvironmentSetting[];
    id?: string;
    rerunOnNodeRebootAfterSuccess?: boolean;
    resourceFiles?: ResourceFile[];
    userIdentity?: UserIdentity;
    waitForSuccess?: boolean;
}

// @public
export interface JobPreparationTaskExecutionInformation {
    containerInfo?: TaskContainerExecutionInformation;
    endTime?: Date;
    exitCode?: number;
    failureInfo?: TaskFailureInformation;
    lastRetryTime?: Date;
    result?: TaskExecutionResult;
    retryCount: number;
    startTime: Date;
    state: JobPreparationTaskState;
    taskRootDirectory?: string;
    taskRootDirectoryUrl?: string;
}

// @public
export type JobPreparationTaskState = "running" | "completed";

// @public
export interface JobReleaseTask {
    commandLine: string;
    containerSettings?: TaskContainerSettings;
    environmentSettings?: EnvironmentSetting[];
    id?: string;
    maxWallClockTime?: string;
    resourceFiles?: ResourceFile[];
    retentionTime?: string;
    userIdentity?: UserIdentity;
}

// @public
export interface JobReleaseTaskExecutionInformation {
    containerInfo?: TaskContainerExecutionInformation;
    endTime?: Date;
    exitCode?: number;
    failureInfo?: TaskFailureInformation;
    result?: TaskExecutionResult;
    startTime: Date;
    state: JobReleaseTaskState;
    taskRootDirectory?: string;
    taskRootDirectoryUrl?: string;
}

// @public
export type JobReleaseTaskState = "running" | "completed";

// @public
export interface JobScheduleExecutionInformation {
    endTime?: Date;
    nextRunTime?: Date;
    recentJob?: RecentJob;
}

// @public
export interface JobScheduleExistsOptionalParams extends OperationOptions {
    apiVersion?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOutInSeconds?: number;
}

// @public
export type JobScheduleState = "active" | "completed" | "disabled" | "terminating" | "deleting";

// @public
export interface JobScheduleStatistics {
    kernelCPUTime: string;
    lastUpdateTime: Date;
    numFailedTasks: number;
    numSucceededTasks: number;
    numTaskRetries: number;
    readIOGiB: number;
    readIOps: number;
    startTime: Date;
    url: string;
    userCPUTime: string;
    waitTime: string;
    wallClockTime: string;
    writeIOGiB: number;
    writeIOps: number;
}

// @public
export interface JobSchedulingError {
    category: ErrorCategory;
    code?: string;
    details?: NameValuePair[];
    message?: string;
}

// @public
export interface JobSpecification {
    allowTaskPreemption?: boolean;
    commonEnvironmentSettings?: EnvironmentSetting[];
    constraints?: JobConstraints;
    displayName?: string;
    jobManagerTask?: JobManagerTask;
    jobPreparationTask?: JobPreparationTask;
    jobReleaseTask?: JobReleaseTask;
    maxParallelTasks?: number;
    metadata?: MetadataItem[];
    networkConfiguration?: JobNetworkConfiguration;
    onAllTasksComplete?: OnAllTasksComplete;
    onTaskFailure?: OnTaskFailure;
    poolInfo: PoolInformation;
    priority?: number;
    usesTaskDependencies?: boolean;
}

// @public
export type JobState = "active" | "disabling" | "disabled" | "enabling" | "terminating" | "completed" | "deleting";

// @public
export interface JobStatistics {
    kernelCPUTime: string;
    lastUpdateTime: Date;
    numFailedTasks: number;
    numSucceededTasks: number;
    numTaskRetries: number;
    readIOGiB: number;
    readIOps: number;
    startTime: Date;
    url: string;
    userCPUTime: string;
    waitTime: string;
    wallClockTime: string;
    writeIOGiB: number;
    writeIOps: number;
}

// @public
export interface LinuxUserConfiguration {
    gid?: number;
    sshPrivateKey?: string;
    uid?: number;
}

// @public
export interface ListApplicationsOptionalParams extends OperationOptions {
    apiVersion?: string;
    maxresults?: number;
    timeOutInSeconds?: number;
}

// @public
export interface ListCertificatesOptionalParams extends OperationOptions {
    apiVersion?: string;
    filter?: string;
    maxresults?: number;
    select?: string[];
    timeOutInSeconds?: number;
}

// @public
export interface ListJobPreparationAndReleaseTaskStatusOptionalParams extends OperationOptions {
    filter?: string;
    maxresults?: number;
    select?: string[];
    timeOutInSeconds?: number;
}

// @public
export interface ListJobSchedulesOptionalParams extends OperationOptions {
    apiVersion?: string;
    expand?: string[];
    filter?: string;
    maxresults?: number;
    select?: string[];
    timeOutInSeconds?: number;
}

// @public
export interface ListJobsFromScheduleOptionalParams extends OperationOptions {
    apiVersion?: string;
    expand?: string[];
    filter?: string;
    maxresults?: number;
    select?: string[];
    timeOutInSeconds?: number;
}

// @public
export interface ListJobsOptionalParams extends OperationOptions {
    apiVersion?: string;
    expand?: string[];
    filter?: string;
    maxresults?: number;
    select?: string[];
    timeOutInSeconds?: number;
}

// @public
export interface ListNodeExtensionsOptionalParams extends OperationOptions {
    maxresults?: number;
    select?: string[];
    timeOutInSeconds?: number;
}

// @public
export interface ListNodeFilesOptionalParams extends OperationOptions {
    apiVersion?: string;
    filter?: string;
    maxresults?: number;
    recursive?: boolean;
    timeOutInSeconds?: number;
}

// @public
export interface ListNodesOptionalParams extends OperationOptions {
    apiVersion?: string;
    filter?: string;
    maxresults?: number;
    select?: string[];
    timeOutInSeconds?: number;
}

// @public
export interface ListPoolNodeCountsOptionalParams extends OperationOptions {
    apiVersion?: string;
    filter?: string;
    maxresults?: number;
    timeOutInSeconds?: number;
}

// @public
export interface ListPoolsOptionalParams extends OperationOptions {
    apiVersion?: string;
    expand?: string[];
    filter?: string;
    maxresults?: number;
    select?: string[];
    timeOutInSeconds?: number;
}

// @public
export interface ListPoolUsageMetricsOptionalParams extends OperationOptions {
    apiVersion?: string;
    endtime?: Date;
    filter?: string;
    maxresults?: number;
    starttime?: Date;
    timeOutInSeconds?: number;
}

// @public
export interface ListSubTasksOptionalParams extends OperationOptions {
    apiVersion?: string;
    select?: string[];
    timeOutInSeconds?: number;
}

// @public
export interface ListSupportedImagesOptionalParams extends OperationOptions {
    filter?: string;
    maxresults?: number;
    timeOutInSeconds?: number;
}

// @public
export interface ListTaskFilesOptionalParams extends OperationOptions {
    apiVersion?: string;
    filter?: string;
    maxresults?: number;
    recursive?: boolean;
    timeOutInSeconds?: number;
}

// @public
export interface ListTasksOptionalParams extends OperationOptions {
    apiVersion?: string;
    expand?: string[];
    filter?: string;
    maxresults?: number;
    select?: string[];
    timeOutInSeconds?: number;
}

// @public
export type LoginMode = "batch" | "interactive";

// @public
export interface MetadataItem {
    name: string;
    value: string;
}

// @public
export interface MountConfiguration {
    azureBlobFileSystemConfiguration?: AzureBlobFileSystemConfiguration;
    azureFileShareConfiguration?: AzureFileShareConfiguration;
    cifsMountConfiguration?: CifsMountConfiguration;
    nfsMountConfiguration?: NfsMountConfiguration;
}

// @public
export interface MultiInstanceSettings {
    commonResourceFiles?: ResourceFile[];
    coordinationCommandLine: string;
    numberOfInstances?: number;
}

// @public
export interface NameValuePair {
    name?: string;
    value?: string;
}

// @public
export interface NetworkConfiguration {
    dynamicVNetAssignmentScope?: DynamicVNetAssignmentScope;
    enableAcceleratedNetworking?: boolean;
    endpointConfiguration?: PoolEndpointConfiguration;
    publicIpAddressConfiguration?: PublicIpAddressConfiguration;
    subnetId?: string;
}

// @public
export interface NetworkSecurityGroupRule {
    access: NetworkSecurityGroupRuleAccess;
    priority: number;
    sourceAddressPrefix: string;
    sourcePortRanges?: string[];
}

// @public
export type NetworkSecurityGroupRuleAccess = "allow" | "deny";

// @public
export interface NfsMountConfiguration {
    mountOptions?: string;
    relativeMountPath: string;
    source: string;
}

// @public
export interface NodeAgentInformation {
    lastUpdateTime: Date;
    version: string;
}

// @public
export type NodeCommunicationMode = "default" | "classic" | "simplified";

// @public
export interface NodeCounts {
    creating: number;
    idle: number;
    leavingPool: number;
    offline: number;
    preempted: number;
    rebooting: number;
    reimaging: number;
    running: number;
    starting: number;
    startTaskFailed: number;
    total: number;
    unknown: number;
    unusable: number;
    waitingForStartTask: number;
}

// @public
export interface NodeDisableSchedulingOptions {
    nodeDisableSchedulingOption?: DisableBatchNodeSchedulingOption;
}

// @public
export interface NodeFile {
    isDirectory?: boolean;
    name?: string;
    properties?: FileProperties;
    url?: string;
}

// @public
export interface NodePlacementConfiguration {
    policy?: NodePlacementPolicyType;
}

// @public
export type NodePlacementPolicyType = "regional" | "zonal";

// @public
export interface NodeRebootOptions {
    nodeRebootOption?: BatchNodeRebootOption;
}

// @public
export interface NodeReimageOptions {
    nodeReimageOption?: BatchNodeReimageOption;
}

// @public
export interface NodeRemoveOptions {
    nodeDeallocationOption?: BatchNodeDeallocationOption;
    nodeList: string[];
    resizeTimeout?: string;
}

// @public
export interface NodeVMExtension {
    instanceView?: VMExtensionInstanceView;
    provisioningState?: string;
    vmExtension?: VMExtension;
}

// @public
export type OnAllTasksComplete = "noaction" | "terminatejob";

// @public
export type OnTaskFailure = "noaction" | "performexitoptionsjobaction";

// @public
export interface OSDisk {
    ephemeralOSDiskSettings?: DiffDiskSettings;
}

// @public
export type OSType = "linux" | "windows";

// @public
export interface OutputFile {
    destination: OutputFileDestination;
    filePattern: string;
    uploadOptions: OutputFileUploadOptions;
}

// @public
export interface OutputFileBlobContainerDestination {
    containerUrl: string;
    identityReference?: BatchNodeIdentityReference;
    path?: string;
    uploadHeaders?: HttpHeader[];
}

// @public
export interface OutputFileDestination {
    container?: OutputFileBlobContainerDestination;
}

// @public
export type OutputFileUploadCondition = "tasksuccess" | "taskfailure" | "taskcompletion";

// @public
export interface OutputFileUploadOptions {
    uploadCondition: OutputFileUploadCondition;
}

// @public
export interface PagedAsyncIterableIterator<TElement, TPage = TElement[], TPageSettings extends PageSettings = PageSettings> {
    [Symbol.asyncIterator](): PagedAsyncIterableIterator<TElement, TPage, TPageSettings>;
    byPage: (settings?: TPageSettings) => AsyncIterableIterator<ContinuablePage<TElement, TPage>>;
    next(): Promise<IteratorResult<TElement>>;
}

// @public
export interface PageSettings {
    continuationToken?: string;
}

// @public
export interface PoolEndpointConfiguration {
    inboundNatPools: InboundNATPool[];
}

// @public
export interface PoolExistsOptionalParams extends OperationOptions {
    apiVersion?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOutInSeconds?: number;
}

// @public
export type PoolIdentityType = "UserAssigned" | "None";

// @public
export interface PoolInformation {
    autoPoolSpecification?: AutoPoolSpecification;
    poolId?: string;
}

// @public
export type PoolLifetimeOption = "jobschedule" | "job";

// @public
export interface PoolNodeCounts {
    dedicated?: NodeCounts;
    lowPriority?: NodeCounts;
    poolId: string;
}

// @public
export interface PoolSpecification {
    applicationLicenses?: string[];
    applicationPackageReferences?: ApplicationPackageReference[];
    autoScaleEvaluationInterval?: string;
    autoScaleFormula?: string;
    certificateReferences?: CertificateReference[];
    cloudServiceConfiguration?: CloudServiceConfiguration;
    displayName?: string;
    enableAutoScale?: boolean;
    enableInterNodeCommunication?: boolean;
    metadata?: MetadataItem[];
    mountConfiguration?: MountConfiguration[];
    networkConfiguration?: NetworkConfiguration;
    resizeTimeout?: string;
    startTask?: StartTask;
    targetDedicatedNodes?: number;
    targetLowPriorityNodes?: number;
    targetNodeCommunicationMode?: NodeCommunicationMode;
    taskSchedulingPolicy?: TaskSchedulingPolicy;
    taskSlotsPerNode?: number;
    userAccounts?: UserAccount[];
    virtualMachineConfiguration?: VirtualMachineConfiguration;
    vmSize: string;
}

// @public
export type PoolState = "active" | "deleting";

// @public
export interface PoolStatistics {
    lastUpdateTime: Date;
    resourceStats?: ResourceStatistics;
    startTime: Date;
    url: string;
    usageStats?: UsageStatistics;
}

// @public
export interface PoolUsageMetrics {
    endTime: Date;
    poolId: string;
    startTime: Date;
    totalCoreHours: number;
    vmSize: string;
}

// @public
export interface PublicIpAddressConfiguration {
    ipAddressIds?: string[];
    ipAddressProvisioningType?: IpAddressProvisioningType;
}

// @public
export interface ReactivateTaskOptionalParams extends OperationOptions {
    apiVersion?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOutInSeconds?: number;
}

// @public
export interface RebootNodeOptionalParams extends OperationOptions {
    apiVersion?: string;
    body?: NodeRebootOptions;
    contentType?: string;
    timeOutInSeconds?: number;
}

// @public
export interface RecentJob {
    id?: string;
    url?: string;
}

// @public
export interface ReimageNodeOptionalParams extends OperationOptions {
    apiVersion?: string;
    body?: NodeReimageOptions;
    contentType?: string;
    timeOutInSeconds?: number;
}

// @public
export interface RemoveNodesOptionalParams extends OperationOptions {
    apiVersion?: string;
    contentType?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOutInSeconds?: number;
}

// @public
export interface ReplaceJobOptionalParams extends OperationOptions {
    apiVersion?: string;
    contentType?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOutInSeconds?: number;
}

// @public
export interface ReplaceJobScheduleOptionalParams extends OperationOptions {
    apiVersion?: string;
    contentType?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOutInSeconds?: number;
}

// @public
export interface ReplaceNodeUserOptionalParams extends OperationOptions {
    apiVersion?: string;
    contentType?: string;
    timeOutInSeconds?: number;
}

// @public
export interface ReplacePoolPropertiesOptionalParams extends OperationOptions {
    apiVersion?: string;
    contentType?: string;
    timeOutInSeconds?: number;
}

// @public
export interface ReplaceTaskOptionalParams extends OperationOptions {
    apiVersion?: string;
    contentType?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOutInSeconds?: number;
}

// @public
export interface ResizeError {
    code?: string;
    message?: string;
    values?: NameValuePair[];
}

// @public
export interface ResizePoolOptionalParams extends OperationOptions {
    apiVersion?: string;
    contentType?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOutInSeconds?: number;
}

// @public
export interface ResourceFile {
    autoStorageContainerName?: string;
    blobPrefix?: string;
    fileMode?: string;
    filePath?: string;
    httpUrl?: string;
    identityReference?: BatchNodeIdentityReference;
    storageContainerUrl?: string;
}

// @public
export interface ResourceStatistics {
    avgCpuPercentage: number;
    avgDiskGiB: number;
    avgMemoryGiB: number;
    diskReadGiB: number;
    diskReadIOps: number;
    diskWriteGiB: number;
    diskWriteIOps: number;
    lastUpdateTime: Date;
    networkReadGiB: number;
    networkWriteGiB: number;
    peakDiskGiB: number;
    peakMemoryGiB: number;
    startTime: Date;
}

// @public
export interface Schedule {
    doNotRunAfter?: Date;
    doNotRunUntil?: Date;
    recurrenceInterval?: string;
    startWindow?: string;
}

// @public
export type SchedulingState = "enabled" | "disabled";

// @public
export interface StartTask {
    commandLine: string;
    containerSettings?: TaskContainerSettings;
    environmentSettings?: EnvironmentSetting[];
    maxTaskRetryCount?: number;
    resourceFiles?: ResourceFile[];
    userIdentity?: UserIdentity;
    waitForSuccess?: boolean;
}

// @public
export interface StartTaskInformation {
    containerInfo?: TaskContainerExecutionInformation;
    endTime?: Date;
    exitCode?: number;
    failureInfo?: TaskFailureInformation;
    lastRetryTime?: Date;
    result?: TaskExecutionResult;
    retryCount: number;
    startTime: Date;
    state: StartTaskState;
}

// @public
export type StartTaskState = "running" | "completed";

// @public
export type StatusLevelTypes = "Error" | "Info" | "Warning";

// @public
export interface StopPoolResizeOptionalParams extends OperationOptions {
    apiVersion?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOutInSeconds?: number;
}

// @public
export type StorageAccountType = "standard_lrs" | "premium_lrs";

// @public
export interface SubtaskInformation {
    containerInfo?: TaskContainerExecutionInformation;
    endTime?: Date;
    exitCode?: number;
    failureInfo?: TaskFailureInformation;
    id?: number;
    nodeInfo?: BatchNodeInformation;
    previousState?: SubtaskState;
    previousStateTransitionTime?: Date;
    result?: TaskExecutionResult;
    startTime?: Date;
    state?: SubtaskState;
    stateTransitionTime?: Date;
}

// @public
export type SubtaskState = "preparing" | "running" | "completed";

// @public
export interface TaskAddCollectionResult {
    value?: TaskAddResult[];
}

// @public
export interface TaskAddResult {
    error?: BatchError;
    eTag?: string;
    lastModified?: Date;
    location?: string;
    status: TaskAddStatus;
    taskId: string;
}

// @public
export type TaskAddStatus = "Success" | "clienterror" | "servererror";

// @public
export interface TaskConstraints {
    maxTaskRetryCount?: number;
    maxWallClockTime?: string;
    retentionTime?: string;
}

// @public
export interface TaskContainerExecutionInformation {
    containerId?: string;
    error?: string;
    state?: string;
}

// @public
export interface TaskContainerSettings {
    containerRunOptions?: string;
    imageName: string;
    registry?: ContainerRegistry;
    workingDirectory?: ContainerWorkingDirectory;
}

// @public
export interface TaskCounts {
    active: number;
    completed: number;
    failed: number;
    running: number;
    succeeded: number;
}

// @public
export interface TaskCountsResult {
    taskCounts: TaskCounts;
    taskSlotCounts: TaskSlotCounts;
}

// @public
export interface TaskDependencies {
    taskIdRanges?: TaskIdRange[];
    taskIds?: string[];
}

// @public
export interface TaskExecutionInformation {
    containerInfo?: TaskContainerExecutionInformation;
    endTime?: Date;
    exitCode?: number;
    failureInfo?: TaskFailureInformation;
    lastRequeueTime?: Date;
    lastRetryTime?: Date;
    requeueCount: number;
    result?: TaskExecutionResult;
    retryCount: number;
    startTime?: Date;
}

// @public
export type TaskExecutionResult = "success" | "failure";

// @public
export interface TaskFailureInformation {
    category: ErrorCategory;
    code?: string;
    details?: NameValuePair[];
    message?: string;
}

// @public
export interface TaskIdRange {
    end: number;
    start: number;
}

// @public
export interface TaskInformation {
    executionInfo?: TaskExecutionInformation;
    jobId?: string;
    subtaskId?: number;
    taskId?: string;
    taskState: TaskState;
    taskUrl?: string;
}

// @public
export interface TaskSchedulingPolicy {
    nodeFillType: BatchNodeFillType;
}

// @public
export interface TaskSlotCounts {
    active: number;
    completed: number;
    failed: number;
    running: number;
    succeeded: number;
}

// @public
export type TaskState = "active" | "preparing" | "running" | "completed";

// @public
export interface TaskStatistics {
    kernelCPUTime: string;
    lastUpdateTime: Date;
    readIOGiB: number;
    readIOps: number;
    startTime: Date;
    url: string;
    userCPUTime: string;
    waitTime: string;
    wallClockTime: string;
    writeIOGiB: number;
    writeIOps: number;
}

// @public
export interface TerminateJobOptionalParams extends OperationOptions {
    apiVersion?: string;
    body?: BatchJobTerminateOptions;
    contentType?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOutInSeconds?: number;
}

// @public
export interface TerminateJobScheduleOptionalParams extends OperationOptions {
    apiVersion?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOutInSeconds?: number;
}

// @public
export interface TerminateTaskOptionalParams extends OperationOptions {
    apiVersion?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOutInSeconds?: number;
}

// @public
export interface UpdateJobOptionalParams extends OperationOptions {
    apiVersion?: string;
    contentType?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOutInSeconds?: number;
}

// @public
export interface UpdateJobScheduleOptionalParams extends OperationOptions {
    apiVersion?: string;
    contentType?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOutInSeconds?: number;
}

// @public
export interface UpdatePoolOptionalParams extends OperationOptions {
    apiVersion?: string;
    contentType?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOutInSeconds?: number;
}

// @public
export interface UploadBatchServiceLogsOptions {
    containerUrl: string;
    endTime?: Date;
    identityReference?: BatchNodeIdentityReference;
    startTime: Date;
}

// @public
export interface UploadBatchServiceLogsResult {
    numberOfFilesUploaded: number;
    virtualDirectoryName: string;
}

// @public
export interface UploadNodeLogsOptionalParams extends OperationOptions {
    apiVersion?: string;
    contentType?: string;
    timeOutInSeconds?: number;
}

// @public
export interface UsageStatistics {
    dedicatedCoreTime: string;
    lastUpdateTime: Date;
    startTime: Date;
}

// @public
export interface UserAccount {
    elevationLevel?: ElevationLevel;
    linuxUserConfiguration?: LinuxUserConfiguration;
    name: string;
    password: string;
    windowsUserConfiguration?: WindowsUserConfiguration;
}

// @public
export interface UserAssignedIdentity {
    readonly clientId?: string;
    readonly principalId?: string;
    resourceId: string;
}

// @public
export interface UserIdentity {
    autoUser?: AutoUserSpecification;
    username?: string;
}

// @public
export type VerificationType = "verified" | "unverified";

// @public
export interface VirtualMachineConfiguration {
    containerConfiguration?: ContainerConfiguration;
    dataDisks?: DataDisk[];
    diskEncryptionConfiguration?: DiskEncryptionConfiguration;
    extensions?: VMExtension[];
    imageReference: ImageReference;
    licenseType?: string;
    nodeAgentSkuId: string;
    nodePlacementConfiguration?: NodePlacementConfiguration;
    osDisk?: OSDisk;
    windowsConfiguration?: WindowsConfiguration;
}

// @public
export interface VirtualMachineInfo {
    imageReference?: ImageReference;
}

// @public
export interface VMExtension {
    autoUpgradeMinorVersion?: boolean;
    enableAutomaticUpgrade?: boolean;
    name: string;
    protectedSettings?: Record<string, string>;
    provisionAfterExtensions?: string[];
    publisher: string;
    settings?: Record<string, string>;
    type: string;
    typeHandlerVersion?: string;
}

// @public
export interface VMExtensionInstanceView {
    name?: string;
    statuses?: InstanceViewStatus[];
    subStatuses?: InstanceViewStatus[];
}

// @public
export interface WindowsConfiguration {
    enableAutomaticUpdates?: boolean;
}

// @public
export interface WindowsUserConfiguration {
    loginMode?: LoginMode;
}

// (No @packageDocumentation comment for this package)

```
