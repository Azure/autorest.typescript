## API Report File for "@azure-rest/batch"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ClientOptions } from '@azure-rest/core-client';
import { OperationOptions } from '@azure-rest/core-client';
import { Pipeline } from '@azure/core-rest-pipeline';
import { TokenCredential } from '@azure/core-auth';

// @public
export type AccessScope = string;

// @public
export interface AccountListSupportedImagesResult {
    "odata.nextLink"?: string;
    value?: ImageInformation[];
}

// @public (undocumented)
export interface AccountsListPoolNodeCountsOptions extends OperationOptions {
    $filter?: string;
    maxresults?: number;
    timeOut?: number;
}

// @public (undocumented)
export interface AccountsListSupportedImagesOptions extends OperationOptions {
    $filter?: string;
    maxresults?: number;
    timeOut?: number;
}

// @public (undocumented)
export interface AccountsOperations {
    // (undocumented)
    listPoolNodeCounts: (options?: AccountsListPoolNodeCountsOptions) => PagedAsyncIterableIterator<PoolNodeCounts>;
    // (undocumented)
    listSupportedImages: (options?: AccountsListSupportedImagesOptions) => PagedAsyncIterableIterator<ImageInformation>;
}

// @public
export interface AffinityInformation {
    affinityId: string;
}

// @public
export type AllocationState = string;

// @public
export interface ApplicationListResult {
    "odata.nextLink"?: string;
    value?: BatchApplication[];
}

// @public
export interface ApplicationPackageReference {
    applicationId: string;
    version?: string;
}

// @public (undocumented)
export interface ApplicationsGetApplicationOptions extends OperationOptions {
    timeOut?: number;
}

// @public (undocumented)
export interface ApplicationsListApplicationsOptions extends OperationOptions {
    maxresults?: number;
    timeOut?: number;
}

// @public (undocumented)
export interface ApplicationsOperations {
    // (undocumented)
    getApplication: (applicationId: string, options?: ApplicationsGetApplicationOptions) => Promise<BatchApplication>;
    // (undocumented)
    listApplications: (options?: ApplicationsListApplicationsOptions) => PagedAsyncIterableIterator<BatchApplication>;
}

// @public
export interface AuthenticationTokenSettings {
    access?: AccessScope[];
}

// @public
export interface AutoPoolSpecification {
    autoPoolIdPrefix?: string;
    keepAlive?: boolean;
    pool?: PoolSpecification;
    poolLifetimeOption: PoolLifetimeOption;
}

// @public
export interface AutoScaleRun {
    error?: AutoScaleRunError;
    results?: string;
    timestamp: Date;
}

// @public
export interface AutoScaleRunError {
    code?: string;
    message?: string;
    values?: NameValuePair[];
}

// @public
export type AutoUserScope = string;

// @public
export interface AutoUserSpecification {
    elevationLevel?: ElevationLevel;
    scope?: AutoUserScope;
}

// @public
export interface AzureBlobFileSystemConfiguration {
    accountKey?: string;
    accountName: string;
    blobfuseOptions?: string;
    containerName: string;
    identityReference?: BatchNodeIdentityReference;
    relativeMountPath: string;
    sasKey?: string;
}

// @public
export interface AzureFileShareConfiguration {
    accountKey: string;
    accountName: string;
    azureFileUrl: string;
    mountOptions?: string;
    relativeMountPath: string;
}

// @public
export interface BatchApplication {
    displayName: string;
    id: string;
    versions: string[];
}

// @public
export interface BatchCertificate {
    certificateFormat?: CertificateFormat;
    data: Uint8Array;
    readonly deleteCertificateError?: DeleteCertificateError;
    password?: string;
    readonly previousState?: CertificateState;
    readonly previousStateTransitionTime?: Date;
    readonly publicData?: Uint8Array;
    readonly state?: CertificateState;
    readonly stateTransitionTime?: Date;
    thumbprint: string;
    thumbprintAlgorithm: string;
    readonly url?: string;
}

// @public (undocumented)
export class BatchClient {
    constructor(endpoint: string, credential: TokenCredential, options?: BatchClientOptions);
    readonly accounts: AccountsOperations;
    readonly applications: ApplicationsOperations;
    readonly certificates: CertificatesOperations;
    readonly jobs: JobsOperations;
    readonly jobSchedules: JobSchedulesOperations;
    readonly nodes: NodesOperations;
    readonly pipeline: Pipeline;
    readonly pools: PoolsOperations;
    readonly tasks: TasksOperations;
}

// @public (undocumented)
export interface BatchClientOptions extends ClientOptions {
}

// @public
export interface BatchError {
    code: string;
    message?: ErrorMessage;
    values?: BatchErrorDetail[];
}

// @public
export interface BatchErrorDetail {
    key?: string;
    value?: string;
}

// @public
export interface BatchJob {
    allowTaskPreemption?: boolean;
    readonly commonEnvironmentSettings?: EnvironmentSetting[];
    constraints?: JobConstraints;
    readonly creationTime?: Date;
    readonly displayName?: string;
    readonly eTag?: string;
    readonly executionInfo?: JobExecutionInformation;
    readonly id?: string;
    readonly jobManagerTask?: JobManagerTask;
    readonly jobPreparationTask?: JobPreparationTask;
    readonly jobReleaseTask?: JobReleaseTask;
    readonly lastModified?: Date;
    maxParallelTasks?: number;
    metadata?: MetadataItem[];
    readonly networkConfiguration?: JobNetworkConfiguration;
    onAllTasksComplete?: OnAllTasksComplete;
    readonly onTaskFailure?: OnTaskFailure;
    poolInfo: PoolInformation;
    readonly previousState?: JobState;
    readonly previousStateTransitionTime?: Date;
    priority?: number;
    readonly state?: JobState;
    readonly stateTransitionTime?: Date;
    readonly stats?: JobStatistics;
    readonly url?: string;
    readonly usesTaskDependencies?: boolean;
}

// @public
export interface BatchJobCreateOptions {
    allowTaskPreemption?: boolean;
    commonEnvironmentSettings?: EnvironmentSetting[];
    constraints?: JobConstraints;
    displayName?: string;
    id: string;
    jobManagerTask?: JobManagerTask;
    jobPreparationTask?: JobPreparationTask;
    jobReleaseTask?: JobReleaseTask;
    maxParallelTasks?: number;
    metadata?: MetadataItem[];
    networkConfiguration?: JobNetworkConfiguration;
    onAllTasksComplete?: OnAllTasksComplete;
    onTaskFailure?: OnTaskFailure;
    poolInfo: PoolInformation;
    priority?: number;
    usesTaskDependencies?: boolean;
}

// @public
export interface BatchJobDisableOptions {
    disableTasks: DisableJobOption;
}

// @public
export interface BatchJobListPreparationAndReleaseTaskStatusResult {
    "odata.nextLink"?: string;
    value?: JobPreparationAndReleaseTaskExecutionInformation[];
}

// @public
export interface BatchJobListResult {
    "odata.nextLink"?: string;
    value?: BatchJob[];
}

// @public
export interface BatchJobSchedule {
    readonly creationTime?: Date;
    readonly displayName?: string;
    readonly eTag?: string;
    readonly executionInfo?: JobScheduleExecutionInformation;
    readonly id?: string;
    jobSpecification: JobSpecification;
    readonly lastModified?: Date;
    metadata?: MetadataItem[];
    readonly previousState?: JobScheduleState;
    readonly previousStateTransitionTime?: Date;
    schedule: Schedule;
    readonly state?: JobScheduleState;
    readonly stateTransitionTime?: Date;
    readonly stats?: JobScheduleStatistics;
    readonly url?: string;
}

// @public
export interface BatchJobScheduleCreateOptions {
    displayName?: string;
    id: string;
    jobSpecification: JobSpecification;
    metadata?: MetadataItem[];
    schedule: Schedule;
}

// @public
export interface BatchJobScheduleListResult {
    "odata.nextLink"?: string;
    value?: BatchJobSchedule[];
}

// @public
export interface BatchJobScheduleUpdateOptions {
    jobSpecification?: JobSpecification;
    metadata?: MetadataItem[];
    schedule?: Schedule;
}

// @public
export interface BatchJobTerminateOptions {
    terminateReason?: string;
}

// @public
export interface BatchJobUpdateOptions {
    allowTaskPreemption?: boolean;
    constraints?: JobConstraints;
    maxParallelTasks?: number;
    metadata?: MetadataItem[];
    onAllTasksComplete?: OnAllTasksComplete;
    poolInfo?: PoolInformation;
    priority?: number;
}

// @public
export interface BatchNode {
    affinityId?: string;
    allocationTime?: Date;
    certificateReferences?: CertificateReference[];
    endpointConfiguration?: BatchNodeEndpointConfiguration;
    errors?: BatchNodeError[];
    id?: string;
    ipAddress?: string;
    isDedicated?: boolean;
    lastBootTime?: Date;
    nodeAgentInfo?: NodeAgentInformation;
    recentTasks?: TaskInformation[];
    runningTasksCount?: number;
    runningTaskSlotsCount?: number;
    schedulingState?: SchedulingState;
    startTask?: StartTask;
    startTaskInfo?: StartTaskInformation;
    state?: BatchNodeState;
    stateTransitionTime?: Date;
    totalTasksRun?: number;
    totalTasksSucceeded?: number;
    url?: string;
    virtualMachineInfo?: VirtualMachineInfo;
    vmSize?: string;
}

// @public
export type BatchNodeDeallocationOption = string;

// @public
export interface BatchNodeEndpointConfiguration {
    inboundEndpoints: InboundEndpoint[];
}

// @public
export interface BatchNodeError {
    code?: string;
    errorDetails?: NameValuePair[];
    message?: string;
}

// @public
export type BatchNodeFillType = string;

// @public
export interface BatchNodeIdentityReference {
    resourceId?: string;
}

// @public
export interface BatchNodeInformation {
    affinityId?: string;
    nodeId?: string;
    nodeUrl?: string;
    poolId?: string;
    taskRootDirectory?: string;
    taskRootDirectoryUrl?: string;
}

// @public
export interface BatchNodeListResult {
    "odata.nextLink"?: string;
    value?: BatchNode[];
}

// @public
export type BatchNodeRebootOption = string;

// @public
export type BatchNodeReimageOption = string;

// @public
export interface BatchNodeRemoteLoginSettingsResult {
    remoteLoginIPAddress: string;
    remoteLoginPort: number;
}

// @public
export type BatchNodeState = string;

// @public
export interface BatchNodeUserCreateOptions {
    expiryTime?: Date;
    isAdmin?: boolean;
    name: string;
    password?: string;
    sshPublicKey?: string;
}

// @public
export interface BatchNodeUserUpdateOptions {
    expiryTime?: Date;
    password?: string;
    sshPublicKey?: string;
}

// @public
export interface BatchPool {
    readonly allocationState?: AllocationState;
    readonly allocationStateTransitionTime?: Date;
    readonly applicationLicenses?: string[];
    readonly applicationPackageReferences?: ApplicationPackageReference[];
    readonly autoScaleEvaluationInterval?: string;
    readonly autoScaleFormula?: string;
    readonly autoScaleRun?: AutoScaleRun;
    readonly certificateReferences?: CertificateReference[];
    readonly cloudServiceConfiguration?: CloudServiceConfiguration;
    readonly creationTime?: Date;
    readonly currentDedicatedNodes?: number;
    readonly currentLowPriorityNodes?: number;
    readonly currentNodeCommunicationMode?: NodeCommunicationMode;
    readonly displayName?: string;
    readonly enableAutoScale?: boolean;
    readonly enableInterNodeCommunication?: boolean;
    readonly eTag?: string;
    readonly id?: string;
    readonly identity?: BatchPoolIdentity;
    readonly lastModified?: Date;
    readonly metadata?: MetadataItem[];
    readonly mountConfiguration?: MountConfiguration[];
    readonly networkConfiguration?: NetworkConfiguration;
    readonly resizeErrors?: ResizeError[];
    readonly resizeTimeout?: string;
    startTask?: StartTask;
    readonly state?: PoolState;
    readonly stateTransitionTime?: Date;
    readonly stats?: PoolStatistics;
    readonly targetDedicatedNodes?: number;
    readonly targetLowPriorityNodes?: number;
    targetNodeCommunicationMode?: NodeCommunicationMode;
    readonly taskSchedulingPolicy?: TaskSchedulingPolicy;
    readonly taskSlotsPerNode?: number;
    readonly url?: string;
    readonly userAccounts?: UserAccount[];
    readonly virtualMachineConfiguration?: VirtualMachineConfiguration;
    readonly vmSize?: string;
}

// @public
export interface BatchPoolCreateOptions {
    applicationLicenses?: string[];
    applicationPackageReferences?: ApplicationPackageReference[];
    autoScaleEvaluationInterval?: string;
    autoScaleFormula?: string;
    certificateReferences?: CertificateReference[];
    cloudServiceConfiguration?: CloudServiceConfiguration;
    displayName?: string;
    enableAutoScale?: boolean;
    enableInterNodeCommunication?: boolean;
    id: string;
    metadata?: MetadataItem[];
    mountConfiguration?: MountConfiguration[];
    networkConfiguration?: NetworkConfiguration;
    resizeTimeout?: string;
    startTask?: StartTask;
    targetDedicatedNodes?: number;
    targetLowPriorityNodes?: number;
    targetNodeCommunicationMode?: NodeCommunicationMode;
    taskSchedulingPolicy?: TaskSchedulingPolicy;
    taskSlotsPerNode?: number;
    userAccounts?: UserAccount[];
    virtualMachineConfiguration?: VirtualMachineConfiguration;
    vmSize: string;
}

// @public
export interface BatchPoolEnableAutoScaleOptions {
    autoScaleEvaluationInterval?: string;
    autoScaleFormula?: string;
}

// @public
export interface BatchPoolEvaluateAutoScaleOptions {
    autoScaleFormula: string;
}

// @public
export interface BatchPoolIdentity {
    type: PoolIdentityType;
    userAssignedIdentities?: UserAssignedIdentity[];
}

// @public
export interface BatchPoolListResult {
    "odata.nextLink"?: string;
    value?: BatchPool[];
}

// @public
export interface BatchPoolReplaceOptions {
    applicationPackageReferences: ApplicationPackageReference[];
    certificateReferences: CertificateReference[];
    metadata: MetadataItem[];
    startTask?: StartTask;
    targetNodeCommunicationMode?: NodeCommunicationMode;
}

// @public
export interface BatchPoolResizeOptions {
    nodeDeallocationOption?: BatchNodeDeallocationOption;
    resizeTimeout?: string;
    targetDedicatedNodes?: number;
    targetLowPriorityNodes?: number;
}

// @public
export interface BatchPoolUpdateOptions {
    applicationPackageReferences?: ApplicationPackageReference[];
    certificateReferences?: CertificateReference[];
    metadata?: MetadataItem[];
    startTask?: StartTask;
    targetNodeCommunicationMode?: NodeCommunicationMode;
}

// @public
export interface BatchTask {
    readonly affinityInfo?: AffinityInformation;
    readonly applicationPackageReferences?: ApplicationPackageReference[];
    readonly authenticationTokenSettings?: AuthenticationTokenSettings;
    readonly commandLine?: string;
    constraints?: TaskConstraints;
    readonly containerSettings?: TaskContainerSettings;
    readonly creationTime?: Date;
    readonly dependsOn?: TaskDependencies;
    readonly displayName?: string;
    readonly environmentSettings?: EnvironmentSetting[];
    readonly eTag?: string;
    readonly executionInfo?: TaskExecutionInformation;
    readonly exitConditions?: ExitConditions;
    readonly id?: string;
    readonly lastModified?: Date;
    readonly multiInstanceSettings?: MultiInstanceSettings;
    readonly nodeInfo?: BatchNodeInformation;
    readonly outputFiles?: OutputFile[];
    readonly previousState?: TaskState;
    readonly previousStateTransitionTime?: Date;
    readonly requiredSlots?: number;
    readonly resourceFiles?: ResourceFile[];
    readonly state?: TaskState;
    readonly stateTransitionTime?: Date;
    readonly stats?: TaskStatistics;
    readonly url?: string;
    readonly userIdentity?: UserIdentity;
}

// @public
export interface BatchTaskCollection {
    value: BatchTaskCreateOptions[];
}

// @public
export interface BatchTaskCreateOptions {
    affinityInfo?: AffinityInformation;
    applicationPackageReferences?: ApplicationPackageReference[];
    authenticationTokenSettings?: AuthenticationTokenSettings;
    commandLine: string;
    constraints?: TaskConstraints;
    containerSettings?: TaskContainerSettings;
    dependsOn?: TaskDependencies;
    displayName?: string;
    environmentSettings?: EnvironmentSetting[];
    exitConditions?: ExitConditions;
    id: string;
    multiInstanceSettings?: MultiInstanceSettings;
    outputFiles?: OutputFile[];
    requiredSlots?: number;
    resourceFiles?: ResourceFile[];
    userIdentity?: UserIdentity;
}

// @public
export interface BatchTaskListResult {
    "odata.nextLink"?: string;
    value?: BatchTask[];
}

// @public
export interface BatchTaskListSubtasksResult {
    value?: SubtaskInformation[];
}

// @public
export type CachingType = string;

// @public
export type CertificateFormat = string;

// @public
export interface CertificateListResult {
    "odata.nextLink"?: string;
    value?: BatchCertificate[];
}

// @public
export interface CertificateReference {
    storeLocation?: CertificateStoreLocation;
    storeName?: string;
    thumbprint: string;
    thumbprintAlgorithm: string;
    visibility?: CertificateVisibility[];
}

// @public (undocumented)
export interface CertificatesCancelCertificateDeletionOptions extends OperationOptions {
    timeOut?: number;
}

// @public (undocumented)
export interface CertificatesCreateCertificateOptions extends OperationOptions {
    contentType?: string;
    timeOut?: number;
}

// @public (undocumented)
export interface CertificatesDeleteCertificateOptions extends OperationOptions {
    timeOut?: number;
}

// @public (undocumented)
export interface CertificatesGetCertificateOptions extends OperationOptions {
    $select?: string[];
    timeOut?: number;
}

// @public (undocumented)
export interface CertificatesListCertificatesOptions extends OperationOptions {
    $filter?: string;
    $select?: string[];
    maxresults?: number;
    timeOut?: number;
}

// @public (undocumented)
export interface CertificatesOperations {
    // (undocumented)
    cancelCertificateDeletion: (thumbprintAlgorithm: string, thumbprint: string, options?: CertificatesCancelCertificateDeletionOptions) => Promise<void>;
    // (undocumented)
    createCertificate: (body: BatchCertificate, options?: CertificatesCreateCertificateOptions) => Promise<void>;
    // (undocumented)
    deleteCertificate: (thumbprintAlgorithm: string, thumbprint: string, options?: CertificatesDeleteCertificateOptions) => Promise<void>;
    // (undocumented)
    getCertificate: (thumbprintAlgorithm: string, thumbprint: string, options?: CertificatesGetCertificateOptions) => Promise<BatchCertificate>;
    // (undocumented)
    listCertificates: (options?: CertificatesListCertificatesOptions) => PagedAsyncIterableIterator<BatchCertificate>;
}

// @public
export type CertificateState = string;

// @public
export type CertificateStoreLocation = string;

// @public
export type CertificateVisibility = string;

// @public
export interface CifsMountConfiguration {
    mountOptions?: string;
    password: string;
    relativeMountPath: string;
    source: string;
    username: string;
}

// @public
export interface CloudServiceConfiguration {
    osFamily: string;
    osVersion?: string;
}

// @public
export interface ContainerConfiguration {
    containerImageNames?: string[];
    containerRegistries?: ContainerRegistry[];
    type: ContainerType;
}

// @public
export interface ContainerRegistry {
    identityReference?: BatchNodeIdentityReference;
    password?: string;
    registryServer?: string;
    username?: string;
}

// @public
export type ContainerType = string;

// @public
export type ContainerWorkingDirectory = string;

// @public
export type ContinuablePage<TElement, TPage = TElement[]> = TPage & {
    continuationToken?: string;
};

// @public
export interface DataDisk {
    caching?: CachingType;
    diskSizeGB: number;
    lun: number;
    storageAccountType?: StorageAccountType;
}

// @public
export interface DeleteCertificateError {
    code?: string;
    message?: string;
    values?: NameValuePair[];
}

// @public
export type DependencyAction = string;

// @public
export type DiffDiskPlacement = string;

// @public
export interface DiffDiskSettings {
    placement?: DiffDiskPlacement;
}

// @public
export type DisableBatchNodeSchedulingOption = string;

// @public
export type DisableJobOption = string;

// @public
export interface DiskEncryptionConfiguration {
    targets?: DiskEncryptionTarget[];
}

// @public
export type DiskEncryptionTarget = string;

// @public
export type DynamicVNetAssignmentScope = string;

// @public
export type ElevationLevel = string;

// @public
export interface EnvironmentSetting {
    name: string;
    value?: string;
}

// @public
export type ErrorCategory = string;

// @public
export interface ErrorMessage {
    lang?: string;
    value?: string;
}

// @public
export interface ExitCodeMapping {
    code: number;
    exitOptions: ExitOptions;
}

// @public
export interface ExitCodeRangeMapping {
    end: number;
    exitOptions: ExitOptions;
    start: number;
}

// @public
export interface ExitConditions {
    default?: ExitOptions;
    exitCodeRanges?: ExitCodeRangeMapping[];
    exitCodes?: ExitCodeMapping[];
    fileUploadError?: ExitOptions;
    preProcessingError?: ExitOptions;
}

// @public
export interface ExitOptions {
    dependencyAction?: DependencyAction;
    jobAction?: JobAction;
}

// @public
export interface FileProperties {
    contentLength: number;
    contentType?: string;
    creationTime?: Date;
    fileMode?: string;
    lastModified: Date;
}

// @public
export interface HttpHeader {
    name: string;
    value?: string;
}

// @public
export interface ImageInformation {
    batchSupportEndOfLife?: Date;
    capabilities?: string[];
    imageReference: ImageReference;
    nodeAgentSKUId: string;
    osType: OSType;
    verificationType: VerificationType;
}

// @public
export interface ImageReference {
    readonly exactVersion?: string;
    offer?: string;
    publisher?: string;
    sku?: string;
    version?: string;
    virtualMachineImageId?: string;
}

// @public
export interface InboundEndpoint {
    backendPort: number;
    frontendPort: number;
    name: string;
    protocol: InboundEndpointProtocol;
    publicFQDN?: string;
    publicIPAddress?: string;
}

// @public
export type InboundEndpointProtocol = string;

// @public
export interface InboundNATPool {
    backendPort: number;
    frontendPortRangeEnd: number;
    frontendPortRangeStart: number;
    name: string;
    networkSecurityGroupRules?: NetworkSecurityGroupRule[];
    protocol: InboundEndpointProtocol;
}

// @public
export interface InstanceViewStatus {
    code?: string;
    displayStatus?: string;
    level?: StatusLevelTypes;
    message?: string;
    time?: string;
}

// @public
export type IPAddressProvisioningType = string;

// @public
export type JobAction = string;

// @public
export interface JobConstraints {
    maxTaskRetryCount?: number;
    maxWallClockTime?: string;
}

// @public
export interface JobExecutionInformation {
    endTime?: Date;
    poolId?: string;
    schedulingError?: JobSchedulingError;
    startTime: Date;
    terminateReason?: string;
}

// @public
export interface JobManagerTask {
    allowLowPriorityNode?: boolean;
    applicationPackageReferences?: ApplicationPackageReference[];
    authenticationTokenSettings?: AuthenticationTokenSettings;
    commandLine: string;
    constraints?: TaskConstraints;
    containerSettings?: TaskContainerSettings;
    displayName?: string;
    environmentSettings?: EnvironmentSetting[];
    id: string;
    killJobOnCompletion?: boolean;
    outputFiles?: OutputFile[];
    requiredSlots?: number;
    resourceFiles?: ResourceFile[];
    runExclusive?: boolean;
    userIdentity?: UserIdentity;
}

// @public
export interface JobNetworkConfiguration {
    subnetId: string;
}

// @public
export interface JobPreparationAndReleaseTaskExecutionInformation {
    jobPreparationTaskExecutionInfo?: JobPreparationTaskExecutionInformation;
    jobReleaseTaskExecutionInfo?: JobReleaseTaskExecutionInformation;
    nodeId?: string;
    nodeUrl?: string;
    poolId?: string;
}

// @public
export interface JobPreparationTask {
    commandLine: string;
    constraints?: TaskConstraints;
    containerSettings?: TaskContainerSettings;
    environmentSettings?: EnvironmentSetting[];
    id?: string;
    rerunOnNodeRebootAfterSuccess?: boolean;
    resourceFiles?: ResourceFile[];
    userIdentity?: UserIdentity;
    waitForSuccess?: boolean;
}

// @public
export interface JobPreparationTaskExecutionInformation {
    containerInfo?: TaskContainerExecutionInformation;
    endTime?: Date;
    exitCode?: number;
    failureInfo?: TaskFailureInformation;
    lastRetryTime?: Date;
    result?: TaskExecutionResult;
    retryCount: number;
    startTime: Date;
    state: JobPreparationTaskState;
    taskRootDirectory?: string;
    taskRootDirectoryUrl?: string;
}

// @public
export type JobPreparationTaskState = string;

// @public
export interface JobReleaseTask {
    commandLine: string;
    containerSettings?: TaskContainerSettings;
    environmentSettings?: EnvironmentSetting[];
    id?: string;
    maxWallClockTime?: string;
    resourceFiles?: ResourceFile[];
    retentionTime?: string;
    userIdentity?: UserIdentity;
}

// @public
export interface JobReleaseTaskExecutionInformation {
    containerInfo?: TaskContainerExecutionInformation;
    endTime?: Date;
    exitCode?: number;
    failureInfo?: TaskFailureInformation;
    result?: TaskExecutionResult;
    startTime: Date;
    state: JobReleaseTaskState;
    taskRootDirectory?: string;
    taskRootDirectoryUrl?: string;
}

// @public
export type JobReleaseTaskState = string;

// @public
export interface JobScheduleExecutionInformation {
    endTime?: Date;
    nextRunTime?: Date;
    recentJob?: RecentJob;
}

// @public (undocumented)
export interface JobSchedulesCreateJobScheduleOptions extends OperationOptions {
    contentType?: string;
    timeOut?: number;
}

// @public (undocumented)
export interface JobSchedulesDeleteJobScheduleOptions extends OperationOptions {
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOut?: number;
}

// @public (undocumented)
export interface JobSchedulesDisableJobScheduleOptions extends OperationOptions {
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOut?: number;
}

// @public (undocumented)
export interface JobSchedulesEnableJobScheduleOptions extends OperationOptions {
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOut?: number;
}

// @public (undocumented)
export interface JobSchedulesGetJobScheduleOptions extends OperationOptions {
    $expand?: string[];
    $select?: string[];
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOut?: number;
}

// @public (undocumented)
export interface JobSchedulesJobScheduleExistsOptions extends OperationOptions {
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOut?: number;
}

// @public (undocumented)
export interface JobSchedulesListJobSchedulesOptions extends OperationOptions {
    $expand?: string[];
    $filter?: string;
    $select?: string[];
    maxresults?: number;
    timeOut?: number;
}

// @public (undocumented)
export interface JobSchedulesOperations {
    // (undocumented)
    createJobSchedule: (body: BatchJobScheduleCreateOptions, options?: JobSchedulesCreateJobScheduleOptions) => Promise<void>;
    // (undocumented)
    deleteJobSchedule: (jobScheduleId: string, options?: JobSchedulesDeleteJobScheduleOptions) => Promise<void>;
    // (undocumented)
    disableJobSchedule: (jobScheduleId: string, options?: JobSchedulesDisableJobScheduleOptions) => Promise<void>;
    // (undocumented)
    enableJobSchedule: (jobScheduleId: string, options?: JobSchedulesEnableJobScheduleOptions) => Promise<void>;
    // (undocumented)
    getJobSchedule: (jobScheduleId: string, options?: JobSchedulesGetJobScheduleOptions) => Promise<BatchJobSchedule>;
    // (undocumented)
    jobScheduleExists: (jobScheduleId: string, options?: JobSchedulesJobScheduleExistsOptions) => Promise<void>;
    // (undocumented)
    listJobSchedules: (options?: JobSchedulesListJobSchedulesOptions) => PagedAsyncIterableIterator<BatchJobSchedule>;
    // (undocumented)
    replaceJobSchedule: (jobScheduleId: string, body: BatchJobSchedule, options?: JobSchedulesReplaceJobScheduleOptions) => Promise<void>;
    // (undocumented)
    terminateJobSchedule: (jobScheduleId: string, options?: JobSchedulesTerminateJobScheduleOptions) => Promise<void>;
    // (undocumented)
    updateJobSchedule: (jobScheduleId: string, body: BatchJobScheduleUpdateOptions, options?: JobSchedulesUpdateJobScheduleOptions) => Promise<void>;
}

// @public (undocumented)
export interface JobSchedulesReplaceJobScheduleOptions extends OperationOptions {
    contentType?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOut?: number;
}

// @public
export type JobScheduleState = string;

// @public
export interface JobScheduleStatistics {
    kernelCPUTime: string;
    lastUpdateTime: Date;
    numFailedTasks: number;
    numSucceededTasks: number;
    numTaskRetries: number;
    readIOGiB: number;
    readIOps: number;
    startTime: Date;
    url: string;
    userCPUTime: string;
    waitTime: string;
    wallClockTime: string;
    writeIOGiB: number;
    writeIOps: number;
}

// @public (undocumented)
export interface JobSchedulesTerminateJobScheduleOptions extends OperationOptions {
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOut?: number;
}

// @public (undocumented)
export interface JobSchedulesUpdateJobScheduleOptions extends OperationOptions {
    contentType?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOut?: number;
}

// @public
export interface JobSchedulingError {
    category: ErrorCategory;
    code?: string;
    details?: NameValuePair[];
    message?: string;
}

// @public (undocumented)
export interface JobsCreateJobOptions extends OperationOptions {
    contentType?: string;
    timeOut?: number;
}

// @public (undocumented)
export interface JobsDeleteJobOptions extends OperationOptions {
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOut?: number;
}

// @public (undocumented)
export interface JobsDisableJobOptions extends OperationOptions {
    contentType?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOut?: number;
}

// @public (undocumented)
export interface JobsEnableJobOptions extends OperationOptions {
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOut?: number;
}

// @public (undocumented)
export interface JobsGetJobOptions extends OperationOptions {
    $expand?: string[];
    $select?: string[];
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOut?: number;
}

// @public (undocumented)
export interface JobsGetJobTaskCountsOptions extends OperationOptions {
    timeOut?: number;
}

// @public (undocumented)
export interface JobsListJobPreparationAndReleaseTaskStatusOptions extends OperationOptions {
    $filter?: string;
    $select?: string[];
    maxresults?: number;
    timeOut?: number;
}

// @public (undocumented)
export interface JobsListJobsFromScheduleOptions extends OperationOptions {
    $expand?: string[];
    $filter?: string;
    $select?: string[];
    maxresults?: number;
    timeOut?: number;
}

// @public (undocumented)
export interface JobsListJobsOptions extends OperationOptions {
    $expand?: string[];
    $filter?: string;
    $select?: string[];
    maxresults?: number;
    timeOut?: number;
}

// @public (undocumented)
export interface JobsOperations {
    // (undocumented)
    createJob: (body: BatchJobCreateOptions, options?: JobsCreateJobOptions) => Promise<void>;
    // (undocumented)
    deleteJob: (jobId: string, options?: JobsDeleteJobOptions) => Promise<void>;
    // (undocumented)
    disableJob: (jobId: string, body: BatchJobDisableOptions, options?: JobsDisableJobOptions) => Promise<void>;
    // (undocumented)
    enableJob: (jobId: string, options?: JobsEnableJobOptions) => Promise<void>;
    // (undocumented)
    getJob: (jobId: string, options?: JobsGetJobOptions) => Promise<BatchJob>;
    // (undocumented)
    getJobTaskCounts: (jobId: string, options?: JobsGetJobTaskCountsOptions) => Promise<TaskCountsResult>;
    // (undocumented)
    listJobPreparationAndReleaseTaskStatus: (jobId: string, options?: JobsListJobPreparationAndReleaseTaskStatusOptions) => PagedAsyncIterableIterator<JobPreparationAndReleaseTaskExecutionInformation>;
    // (undocumented)
    listJobs: (options?: JobsListJobsOptions) => PagedAsyncIterableIterator<BatchJob>;
    // (undocumented)
    listJobsFromSchedule: (jobScheduleId: string, options?: JobsListJobsFromScheduleOptions) => PagedAsyncIterableIterator<BatchJob>;
    // (undocumented)
    replaceJob: (jobId: string, body: BatchJob, options?: JobsReplaceJobOptions) => Promise<void>;
    // (undocumented)
    terminateJob: (jobId: string, body: BatchJobTerminateOptions, options?: JobsTerminateJobOptions) => Promise<void>;
    // (undocumented)
    updateJob: (jobId: string, body: BatchJobUpdateOptions, options?: JobsUpdateJobOptions) => Promise<void>;
}

// @public
export interface JobSpecification {
    allowTaskPreemption?: boolean;
    commonEnvironmentSettings?: EnvironmentSetting[];
    constraints?: JobConstraints;
    displayName?: string;
    jobManagerTask?: JobManagerTask;
    jobPreparationTask?: JobPreparationTask;
    jobReleaseTask?: JobReleaseTask;
    maxParallelTasks?: number;
    metadata?: MetadataItem[];
    networkConfiguration?: JobNetworkConfiguration;
    onAllTasksComplete?: OnAllTasksComplete;
    onTaskFailure?: OnTaskFailure;
    poolInfo: PoolInformation;
    priority?: number;
    usesTaskDependencies?: boolean;
}

// @public (undocumented)
export interface JobsReplaceJobOptions extends OperationOptions {
    contentType?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOut?: number;
}

// @public
export type JobState = string;

// @public
export interface JobStatistics {
    kernelCPUTime: string;
    lastUpdateTime: Date;
    numFailedTasks: number;
    numSucceededTasks: number;
    numTaskRetries: number;
    readIOGiB: number;
    readIOps: number;
    startTime: Date;
    url: string;
    userCPUTime: string;
    waitTime: string;
    wallClockTime: string;
    writeIOGiB: number;
    writeIOps: number;
}

// @public (undocumented)
export interface JobsTerminateJobOptions extends OperationOptions {
    contentType?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOut?: number;
}

// @public (undocumented)
export interface JobsUpdateJobOptions extends OperationOptions {
    contentType?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOut?: number;
}

// @public
export interface LinuxUserConfiguration {
    gid?: number;
    sshPrivateKey?: string;
    uid?: number;
}

// @public
export type LoginMode = string;

// @public
export interface MetadataItem {
    name: string;
    value: string;
}

// @public
export interface MountConfiguration {
    azureBlobFileSystemConfiguration?: AzureBlobFileSystemConfiguration;
    azureFileShareConfiguration?: AzureFileShareConfiguration;
    cifsMountConfiguration?: CifsMountConfiguration;
    nfsMountConfiguration?: NfsMountConfiguration;
}

// @public
export interface MultiInstanceSettings {
    commonResourceFiles?: ResourceFile[];
    coordinationCommandLine: string;
    numberOfInstances?: number;
}

// @public
export interface NameValuePair {
    name?: string;
    value?: string;
}

// @public
export interface NetworkConfiguration {
    dynamicVNetAssignmentScope?: DynamicVNetAssignmentScope;
    enableAcceleratedNetworking?: boolean;
    endpointConfiguration?: PoolEndpointConfiguration;
    publicIPAddressConfiguration?: PublicIpAddressConfiguration;
    subnetId?: string;
}

// @public
export interface NetworkSecurityGroupRule {
    access: NetworkSecurityGroupRuleAccess;
    priority: number;
    sourceAddressPrefix: string;
    sourcePortRanges?: string[];
}

// @public
export type NetworkSecurityGroupRuleAccess = string;

// @public
export interface NfsMountConfiguration {
    mountOptions?: string;
    relativeMountPath: string;
    source: string;
}

// @public
export interface NodeAgentInformation {
    lastUpdateTime: Date;
    version: string;
}

// @public
export type NodeCommunicationMode = string;

// @public
export interface NodeCounts {
    creating: number;
    idle: number;
    leavingPool: number;
    offline: number;
    preempted: number;
    rebooting: number;
    reimaging: number;
    running: number;
    starting: number;
    startTaskFailed: number;
    total: number;
    unknown: number;
    unusable: number;
    waitingForStartTask: number;
}

// @public
export interface NodeDisableSchedulingOptions {
    nodeDisableSchedulingOption?: DisableBatchNodeSchedulingOption;
}

// @public
export interface NodeFile {
    isDirectory?: boolean;
    name?: string;
    properties?: FileProperties;
    url?: string;
}

// @public
export interface NodeFileListResult {
    "odata.nextLink"?: string;
    value?: NodeFile[];
}

// @public
export interface NodePlacementConfiguration {
    policy?: NodePlacementPolicyType;
}

// @public
export type NodePlacementPolicyType = string;

// @public
export interface NodeRebootOptions {
    nodeRebootOption?: BatchNodeRebootOption;
}

// @public
export interface NodeReimageOptions {
    nodeReimageOption?: BatchNodeReimageOption;
}

// @public
export interface NodeRemoveOptions {
    nodeDeallocationOption?: BatchNodeDeallocationOption;
    nodeList: string[];
    resizeTimeout?: string;
}

// @public (undocumented)
export interface NodesCreateNodeUserOptions extends OperationOptions {
    contentType?: string;
    timeOut?: number;
}

// @public (undocumented)
export interface NodesDeleteNodeFileOptions extends OperationOptions {
    recursive?: boolean;
    timeOut?: number;
}

// @public (undocumented)
export interface NodesDeleteNodeUserOptions extends OperationOptions {
    timeOut?: number;
}

// @public (undocumented)
export interface NodesDisableNodeSchedulingOptions extends OperationOptions {
    contentType?: string;
    timeOut?: number;
}

// @public (undocumented)
export interface NodesEnableNodeSchedulingOptions extends OperationOptions {
    timeOut?: number;
}

// @public (undocumented)
export interface NodesGetNodeExtensionOptions extends OperationOptions {
    $select?: string[];
    timeOut?: number;
}

// @public (undocumented)
export interface NodesGetNodeFileOptions extends OperationOptions {
    ifModifiedSince?: Date;
    ifUnmodifiedSince?: Date;
    ocpRange?: string;
    timeOut?: number;
}

// @public (undocumented)
export interface NodesGetNodeFilePropertiesOptions extends OperationOptions {
    ifModifiedSince?: Date;
    ifUnmodifiedSince?: Date;
    timeOut?: number;
}

// @public (undocumented)
export interface NodesGetNodeOptions extends OperationOptions {
    $select?: string[];
    timeOut?: number;
}

// @public (undocumented)
export interface NodesGetNodeRemoteDesktopFileOptions extends OperationOptions {
    timeOut?: number;
}

// @public (undocumented)
export interface NodesGetNodeRemoteLoginSettingsOptions extends OperationOptions {
    timeOut?: number;
}

// @public (undocumented)
export interface NodesListNodeExtensionsOptions extends OperationOptions {
    $select?: string[];
    maxresults?: number;
    timeOut?: number;
}

// @public (undocumented)
export interface NodesListNodeFilesOptions extends OperationOptions {
    $filter?: string;
    maxresults?: number;
    recursive?: boolean;
    timeOut?: number;
}

// @public (undocumented)
export interface NodesListNodesOptions extends OperationOptions {
    $filter?: string;
    $select?: string[];
    maxresults?: number;
    timeOut?: number;
}

// @public (undocumented)
export interface NodesOperations {
    // (undocumented)
    createNodeUser: (poolId: string, nodeId: string, body: BatchNodeUserCreateOptions, options?: NodesCreateNodeUserOptions) => Promise<void>;
    // (undocumented)
    deleteNodeFile: (poolId: string, nodeId: string, filePath: string, options?: NodesDeleteNodeFileOptions) => Promise<void>;
    // (undocumented)
    deleteNodeUser: (poolId: string, nodeId: string, userName: string, options?: NodesDeleteNodeUserOptions) => Promise<void>;
    // (undocumented)
    disableNodeScheduling: (poolId: string, nodeId: string, body: NodeDisableSchedulingOptions, options?: NodesDisableNodeSchedulingOptions) => Promise<void>;
    // (undocumented)
    enableNodeScheduling: (poolId: string, nodeId: string, options?: NodesEnableNodeSchedulingOptions) => Promise<void>;
    // (undocumented)
    getNode: (poolId: string, nodeId: string, options?: NodesGetNodeOptions) => Promise<BatchNode>;
    // (undocumented)
    getNodeExtension: (poolId: string, nodeId: string, extensionName: string, options?: NodesGetNodeExtensionOptions) => Promise<NodeVMExtension>;
    // (undocumented)
    getNodeFile: (poolId: string, nodeId: string, filePath: string, options?: NodesGetNodeFileOptions) => Promise<Uint8Array>;
    // (undocumented)
    getNodeFileProperties: (poolId: string, nodeId: string, filePath: string, options?: NodesGetNodeFilePropertiesOptions) => Promise<void>;
    // (undocumented)
    getNodeRemoteDesktopFile: (poolId: string, nodeId: string, options?: NodesGetNodeRemoteDesktopFileOptions) => Promise<Uint8Array>;
    // (undocumented)
    getNodeRemoteLoginSettings: (poolId: string, nodeId: string, options?: NodesGetNodeRemoteLoginSettingsOptions) => Promise<BatchNodeRemoteLoginSettingsResult>;
    // (undocumented)
    listNodeExtensions: (poolId: string, nodeId: string, options?: NodesListNodeExtensionsOptions) => PagedAsyncIterableIterator<NodeVMExtension>;
    // (undocumented)
    listNodeFiles: (poolId: string, nodeId: string, options?: NodesListNodeFilesOptions) => PagedAsyncIterableIterator<NodeFile>;
    // (undocumented)
    listNodes: (poolId: string, options?: NodesListNodesOptions) => PagedAsyncIterableIterator<BatchNode>;
    // (undocumented)
    rebootNode: (poolId: string, nodeId: string, body: NodeRebootOptions, options?: NodesRebootNodeOptions) => Promise<void>;
    // (undocumented)
    reimageNode: (poolId: string, nodeId: string, body: NodeReimageOptions, options?: NodesReimageNodeOptions) => Promise<void>;
    // (undocumented)
    replaceNodeUser: (poolId: string, nodeId: string, userName: string, body: BatchNodeUserUpdateOptions, options?: NodesReplaceNodeUserOptions) => Promise<void>;
    // (undocumented)
    uploadNodeLogs: (poolId: string, nodeId: string, body: UploadBatchServiceLogsOptions, options?: NodesUploadNodeLogsOptions) => Promise<UploadBatchServiceLogsResult>;
}

// @public (undocumented)
export interface NodesRebootNodeOptions extends OperationOptions {
    contentType?: string;
    timeOut?: number;
}

// @public (undocumented)
export interface NodesReimageNodeOptions extends OperationOptions {
    contentType?: string;
    timeOut?: number;
}

// @public (undocumented)
export interface NodesReplaceNodeUserOptions extends OperationOptions {
    contentType?: string;
    timeOut?: number;
}

// @public (undocumented)
export interface NodesUploadNodeLogsOptions extends OperationOptions {
    contentType?: string;
    timeOut?: number;
}

// @public
export interface NodeVMExtension {
    instanceView?: VMExtensionInstanceView;
    provisioningState?: string;
    vmExtension?: VMExtension;
}

// @public
export interface NodeVMExtensionList {
    "odata.nextLink"?: string;
    value?: NodeVMExtension[];
}

// @public
export type OnAllTasksComplete = string;

// @public
export type OnTaskFailure = string;

// @public
export interface OSDisk {
    ephemeralOSDiskSettings?: DiffDiskSettings;
}

// @public
export type OSType = string;

// @public
export interface OutputFile {
    destination: OutputFileDestination;
    filePattern: string;
    uploadOptions: OutputFileUploadOptions;
}

// @public
export interface OutputFileBlobContainerDestination {
    containerUrl: string;
    identityReference?: BatchNodeIdentityReference;
    path?: string;
    uploadHeaders?: HttpHeader[];
}

// @public
export interface OutputFileDestination {
    container?: OutputFileBlobContainerDestination;
}

// @public
export type OutputFileUploadCondition = string;

// @public
export interface OutputFileUploadOptions {
    uploadCondition: OutputFileUploadCondition;
}

// @public
export interface PagedAsyncIterableIterator<TElement, TPage = TElement[], TPageSettings extends PageSettings = PageSettings> {
    [Symbol.asyncIterator](): PagedAsyncIterableIterator<TElement, TPage, TPageSettings>;
    byPage: (settings?: TPageSettings) => AsyncIterableIterator<ContinuablePage<TElement, TPage>>;
    next(): Promise<IteratorResult<TElement>>;
}

// @public
export interface PageSettings {
    continuationToken?: string;
}

// @public
export interface PoolEndpointConfiguration {
    inboundNATPools: InboundNATPool[];
}

// @public
export type PoolIdentityType = string;

// @public
export interface PoolInformation {
    autoPoolSpecification?: AutoPoolSpecification;
    poolId?: string;
}

// @public
export type PoolLifetimeOption = string;

// @public
export interface PoolListUsageMetricsResult {
    "odata.nextLink"?: string;
    value?: PoolUsageMetrics[];
}

// @public
export interface PoolNodeCounts {
    dedicated?: NodeCounts;
    lowPriority?: NodeCounts;
    poolId: string;
}

// @public
export interface PoolNodeCountsListResult {
    "odata.nextLink"?: string;
    value?: PoolNodeCounts[];
}

// @public (undocumented)
export interface PoolsCreatePoolOptions extends OperationOptions {
    contentType?: string;
    timeOut?: number;
}

// @public (undocumented)
export interface PoolsDeletePoolOptions extends OperationOptions {
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOut?: number;
}

// @public (undocumented)
export interface PoolsDisablePoolAutoScaleOptions extends OperationOptions {
    timeOut?: number;
}

// @public (undocumented)
export interface PoolsEnablePoolAutoScaleOptions extends OperationOptions {
    contentType?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOut?: number;
}

// @public (undocumented)
export interface PoolsEvaluatePoolAutoScaleOptions extends OperationOptions {
    contentType?: string;
    timeOut?: number;
}

// @public (undocumented)
export interface PoolsGetPoolOptions extends OperationOptions {
    $expand?: string[];
    $select?: string[];
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOut?: number;
}

// @public (undocumented)
export interface PoolsListPoolsOptions extends OperationOptions {
    $expand?: string[];
    $filter?: string;
    $select?: string[];
    maxresults?: number;
    timeOut?: number;
}

// @public (undocumented)
export interface PoolsListPoolUsageMetricsOptions extends OperationOptions {
    $filter?: string;
    endtime?: Date;
    maxresults?: number;
    starttime?: Date;
    timeOut?: number;
}

// @public (undocumented)
export interface PoolsOperations {
    // (undocumented)
    createPool: (body: BatchPoolCreateOptions, options?: PoolsCreatePoolOptions) => Promise<void>;
    // (undocumented)
    deletePool: (poolId: string, options?: PoolsDeletePoolOptions) => Promise<void>;
    // (undocumented)
    disablePoolAutoScale: (poolId: string, options?: PoolsDisablePoolAutoScaleOptions) => Promise<void>;
    // (undocumented)
    enablePoolAutoScale: (poolId: string, body: BatchPoolEnableAutoScaleOptions, options?: PoolsEnablePoolAutoScaleOptions) => Promise<void>;
    // (undocumented)
    evaluatePoolAutoScale: (poolId: string, body: BatchPoolEvaluateAutoScaleOptions, options?: PoolsEvaluatePoolAutoScaleOptions) => Promise<AutoScaleRun>;
    // (undocumented)
    getPool: (poolId: string, options?: PoolsGetPoolOptions) => Promise<BatchPool>;
    // (undocumented)
    listPools: (options?: PoolsListPoolsOptions) => PagedAsyncIterableIterator<BatchPool>;
    // (undocumented)
    listPoolUsageMetrics: (options?: PoolsListPoolUsageMetricsOptions) => PagedAsyncIterableIterator<PoolUsageMetrics>;
    // (undocumented)
    poolExists: (poolId: string, options?: PoolsPoolExistsOptions) => Promise<void>;
    // (undocumented)
    removeNodes: (poolId: string, body: NodeRemoveOptions, options?: PoolsRemoveNodesOptions) => Promise<void>;
    // (undocumented)
    replacePoolProperties: (poolId: string, body: BatchPoolReplaceOptions, options?: PoolsReplacePoolPropertiesOptions) => Promise<void>;
    // (undocumented)
    resizePool: (poolId: string, body: BatchPoolResizeOptions, options?: PoolsResizePoolOptions) => Promise<void>;
    // (undocumented)
    stopPoolResize: (poolId: string, options?: PoolsStopPoolResizeOptions) => Promise<void>;
    // (undocumented)
    updatePool: (poolId: string, body: BatchPoolUpdateOptions, options?: PoolsUpdatePoolOptions) => Promise<void>;
}

// @public
export interface PoolSpecification {
    applicationLicenses?: string[];
    applicationPackageReferences?: ApplicationPackageReference[];
    autoScaleEvaluationInterval?: string;
    autoScaleFormula?: string;
    certificateReferences?: CertificateReference[];
    cloudServiceConfiguration?: CloudServiceConfiguration;
    displayName?: string;
    enableAutoScale?: boolean;
    enableInterNodeCommunication?: boolean;
    metadata?: MetadataItem[];
    mountConfiguration?: MountConfiguration[];
    networkConfiguration?: NetworkConfiguration;
    resizeTimeout?: string;
    startTask?: StartTask;
    targetDedicatedNodes?: number;
    targetLowPriorityNodes?: number;
    targetNodeCommunicationMode?: NodeCommunicationMode;
    taskSchedulingPolicy?: TaskSchedulingPolicy;
    taskSlotsPerNode?: number;
    userAccounts?: UserAccount[];
    virtualMachineConfiguration?: VirtualMachineConfiguration;
    vmSize: string;
}

// @public (undocumented)
export interface PoolsPoolExistsOptions extends OperationOptions {
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOut?: number;
}

// @public (undocumented)
export interface PoolsRemoveNodesOptions extends OperationOptions {
    contentType?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOut?: number;
}

// @public (undocumented)
export interface PoolsReplacePoolPropertiesOptions extends OperationOptions {
    contentType?: string;
    timeOut?: number;
}

// @public (undocumented)
export interface PoolsResizePoolOptions extends OperationOptions {
    contentType?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOut?: number;
}

// @public (undocumented)
export interface PoolsStopPoolResizeOptions extends OperationOptions {
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOut?: number;
}

// @public
export type PoolState = string;

// @public
export interface PoolStatistics {
    lastUpdateTime: Date;
    resourceStats?: ResourceStatistics;
    startTime: Date;
    url: string;
    usageStats?: UsageStatistics;
}

// @public (undocumented)
export interface PoolsUpdatePoolOptions extends OperationOptions {
    contentType?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOut?: number;
}

// @public
export interface PoolUsageMetrics {
    endTime: Date;
    poolId: string;
    startTime: Date;
    totalCoreHours: number;
    vmSize: string;
}

// @public
export interface PublicIpAddressConfiguration {
    ipAddressIds?: string[];
    provision?: IPAddressProvisioningType;
}

// @public
export interface RecentJob {
    id?: string;
    url?: string;
}

// @public
export interface ResizeError {
    code?: string;
    message?: string;
    values?: NameValuePair[];
}

// @public
export interface ResourceFile {
    autoStorageContainerName?: string;
    blobPrefix?: string;
    fileMode?: string;
    filePath?: string;
    httpUrl?: string;
    identityReference?: BatchNodeIdentityReference;
    storageContainerUrl?: string;
}

// @public
export interface ResourceStatistics {
    avgCPUPercentage: number;
    avgDiskGiB: number;
    avgMemoryGiB: number;
    diskReadGiB: number;
    diskReadIOps: number;
    diskWriteGiB: number;
    diskWriteIOps: number;
    lastUpdateTime: Date;
    networkReadGiB: number;
    networkWriteGiB: number;
    peakDiskGiB: number;
    peakMemoryGiB: number;
    startTime: Date;
}

// @public
export interface Schedule {
    doNotRunAfter?: Date;
    doNotRunUntil?: Date;
    recurrenceInterval?: string;
    startWindow?: string;
}

// @public
export type SchedulingState = string;

// @public
export interface StartTask {
    commandLine: string;
    containerSettings?: TaskContainerSettings;
    environmentSettings?: EnvironmentSetting[];
    maxTaskRetryCount?: number;
    resourceFiles?: ResourceFile[];
    userIdentity?: UserIdentity;
    waitForSuccess?: boolean;
}

// @public
export interface StartTaskInformation {
    containerInfo?: TaskContainerExecutionInformation;
    endTime?: Date;
    exitCode?: number;
    failureInfo?: TaskFailureInformation;
    lastRetryTime?: Date;
    result?: TaskExecutionResult;
    retryCount: number;
    startTime: Date;
    state: StartTaskState;
}

// @public
export type StartTaskState = string;

// @public
export type StatusLevelTypes = string;

// @public
export type StorageAccountType = string;

// @public
export interface SubtaskInformation {
    containerInfo?: TaskContainerExecutionInformation;
    endTime?: Date;
    exitCode?: number;
    failureInfo?: TaskFailureInformation;
    id?: number;
    nodeInfo?: BatchNodeInformation;
    previousState?: SubtaskState;
    previousStateTransitionTime?: Date;
    result?: TaskExecutionResult;
    startTime?: Date;
    state?: SubtaskState;
    stateTransitionTime?: Date;
}

// @public
export type SubtaskState = string;

// @public
export interface TaskAddCollectionResult {
    value?: TaskAddResult[];
}

// @public
export interface TaskAddResult {
    error?: BatchError;
    eTag?: string;
    lastModified?: Date;
    location?: string;
    status: TaskAddStatus;
    taskId: string;
}

// @public
export type TaskAddStatus = string;

// @public
export interface TaskConstraints {
    maxTaskRetryCount?: number;
    maxWallClockTime?: string;
    retentionTime?: string;
}

// @public
export interface TaskContainerExecutionInformation {
    containerId?: string;
    error?: string;
    state?: string;
}

// @public
export interface TaskContainerSettings {
    containerRunOptions?: string;
    imageName: string;
    registry?: ContainerRegistry;
    workingDirectory?: ContainerWorkingDirectory;
}

// @public
export interface TaskCounts {
    active: number;
    completed: number;
    failed: number;
    running: number;
    succeeded: number;
}

// @public
export interface TaskCountsResult {
    taskCounts: TaskCounts;
    taskSlotCounts: TaskSlotCounts;
}

// @public
export interface TaskDependencies {
    taskIdRanges?: TaskIdRange[];
    taskIds?: string[];
}

// @public
export interface TaskExecutionInformation {
    containerInfo?: TaskContainerExecutionInformation;
    endTime?: Date;
    exitCode?: number;
    failureInfo?: TaskFailureInformation;
    lastRequeueTime?: Date;
    lastRetryTime?: Date;
    requeueCount: number;
    result?: TaskExecutionResult;
    retryCount: number;
    startTime?: Date;
}

// @public
export type TaskExecutionResult = string;

// @public
export interface TaskFailureInformation {
    category: ErrorCategory;
    code?: string;
    details?: NameValuePair[];
    message?: string;
}

// @public
export interface TaskIdRange {
    end: number;
    start: number;
}

// @public
export interface TaskInformation {
    executionInfo?: TaskExecutionInformation;
    jobId?: string;
    subtaskId?: number;
    taskId?: string;
    taskState: TaskState;
    taskUrl?: string;
}

// @public
export interface TaskSchedulingPolicy {
    nodeFillType: BatchNodeFillType;
}

// @public (undocumented)
export interface TasksCreateTaskCollectionOptions extends OperationOptions {
    contentType?: string;
    timeOut?: number;
}

// @public (undocumented)
export interface TasksCreateTaskOptions extends OperationOptions {
    contentType?: string;
    timeOut?: number;
}

// @public (undocumented)
export interface TasksDeleteTaskFileOptions extends OperationOptions {
    recursive?: boolean;
    timeOut?: number;
}

// @public (undocumented)
export interface TasksDeleteTaskOptions extends OperationOptions {
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOut?: number;
}

// @public (undocumented)
export interface TasksGetTaskFileOptions extends OperationOptions {
    ifModifiedSince?: Date;
    ifUnmodifiedSince?: Date;
    ocpRange?: string;
    timeOut?: number;
}

// @public (undocumented)
export interface TasksGetTaskFilePropertiesOptions extends OperationOptions {
    ifModifiedSince?: Date;
    ifUnmodifiedSince?: Date;
    timeOut?: number;
}

// @public (undocumented)
export interface TasksGetTaskOptions extends OperationOptions {
    $expand?: string[];
    $select?: string[];
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOut?: number;
}

// @public (undocumented)
export interface TasksListSubTasksOptions extends OperationOptions {
    $select?: string[];
    timeOut?: number;
}

// @public (undocumented)
export interface TasksListTaskFilesOptions extends OperationOptions {
    $filter?: string;
    maxresults?: number;
    recursive?: boolean;
    timeOut?: number;
}

// @public (undocumented)
export interface TasksListTasksOptions extends OperationOptions {
    $expand?: string[];
    $filter?: string;
    $select?: string[];
    maxresults?: number;
    timeOut?: number;
}

// @public
export interface TaskSlotCounts {
    active: number;
    completed: number;
    failed: number;
    running: number;
    succeeded: number;
}

// @public (undocumented)
export interface TasksOperations {
    // (undocumented)
    createTask: (jobId: string, body: BatchTaskCreateOptions, options?: TasksCreateTaskOptions) => Promise<void>;
    // (undocumented)
    createTaskCollection: (jobId: string, collection: BatchTaskCollection, options?: TasksCreateTaskCollectionOptions) => Promise<TaskAddCollectionResult>;
    // (undocumented)
    deleteTask: (jobId: string, taskId: string, options?: TasksDeleteTaskOptions) => Promise<void>;
    // (undocumented)
    deleteTaskFile: (jobId: string, taskId: string, filePath: string, options?: TasksDeleteTaskFileOptions) => Promise<void>;
    // (undocumented)
    getTask: (jobId: string, taskId: string, options?: TasksGetTaskOptions) => Promise<BatchTask>;
    // (undocumented)
    getTaskFile: (jobId: string, taskId: string, filePath: string, options?: TasksGetTaskFileOptions) => Promise<Uint8Array>;
    // (undocumented)
    getTaskFileProperties: (jobId: string, taskId: string, filePath: string, options?: TasksGetTaskFilePropertiesOptions) => Promise<void>;
    // (undocumented)
    listSubTasks: (jobId: string, taskId: string, options?: TasksListSubTasksOptions) => Promise<BatchTaskListSubtasksResult>;
    // (undocumented)
    listTaskFiles: (jobId: string, taskId: string, options?: TasksListTaskFilesOptions) => PagedAsyncIterableIterator<NodeFile>;
    // (undocumented)
    listTasks: (jobId: string, options?: TasksListTasksOptions) => PagedAsyncIterableIterator<BatchTask>;
    // (undocumented)
    reactivateTask: (jobId: string, taskId: string, options?: TasksReactivateTaskOptions) => Promise<void>;
    // (undocumented)
    replaceTask: (jobId: string, taskId: string, body: BatchTask, options?: TasksReplaceTaskOptions) => Promise<void>;
    // (undocumented)
    terminateTask: (jobId: string, taskId: string, options?: TasksTerminateTaskOptions) => Promise<void>;
}

// @public (undocumented)
export interface TasksReactivateTaskOptions extends OperationOptions {
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOut?: number;
}

// @public (undocumented)
export interface TasksReplaceTaskOptions extends OperationOptions {
    contentType?: string;
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOut?: number;
}

// @public
export type TaskState = string;

// @public
export interface TaskStatistics {
    kernelCPUTime: string;
    lastUpdateTime: Date;
    readIOGiB: number;
    readIOps: number;
    startTime: Date;
    url: string;
    userCPUTime: string;
    waitTime: string;
    wallClockTime: string;
    writeIOGiB: number;
    writeIOps: number;
}

// @public (undocumented)
export interface TasksTerminateTaskOptions extends OperationOptions {
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
    timeOut?: number;
}

// @public
export interface UploadBatchServiceLogsOptions {
    containerUrl: string;
    endTime?: Date;
    identityReference?: BatchNodeIdentityReference;
    startTime: Date;
}

// @public
export interface UploadBatchServiceLogsResult {
    numberOfFilesUploaded: number;
    virtualDirectoryName: string;
}

// @public
export interface UsageStatistics {
    dedicatedCoreTime: string;
    lastUpdateTime: Date;
    startTime: Date;
}

// @public
export interface UserAccount {
    elevationLevel?: ElevationLevel;
    linuxUserConfiguration?: LinuxUserConfiguration;
    name: string;
    password: string;
    windowsUserConfiguration?: WindowsUserConfiguration;
}

// @public
export interface UserAssignedIdentity {
    readonly clientId?: string;
    readonly principalId?: string;
    resourceId: string;
}

// @public
export interface UserIdentity {
    autoUser?: AutoUserSpecification;
    username?: string;
}

// @public
export type VerificationType = string;

// @public
export interface VirtualMachineConfiguration {
    containerConfiguration?: ContainerConfiguration;
    dataDisks?: DataDisk[];
    diskEncryptionConfiguration?: DiskEncryptionConfiguration;
    extensions?: VMExtension[];
    imageReference: ImageReference;
    licenseType?: string;
    nodeAgentSKUId: string;
    nodePlacementConfiguration?: NodePlacementConfiguration;
    osDisk?: OSDisk;
    windowsConfiguration?: WindowsConfiguration;
}

// @public
export interface VirtualMachineInfo {
    imageReference?: ImageReference;
}

// @public
export interface VMExtension {
    autoUpgradeMinorVersion?: boolean;
    enableAutomaticUpgrade?: boolean;
    name: string;
    protectedSettings?: Record<string, string>;
    provisionAfterExtensions?: string[];
    publisher: string;
    settings?: Record<string, string>;
    type: string;
    typeHandlerVersion?: string;
}

// @public
export interface VMExtensionInstanceView {
    name?: string;
    statuses?: InstanceViewStatus[];
    subStatuses?: InstanceViewStatus[];
}

// @public
export interface WindowsConfiguration {
    enableAutomaticUpdates?: boolean;
}

// @public
export interface WindowsUserConfiguration {
    loginMode?: LoginMode;
}

// (No @packageDocumentation comment for this package)

```
