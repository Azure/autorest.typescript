## API Report File for "@azure/load-testing"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbortSignalLike } from '@azure/abort-controller';
import { ClientOptions } from '@azure-rest/core-client';
import { KeyCredential } from '@azure/core-auth';
import { OperationOptions } from '@azure-rest/core-client';
import { OperationState } from '@azure/core-lro';
import { PathUncheckedResponse } from '@azure-rest/core-client';
import { Pipeline } from '@azure/core-rest-pipeline';
import { PollerLike } from '@azure/core-lro';
import { TokenCredential } from '@azure/core-auth';

// @public
export interface BatchOptions {
    translateTextWithinImage?: boolean;
}

// @public
export interface BatchRequest {
    source: SourceInput;
    storageType?: StorageInputType;
    targets: TargetInput[];
}

// @public
export interface CancelTranslationOptionalParams extends OperationOptions {
}

// @public
export type ContinuablePage<TElement, TPage = TElement[]> = TPage & {
    continuationToken?: string;
};

// @public
export interface DocumentFilter {
    prefix?: string;
    suffix?: string;
}

// @public
export interface DocumentStatus {
    characterCharged?: number;
    createdDateTimeUtc: Date;
    error?: TranslationError;
    id: string;
    lastActionDateTimeUtc: Date;
    path?: string;
    progress: number;
    sourcePath: string;
    status: Status;
    to: string;
    totalImageScansFailed?: number;
    totalImageScansSucceeded?: number;
}

// @public
export interface DocumentTranslateContent {
    document: FileContents | {
        contents: FileContents;
        contentType?: string;
        filename?: string;
    };
    glossary?: Array<FileContents | {
        contents: FileContents;
        contentType?: string;
        filename?: string;
    }>;
}

// @public (undocumented)
export class DocumentTranslationClient {
    constructor(endpointParam: string, credential: KeyCredential | TokenCredential, options?: DocumentTranslationClientOptionalParams);
    cancelTranslation(translationId: string, options?: CancelTranslationOptionalParams): Promise<TranslationStatus>;
    getDocumentsStatus(translationId: string, options?: GetDocumentsStatusOptionalParams): PagedAsyncIterableIterator<DocumentStatus>;
    getDocumentStatus(translationId: string, documentId: string, options?: GetDocumentStatusOptionalParams): Promise<DocumentStatus>;
    getSupportedFormats(options?: GetSupportedFormatsOptionalParams): Promise<SupportedFileFormats>;
    getTranslationsStatus(options?: GetTranslationsStatusOptionalParams): PagedAsyncIterableIterator<TranslationStatus>;
    getTranslationStatus(translationId: string, options?: GetTranslationStatusOptionalParams): Promise<TranslationStatus>;
    readonly pipeline: Pipeline;
    startTranslation(body: StartTranslationDetails, options?: StartTranslationOptionalParams): PollerLike<OperationState<TranslationStatus>, TranslationStatus>;
}

// @public
export interface DocumentTranslationClientOptionalParams extends ClientOptions {
    apiVersion?: string;
}

// @public
export type FileContents = string | NodeJS.ReadableStream | ReadableStream<Uint8Array> | Uint8Array | Blob;

// @public
export interface FileFormat {
    contentTypes: string[];
    defaultVersion?: string;
    fileExtensions: string[];
    format: string;
    type?: FileFormatType;
    versions?: string[];
}

// @public
export type FileFormatType = "document" | "glossary";

// @public
export interface GetDocumentsStatusOptionalParams extends OperationOptions {
    createdDateTimeUtcEnd?: Date;
    createdDateTimeUtcStart?: Date;
    documentIds?: string[];
    maxpagesize?: number;
    orderby?: string[];
    skip?: number;
    statuses?: string[];
    top?: number;
}

// @public
export interface GetDocumentStatusOptionalParams extends OperationOptions {
}

// @public
export interface GetSupportedFormatsOptionalParams extends OperationOptions {
    typeParam?: FileFormatType;
}

// @public
export interface GetTranslationsStatusOptionalParams extends OperationOptions {
    createdDateTimeUtcEnd?: Date;
    createdDateTimeUtcStart?: Date;
    maxpagesize?: number;
    orderby?: string[];
    skip?: number;
    statuses?: string[];
    top?: number;
    translationIds?: string[];
}

// @public
export interface GetTranslationStatusOptionalParams extends OperationOptions {
}

// @public
export interface Glossary {
    format: string;
    glossaryUrl: string;
    storageSource?: TranslationStorageSource;
    version?: string;
}

// @public
export interface InnerTranslationError {
    code: string;
    innerError?: InnerTranslationError;
    message: string;
    readonly target?: string;
}

// @public
export enum KnownVersions {
    V20240501 = "2024-05-01",
    V20241101Preview = "2024-11-01-preview"
}

// @public
export interface PagedAsyncIterableIterator<TElement, TPage = TElement[], TPageSettings extends PageSettings = PageSettings> {
    [Symbol.asyncIterator](): PagedAsyncIterableIterator<TElement, TPage, TPageSettings>;
    byPage: (settings?: TPageSettings) => AsyncIterableIterator<ContinuablePage<TElement, TPage>>;
    next(): Promise<IteratorResult<TElement>>;
}

// @public
export interface PageSettings {
    continuationToken?: string;
}

// @public
export function restorePoller<TResponse extends PathUncheckedResponse, TResult>(client: DocumentTranslationClient, serializedState: string, sourceOperation: (...args: any[]) => PollerLike<OperationState<TResult>, TResult>, options?: RestorePollerOptions<TResult>): PollerLike<OperationState<TResult>, TResult>;

// @public (undocumented)
export interface RestorePollerOptions<TResult, TResponse extends PathUncheckedResponse = PathUncheckedResponse> extends OperationOptions {
    abortSignal?: AbortSignalLike;
    processResponseBody?: (result: TResponse) => Promise<TResult>;
    updateIntervalInMs?: number;
}

// @public (undocumented)
export class SingleDocumentTranslationClient {
    constructor(endpointParam: string, credential: KeyCredential | TokenCredential, options?: SingleDocumentTranslationClientOptionalParams);
    readonly pipeline: Pipeline;
    translate(targetLanguage: string, body: DocumentTranslateContent, options?: TranslateOptionalParams): Promise<Uint8Array>;
}

// @public
export interface SingleDocumentTranslationClientOptionalParams extends ClientOptions {
    apiVersion?: string;
}

// @public
export interface SourceInput {
    filter?: DocumentFilter;
    language?: string;
    sourceUrl: string;
    storageSource?: TranslationStorageSource;
}

// @public
export interface StartTranslationDetails {
    inputs: BatchRequest[];
    options?: BatchOptions;
}

// @public
export interface StartTranslationOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export type Status = "NotStarted" | "Running" | "Succeeded" | "Failed" | "Cancelled" | "Cancelling" | "ValidationFailed";

// @public
export type StorageInputType = "Folder" | "File";

// @public
export interface SupportedFileFormats {
    value: FileFormat[];
}

// @public
export interface TargetInput {
    category?: string;
    glossaries?: Glossary[];
    language: string;
    storageSource?: TranslationStorageSource;
    targetUrl: string;
}

// @public
export interface TranslateOptionalParams extends OperationOptions {
    allowFallback?: boolean;
    category?: string;
    clientRequestId?: string;
    sourceLanguage?: string;
    translateTextWithinImage?: boolean;
}

// @public
export interface TranslationError {
    code: TranslationErrorCode;
    innerError?: InnerTranslationError;
    message: string;
    readonly target?: string;
}

// @public
export type TranslationErrorCode = "InvalidRequest" | "InvalidArgument" | "InternalServerError" | "ServiceUnavailable" | "ResourceNotFound" | "Unauthorized" | "RequestRateTooHigh";

// @public
export interface TranslationStatus {
    createdDateTimeUtc: Date;
    error?: TranslationError;
    id: string;
    lastActionDateTimeUtc: Date;
    status: Status;
    summary: TranslationStatusSummary;
}

// @public
export interface TranslationStatusSummary {
    cancelled: number;
    failed: number;
    inProgress: number;
    notYetStarted: number;
    success: number;
    total: number;
    totalCharacterCharged: number;
    totalImageScansFailed?: number;
    totalImageScansSucceeded?: number;
}

// @public
export type TranslationStorageSource = "AzureBlob";

// (No @packageDocumentation comment for this package)

```
