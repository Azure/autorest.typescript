## API Report File for "@azure-rest/azure-search-documents-rest"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ClientOptions } from '@azure-rest/core-client';
import { KeyCredential } from '@azure/core-auth';
import { OperationOptions } from '@azure-rest/core-client';
import { Pipeline } from '@azure/core-rest-pipeline';
import { TokenCredential } from '@azure/core-auth';

// @public
export type AIFoundryModelCatalogName = "OpenAI-CLIP-Image-Text-Embeddings-vit-base-patch32" | "OpenAI-CLIP-Image-Text-Embeddings-ViT-Large-Patch14-336" | "Facebook-DinoV2-Image-Embeddings-ViT-Base" | "Facebook-DinoV2-Image-Embeddings-ViT-Giant" | "Cohere-embed-v3-english" | "Cohere-embed-v3-multilingual";

// @public
export interface AIServicesAccountIdentity extends CognitiveServicesAccount {
    identity?: SearchIndexerDataIdentityUnion;
    odataType: "#Microsoft.Azure.Search.AIServicesByIdentity";
    subdomainUrl: string;
}

// @public
export interface AIServicesAccountKey extends CognitiveServicesAccount {
    key: string;
    odataType: "#Microsoft.Azure.Search.AIServicesByKey";
    subdomainUrl: string;
}

// @public
export interface AIServicesVisionParameters {
    apiKey?: string;
    authIdentity?: SearchIndexerDataIdentityUnion;
    modelVersion: string;
    resourceUri: string;
}

// @public
export interface AIServicesVisionVectorizer extends VectorSearchVectorizer {
    aiServicesVisionParameters?: AIServicesVisionParameters;
    kind: "aiServicesVision";
}

// @public
export interface AliasesCreateOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface AliasesCreateOrUpdateOptionalParams extends OperationOptions {
    clientRequestId?: string;
    ifMatch?: string;
    ifNoneMatch?: string;
}

// @public
export interface AliasesDeleteOptionalParams extends OperationOptions {
    clientRequestId?: string;
    ifMatch?: string;
    ifNoneMatch?: string;
}

// @public
export interface AliasesGetOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface AliasesListOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface AliasesOperations {
    create: (alias: SearchAlias, options?: AliasesCreateOptionalParams) => Promise<SearchAlias>;
    createOrUpdate: (alias: SearchAlias, aliasName: string, options?: AliasesCreateOrUpdateOptionalParams) => Promise<SearchAlias>;
    delete: (aliasName: string, options?: AliasesDeleteOptionalParams) => Promise<void>;
    get: (aliasName: string, options?: AliasesGetOptionalParams) => Promise<SearchAlias>;
    list: (options?: AliasesListOptionalParams) => PagedAsyncIterableIterator<SearchAlias>;
}

// @public
export interface AnalyzedTokenInfo {
    endOffset: number;
    position: number;
    startOffset: number;
    token: string;
}

// @public
export interface AnalyzeRequest {
    analyzer?: LexicalAnalyzerName;
    charFilters?: CharFilterName[];
    normalizer?: LexicalNormalizerName;
    text: string;
    tokenFilters?: TokenFilterName[];
    tokenizer?: LexicalTokenizerName;
}

// @public
export interface AnalyzeResult {
    tokens: AnalyzedTokenInfo[];
}

// @public
export interface AsciiFoldingTokenFilter extends TokenFilter {
    odataType: "#Microsoft.Azure.Search.AsciiFoldingTokenFilter";
    preserveOriginal?: boolean;
}

// @public
export interface AutocompleteItem {
    queryPlusText: string;
    text: string;
}

// @public
export type AutocompleteMode = "oneTerm" | "twoTerms" | "oneTermWithContext";

// @public
export interface AutocompleteRequest {
    autocompleteMode?: AutocompleteMode;
    filter?: string;
    highlightPostTag?: string;
    highlightPreTag?: string;
    minimumCoverage?: number;
    searchFields?: string;
    searchText: string;
    suggesterName: string;
    top?: number;
    useFuzzyMatching?: boolean;
}

// @public
export interface AutocompleteResult {
    coverage?: number;
    results: AutocompleteItem[];
}

// @public
export interface AzureActiveDirectoryApplicationCredentials {
    applicationId: string;
    applicationSecret?: string;
}

// @public
export interface AzureMachineLearningParameters {
    authenticationKey?: string;
    modelName?: AIFoundryModelCatalogName;
    region?: string;
    resourceId?: string;
    scoringUri: string;
    timeout?: string;
}

// @public
export interface AzureMachineLearningSkill extends SearchIndexerSkill {
    authenticationKey?: string;
    degreeOfParallelism?: number;
    odataType: "#Microsoft.Skills.Custom.AmlSkill";
    region?: string;
    resourceId?: string;
    scoringUri?: string;
    timeout?: string;
}

// @public
export interface AzureMachineLearningVectorizer extends VectorSearchVectorizer {
    amlParameters?: AzureMachineLearningParameters;
    kind: "aml";
}

// @public
export interface AzureOpenAIEmbeddingSkill extends SearchIndexerSkill {
    apiKey?: string;
    authIdentity?: SearchIndexerDataIdentityUnion;
    deploymentName?: string;
    dimensions?: number;
    modelName?: AzureOpenAIModelName;
    odataType: "#Microsoft.Skills.Text.AzureOpenAIEmbeddingSkill";
    resourceUrl?: string;
}

// @public
export type AzureOpenAIModelName = "text-embedding-ada-002" | "text-embedding-3-large" | "text-embedding-3-small";

// @public
export interface AzureOpenAITokenizerParameters {
    allowedSpecialTokens?: string[];
    encoderModelName?: SplitSkillEncoderModelName;
}

// @public
export interface AzureOpenAIVectorizer extends VectorSearchVectorizer {
    kind: "azureOpenAI";
    parameters?: AzureOpenAIVectorizerParameters;
}

// @public
export interface AzureOpenAIVectorizerParameters {
    apiKey?: string;
    authIdentity?: SearchIndexerDataIdentityUnion;
    deploymentName?: string;
    modelName?: AzureOpenAIModelName;
    resourceUrl?: string;
}

// @public
export interface BinaryQuantizationCompression extends VectorSearchCompression {
    kind: "binaryQuantization";
}

// @public
export type BlobIndexerDataToExtract = "storageMetadata" | "allMetadata" | "contentAndMetadata";

// @public
export type BlobIndexerImageAction = "none" | "generateNormalizedImages" | "generateNormalizedImagePerPage";

// @public
export type BlobIndexerParsingMode = "default" | "text" | "delimitedText" | "json" | "jsonArray" | "jsonLines" | "markdown";

// @public
export type BlobIndexerPDFTextRotationAlgorithm = "none" | "detectAngles";

// @public
export interface BM25SimilarityAlgorithm extends SimilarityAlgorithm {
    b?: number;
    k1?: number;
    odataType: "#Microsoft.Azure.Search.BM25Similarity";
}

// @public
export interface CharFilter {
    name: string;
    odataType: string;
}

// @public
export type CharFilterName = "html_strip";

// @public
export type CharFilterUnion = MappingCharFilter | PatternReplaceCharFilter | CharFilter;

// @public
export interface CjkBigramTokenFilter extends TokenFilter {
    ignoreScripts?: CjkBigramTokenFilterScripts[];
    odataType: "#Microsoft.Azure.Search.CjkBigramTokenFilter";
    outputUnigrams?: boolean;
}

// @public
export type CjkBigramTokenFilterScripts = "han" | "hiragana" | "katakana" | "hangul";

// @public
export interface ClassicSimilarityAlgorithm extends SimilarityAlgorithm {
    odataType: "#Microsoft.Azure.Search.ClassicSimilarity";
}

// @public
export interface ClassicTokenizer extends LexicalTokenizer {
    maxTokenLength?: number;
    odataType: "#Microsoft.Azure.Search.ClassicTokenizer";
}

// @public
export interface CognitiveServicesAccount {
    description?: string;
    odataType: string;
}

// @public
export interface CognitiveServicesAccountKey extends CognitiveServicesAccount {
    key: string;
    odataType: "#Microsoft.Azure.Search.CognitiveServicesByKey";
}

// @public
export type CognitiveServicesAccountUnion = DefaultCognitiveServicesAccount | CognitiveServicesAccountKey | AIServicesAccountKey | AIServicesAccountIdentity | CognitiveServicesAccount;

// @public
export interface CommonGramTokenFilter extends TokenFilter {
    commonWords: string[];
    ignoreCase?: boolean;
    odataType: "#Microsoft.Azure.Search.CommonGramTokenFilter";
    useQueryMode?: boolean;
}

// @public
export interface ConditionalSkill extends SearchIndexerSkill {
    odataType: "#Microsoft.Skills.Util.ConditionalSkill";
}

// @public
export type ContinuablePage<TElement, TPage = TElement[]> = TPage & {
    continuationToken?: string;
};

// @public
export interface CorsOptions {
    allowedOrigins: string[];
    maxAgeInSeconds?: number;
}

// @public
export interface CustomAnalyzer extends LexicalAnalyzer {
    charFilters?: CharFilterName[];
    odataType: "#Microsoft.Azure.Search.CustomAnalyzer";
    tokenFilters?: TokenFilterName[];
    tokenizer: LexicalTokenizerName;
}

// @public
export interface CustomEntity {
    accentSensitive?: boolean;
    aliases?: CustomEntityAlias[];
    caseSensitive?: boolean;
    defaultAccentSensitive?: boolean;
    defaultCaseSensitive?: boolean;
    defaultFuzzyEditDistance?: number;
    description?: string;
    fuzzyEditDistance?: number;
    id?: string;
    name: string;
    subtype?: string;
    type?: string;
}

// @public
export interface CustomEntityAlias {
    accentSensitive?: boolean;
    caseSensitive?: boolean;
    fuzzyEditDistance?: number;
    text: string;
}

// @public
export interface CustomEntityLookupSkill extends SearchIndexerSkill {
    defaultLanguageCode?: CustomEntityLookupSkillLanguage;
    entitiesDefinitionUri?: string;
    globalDefaultAccentSensitive?: boolean;
    globalDefaultCaseSensitive?: boolean;
    globalDefaultFuzzyEditDistance?: number;
    inlineEntitiesDefinition?: CustomEntity[];
    odataType: "#Microsoft.Skills.Text.CustomEntityLookupSkill";
}

// @public
export type CustomEntityLookupSkillLanguage = "da" | "de" | "en" | "es" | "fi" | "fr" | "it" | "ko" | "pt";

// @public
export interface CustomNormalizer extends LexicalNormalizer {
    charFilters?: CharFilterName[];
    odataType: "#Microsoft.Azure.Search.CustomNormalizer";
    tokenFilters?: TokenFilterName[];
}

// @public
export interface DataChangeDetectionPolicy {
    odataType: string;
}

// @public
export type DataChangeDetectionPolicyUnion = HighWaterMarkChangeDetectionPolicy | SqlIntegratedChangeTrackingPolicy | DataChangeDetectionPolicy;

// @public
export interface DataDeletionDetectionPolicy {
    odataType: string;
}

// @public
export type DataDeletionDetectionPolicyUnion = SoftDeleteColumnDeletionDetectionPolicy | NativeBlobSoftDeleteDeletionDetectionPolicy | DataDeletionDetectionPolicy;

// @public
export interface DataSourceCredentials {
    connectionString?: string;
}

// @public
export interface DataSourcesCreateOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface DataSourcesCreateOrUpdateOptionalParams extends OperationOptions {
    clientRequestId?: string;
    ifMatch?: string;
    ifNoneMatch?: string;
    skipIndexerResetRequirementForCache?: boolean;
}

// @public
export interface DataSourcesDeleteOptionalParams extends OperationOptions {
    clientRequestId?: string;
    ifMatch?: string;
    ifNoneMatch?: string;
}

// @public
export interface DataSourcesGetOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface DataSourcesListOptionalParams extends OperationOptions {
    clientRequestId?: string;
    select?: string;
}

// @public
export interface DataSourcesOperations {
    create: (dataSource: SearchIndexerDataSource, options?: DataSourcesCreateOptionalParams) => Promise<SearchIndexerDataSource>;
    createOrUpdate: (dataSource: SearchIndexerDataSource, dataSourceName: string, options?: DataSourcesCreateOrUpdateOptionalParams) => Promise<SearchIndexerDataSource>;
    delete: (dataSourceName: string, options?: DataSourcesDeleteOptionalParams) => Promise<void>;
    get: (dataSourceName: string, options?: DataSourcesGetOptionalParams) => Promise<SearchIndexerDataSource>;
    list: (options?: DataSourcesListOptionalParams) => Promise<ListDataSourcesResult>;
}

// @public
export interface DebugInfo {
    readonly queryRewrites?: QueryRewritesDebugInfo;
}

// @public
export interface DefaultCognitiveServicesAccount extends CognitiveServicesAccount {
    odataType: "#Microsoft.Azure.Search.DefaultCognitiveServices";
}

// @public
export interface DictionaryDecompounderTokenFilter extends TokenFilter {
    maxSubwordSize?: number;
    minSubwordSize?: number;
    minWordSize?: number;
    odataType: "#Microsoft.Azure.Search.DictionaryDecompounderTokenFilter";
    onlyLongestMatch?: boolean;
    wordList: string[];
}

// @public
export interface DistanceScoringFunction extends ScoringFunction {
    parameters: DistanceScoringParameters;
    type: "distance";
}

// @public
export interface DistanceScoringParameters {
    boostingDistance: number;
    referencePointParameter: string;
}

// @public
export interface DocumentDebugInfo {
    readonly semantic?: SemanticDebugInfo;
    readonly vectors?: VectorsDebugInfo;
}

// @public
export interface DocumentExtractionSkill extends SearchIndexerSkill {
    configuration?: Record<string, any>;
    dataToExtract?: string;
    odataType: "#Microsoft.Skills.Util.DocumentExtractionSkill";
    parsingMode?: string;
}

// @public
export interface DocumentIntelligenceLayoutSkill extends SearchIndexerSkill {
    markdownHeaderDepth?: DocumentIntelligenceLayoutSkillMarkdownHeaderDepth;
    odataType: "#Microsoft.Skills.Util.DocumentIntelligenceLayoutSkill";
    outputMode?: DocumentIntelligenceLayoutSkillOutputMode;
}

// @public
export type DocumentIntelligenceLayoutSkillMarkdownHeaderDepth = "h1" | "h2" | "h3" | "h4" | "h5" | "h6";

// @public
export type DocumentIntelligenceLayoutSkillOutputMode = "oneToMany";

// @public
export interface DocumentKeysOrIds {
    datasourceDocumentIds?: string[];
    documentKeys?: string[];
}

// @public
export interface DocumentsAutocompleteGetOptionalParams extends OperationOptions {
    autocompleteMode?: AutocompleteMode;
    clientRequestId?: string;
    filter?: string;
    highlightPostTag?: string;
    highlightPreTag?: string;
    minimumCoverage?: number;
    searchFields?: string[];
    top?: number;
    useFuzzyMatching?: boolean;
}

// @public
export interface DocumentsAutocompletePostOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface DocumentsCountOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface DocumentsGetOptionalParams extends OperationOptions {
    clientRequestId?: string;
    selectedFields?: string[];
}

// @public
export interface DocumentsIndexOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface DocumentsOperations {
    autocompleteGet: (searchText: string, suggesterName: string, indexName: string, options?: DocumentsAutocompleteGetOptionalParams) => Promise<AutocompleteResult>;
    autocompletePost: (autocompleteRequest: AutocompleteRequest, indexName: string, options?: DocumentsAutocompletePostOptionalParams) => Promise<AutocompleteResult>;
    count: (indexName: string, options?: DocumentsCountOptionalParams) => Promise<number>;
    get: (key: string, indexName: string, options?: DocumentsGetOptionalParams) => Promise<LookupDocument>;
    index: (batch: IndexBatch, indexName: string, options?: DocumentsIndexOptionalParams) => Promise<IndexDocumentsResult>;
    searchGet: (indexName: string, options?: DocumentsSearchGetOptionalParams) => Promise<SearchDocumentsResult>;
    searchPost: (searchRequest: SearchRequest, indexName: string, options?: DocumentsSearchPostOptionalParams) => Promise<SearchDocumentsResult>;
    suggestGet: (searchText: string, suggesterName: string, indexName: string, options?: DocumentsSuggestGetOptionalParams) => Promise<SuggestDocumentsResult>;
    suggestPost: (suggestRequest: SuggestRequest, indexName: string, options?: DocumentsSuggestPostOptionalParams) => Promise<SuggestDocumentsResult>;
}

// @public
export interface DocumentsSearchGetOptionalParams extends OperationOptions {
    answers?: QueryAnswerType;
    captions?: QueryCaptionType;
    clientRequestId?: string;
    debug?: QueryDebugMode;
    facets?: string[];
    filter?: string;
    highlightFields?: string[];
    highlightPostTag?: string;
    highlightPreTag?: string;
    includeTotalResultCount?: boolean;
    minimumCoverage?: number;
    orderBy?: string[];
    queryLanguage?: QueryLanguage;
    queryRewrites?: QueryRewritesType;
    queryType?: QueryType;
    scoringParameters?: string[];
    scoringProfile?: string;
    scoringStatistics?: ScoringStatistics;
    searchFields?: string[];
    searchMode?: SearchMode;
    searchText?: string;
    select?: string[];
    semanticConfiguration?: string;
    semanticErrorHandling?: SemanticErrorMode;
    semanticFields?: string[];
    semanticMaxWaitInMilliseconds?: number;
    semanticQuery?: string;
    sessionId?: string;
    skip?: number;
    speller?: QuerySpellerType;
    top?: number;
}

// @public
export interface DocumentsSearchPostOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface DocumentsSuggestGetOptionalParams extends OperationOptions {
    clientRequestId?: string;
    filter?: string;
    highlightPostTag?: string;
    highlightPreTag?: string;
    minimumCoverage?: number;
    orderBy?: string[];
    searchFields?: string[];
    select?: string[];
    top?: number;
    useFuzzyMatching?: boolean;
}

// @public
export interface DocumentsSuggestPostOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export type EdgeNGramTokenFilterSide = "front" | "back";

// @public
export interface EdgeNGramTokenFilterV2 extends TokenFilter {
    maxGram?: number;
    minGram?: number;
    odataType: "#Microsoft.Azure.Search.EdgeNGramTokenFilterV2";
    side?: EdgeNGramTokenFilterSide;
}

// @public
export interface EdgeNGramTokenizer extends LexicalTokenizer {
    maxGram?: number;
    minGram?: number;
    odataType: "#Microsoft.Azure.Search.EdgeNGramTokenizer";
    tokenChars?: TokenCharacterKind[];
}

// @public
export interface ElisionTokenFilter extends TokenFilter {
    articles?: string[];
    odataType: "#Microsoft.Azure.Search.ElisionTokenFilter";
}

// @public
export type EntityCategory = "location" | "organization" | "person" | "quantity" | "datetime" | "url" | "email";

// @public
export interface EntityLinkingSkill extends SearchIndexerSkill {
    defaultLanguageCode?: string;
    minimumPrecision?: number;
    modelVersion?: string;
    odataType: "#Microsoft.Skills.Text.V3.EntityLinkingSkill";
}

// @public
export interface EntityRecognitionSkill extends SearchIndexerSkill {
    categories?: EntityCategory[];
    defaultLanguageCode?: EntityRecognitionSkillLanguage;
    includeTypelessEntities?: boolean;
    minimumPrecision?: number;
    odataType: "#Microsoft.Skills.Text.EntityRecognitionSkill";
}

// @public
export type EntityRecognitionSkillLanguage = "ar" | "cs" | "zh-Hans" | "zh-Hant" | "da" | "nl" | "en" | "fi" | "fr" | "de" | "el" | "hu" | "it" | "ja" | "ko" | "no" | "pl" | "pt-PT" | "pt-BR" | "ru" | "es" | "sv" | "tr";

// @public
export interface EntityRecognitionSkillV3 extends SearchIndexerSkill {
    categories?: string[];
    defaultLanguageCode?: string;
    minimumPrecision?: number;
    modelVersion?: string;
    odataType: "#Microsoft.Skills.Text.V3.EntityRecognitionSkill";
}

// @public
export interface ErrorAdditionalInfo {
    info?: Record<string, string>;
    type?: string;
}

// @public
export interface ErrorDetail {
    additionalInfo?: ErrorAdditionalInfo[];
    code?: string;
    details?: ErrorDetail[];
    message?: string;
    target?: string;
}

// @public
export interface ErrorResponse {
    error?: ErrorDetail;
}

// @public
export interface ExhaustiveKnnAlgorithmConfiguration extends VectorSearchAlgorithmConfiguration {
    kind: "exhaustiveKnn";
    parameters?: ExhaustiveKnnParameters;
}

// @public
export interface ExhaustiveKnnParameters {
    metric?: VectorSearchAlgorithmMetric;
}

// @public
export interface FacetResult {
    additionalProperties?: Record<string, any>;
    count?: number;
    readonly facets?: Record<string, FacetResult[]>;
    readonly sum?: number;
}

// @public
export interface FieldMapping {
    mappingFunction?: FieldMappingFunction;
    sourceFieldName: string;
    targetFieldName?: string;
}

// @public
export interface FieldMappingFunction {
    name: string;
    parameters?: Record<string, any>;
}

// @public
export interface FreshnessScoringFunction extends ScoringFunction {
    parameters: FreshnessScoringParameters;
    type: "freshness";
}

// @public
export interface FreshnessScoringParameters {
    boostingDuration: string;
}

// @public
export interface GetIndexStatisticsResult {
    documentCount: number;
    storageSize: number;
    vectorIndexSize: number;
}

// @public
export interface GetIndexStatsSummaryOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface GetServiceStatisticsOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface HighWaterMarkChangeDetectionPolicy extends DataChangeDetectionPolicy {
    highWaterMarkColumnName: string;
    odataType: "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy";
}

// @public
export interface HnswAlgorithmConfiguration extends VectorSearchAlgorithmConfiguration {
    kind: "hnsw";
    parameters?: HnswParameters;
}

// @public
export interface HnswParameters {
    efConstruction?: number;
    efSearch?: number;
    m?: number;
    metric?: VectorSearchAlgorithmMetric;
}

// @public
export type HybridCountAndFacetMode = "countRetrievableResults" | "countAllResults";

// @public
export interface HybridSearch {
    countAndFacetMode?: HybridCountAndFacetMode;
    maxTextRecallSize?: number;
}

// @public
export interface ImageAnalysisSkill extends SearchIndexerSkill {
    defaultLanguageCode?: ImageAnalysisSkillLanguage;
    details?: ImageDetail[];
    odataType: "#Microsoft.Skills.Vision.ImageAnalysisSkill";
    visualFeatures?: VisualFeature[];
}

// @public
export type ImageAnalysisSkillLanguage = "ar" | "az" | "bg" | "bs" | "ca" | "cs" | "cy" | "da" | "de" | "el" | "en" | "es" | "et" | "eu" | "fi" | "fr" | "ga" | "gl" | "he" | "hi" | "hr" | "hu" | "id" | "it" | "ja" | "kk" | "ko" | "lt" | "lv" | "mk" | "ms" | "nb" | "nl" | "pl" | "prs" | "pt-BR" | "pt" | "pt-PT" | "ro" | "ru" | "sk" | "sl" | "sr-Cyrl" | "sr-Latn" | "sv" | "th" | "tr" | "uk" | "vi" | "zh" | "zh-Hans" | "zh-Hant";

// @public
export type ImageDetail = "celebrities" | "landmarks";

// @public
export interface IndexAction {
    actionType?: IndexActionType;
    additionalProperties?: Record<string, any>;
}

// @public
export type IndexActionType = "upload" | "merge" | "mergeOrUpload" | "delete";

// @public
export interface IndexBatch {
    actions: IndexAction[];
}

// @public
export interface IndexDocumentsResult {
    results: IndexingResult[];
}

// @public
export interface IndexerCurrentState {
    readonly allDocsFinalChangeTrackingState?: string;
    readonly allDocsInitialChangeTrackingState?: string;
    readonly mode?: IndexingMode;
    readonly resetDatasourceDocumentIds?: string[];
    readonly resetDocsFinalChangeTrackingState?: string;
    readonly resetDocsInitialChangeTrackingState?: string;
    readonly resetDocumentKeys?: string[];
}

// @public
export type IndexerExecutionEnvironment = "standard" | "private";

// @public
export interface IndexerExecutionResult {
    readonly currentState?: IndexerCurrentState;
    endTime?: Date;
    errorMessage?: string;
    errors: SearchIndexerError[];
    failedItemCount: number;
    finalTrackingState?: string;
    initialTrackingState?: string;
    itemCount: number;
    startTime?: Date;
    status: IndexerExecutionStatus;
    readonly statusDetail?: IndexerExecutionStatusDetail;
    warnings: SearchIndexerWarning[];
}

// @public
export type IndexerExecutionStatus = "transientFailure" | "success" | "inProgress" | "reset";

// @public
export type IndexerExecutionStatusDetail = "resetDocs";

// @public
export interface IndexersCreateOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface IndexersCreateOrUpdateOptionalParams extends OperationOptions {
    clientRequestId?: string;
    disableCacheReprocessingChangeDetection?: boolean;
    ifMatch?: string;
    ifNoneMatch?: string;
    skipIndexerResetRequirementForCache?: boolean;
}

// @public
export interface IndexersDeleteOptionalParams extends OperationOptions {
    clientRequestId?: string;
    ifMatch?: string;
    ifNoneMatch?: string;
}

// @public
export interface IndexersGetOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface IndexersGetStatusOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface IndexersListOptionalParams extends OperationOptions {
    clientRequestId?: string;
    select?: string;
}

// @public
export interface IndexersOperations {
    create: (indexer: SearchIndexer, options?: IndexersCreateOptionalParams) => Promise<SearchIndexer>;
    createOrUpdate: (indexer: SearchIndexer, indexerName: string, options?: IndexersCreateOrUpdateOptionalParams) => Promise<SearchIndexer>;
    delete: (indexerName: string, options?: IndexersDeleteOptionalParams) => Promise<void>;
    get: (indexerName: string, options?: IndexersGetOptionalParams) => Promise<SearchIndexer>;
    getStatus: (indexerName: string, options?: IndexersGetStatusOptionalParams) => Promise<SearchIndexerStatus>;
    list: (options?: IndexersListOptionalParams) => Promise<ListIndexersResult>;
    reset: (indexerName: string, options?: IndexersResetOptionalParams) => Promise<void>;
    resetDocs: (indexerName: string, options?: IndexersResetDocsOptionalParams) => Promise<void>;
    run: (indexerName: string, options?: IndexersRunOptionalParams) => Promise<void>;
}

// @public
export interface IndexersResetDocsOptionalParams extends OperationOptions {
    clientRequestId?: string;
    keysOrIds?: DocumentKeysOrIds;
    overwrite?: boolean;
}

// @public
export interface IndexersResetOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface IndexersRunOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export type IndexerStatus = "unknown" | "error" | "running";

// @public
export interface IndexesAnalyzeOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface IndexesCreateOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface IndexesCreateOrUpdateOptionalParams extends OperationOptions {
    allowIndexDowntime?: boolean;
    clientRequestId?: string;
    ifMatch?: string;
    ifNoneMatch?: string;
}

// @public
export interface IndexesDeleteOptionalParams extends OperationOptions {
    clientRequestId?: string;
    ifMatch?: string;
    ifNoneMatch?: string;
}

// @public
export interface IndexesGetOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface IndexesGetStatisticsOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface IndexesListOptionalParams extends OperationOptions {
    clientRequestId?: string;
    select?: string;
}

// @public
export interface IndexesOperations {
    analyze: (request: AnalyzeRequest, indexName: string, options?: IndexesAnalyzeOptionalParams) => Promise<AnalyzeResult>;
    create: (index: SearchIndex, options?: IndexesCreateOptionalParams) => Promise<SearchIndex>;
    createOrUpdate: (index: SearchIndex, indexName: string, options?: IndexesCreateOrUpdateOptionalParams) => Promise<SearchIndex>;
    delete: (indexName: string, options?: IndexesDeleteOptionalParams) => Promise<void>;
    get: (indexName: string, options?: IndexesGetOptionalParams) => Promise<SearchIndex>;
    getStatistics: (indexName: string, options?: IndexesGetStatisticsOptionalParams) => Promise<GetIndexStatisticsResult>;
    list: (options?: IndexesListOptionalParams) => PagedAsyncIterableIterator<SearchIndex>;
}

// @public
export type IndexingMode = "indexingAllDocs" | "indexingResetDocs";

// @public
export interface IndexingParameters {
    batchSize?: number;
    configuration?: IndexingParametersConfiguration;
    maxFailedItems?: number;
    maxFailedItemsPerBatch?: number;
}

// @public
export interface IndexingParametersConfiguration {
    additionalProperties?: Record<string, any>;
    allowSkillsetToReadFileData?: boolean;
    dataToExtract?: BlobIndexerDataToExtract;
    delimitedTextDelimiter?: string;
    delimitedTextHeaders?: string;
    documentRoot?: string;
    excludedFileNameExtensions?: string;
    executionEnvironment?: IndexerExecutionEnvironment;
    failOnUnprocessableDocument?: boolean;
    failOnUnsupportedContentType?: boolean;
    firstLineContainsHeaders?: boolean;
    imageAction?: BlobIndexerImageAction;
    indexedFileNameExtensions?: string;
    indexStorageMetadataOnlyForOversizedDocuments?: boolean;
    markdownHeaderDepth?: MarkdownHeaderDepth;
    markdownParsingSubmode?: MarkdownParsingSubmode;
    parsingMode?: BlobIndexerParsingMode;
    pdfTextRotationAlgorithm?: BlobIndexerPDFTextRotationAlgorithm;
    queryTimeout?: string;
}

// @public
export interface IndexingResult {
    errorMessage?: string;
    key: string;
    statusCode: number;
    succeeded: boolean;
}

// @public
export interface IndexingSchedule {
    interval: string;
    startTime?: Date;
}

// @public
export type IndexProjectionMode = "skipIndexingParentDocuments" | "includeIndexingParentDocuments";

// @public
export interface IndexStatisticsSummary {
    readonly documentCount: number;
    readonly name: string;
    readonly storageSize: number;
    readonly vectorIndexSize?: number;
}

// @public
export interface InputFieldMappingEntry {
    inputs?: InputFieldMappingEntry[];
    name: string;
    source?: string;
    sourceContext?: string;
}

// @public
export interface KeepTokenFilter extends TokenFilter {
    keepWords: string[];
    lowerCaseKeepWords?: boolean;
    odataType: "#Microsoft.Azure.Search.KeepTokenFilter";
}

// @public
export interface KeyPhraseExtractionSkill extends SearchIndexerSkill {
    defaultLanguageCode?: KeyPhraseExtractionSkillLanguage;
    maxKeyPhraseCount?: number;
    modelVersion?: string;
    odataType: "#Microsoft.Skills.Text.KeyPhraseExtractionSkill";
}

// @public
export type KeyPhraseExtractionSkillLanguage = "da" | "nl" | "en" | "fi" | "fr" | "de" | "it" | "ja" | "ko" | "no" | "pl" | "pt-PT" | "pt-BR" | "ru" | "es" | "sv";

// @public
export interface KeywordMarkerTokenFilter extends TokenFilter {
    ignoreCase?: boolean;
    keywords: string[];
    odataType: "#Microsoft.Azure.Search.KeywordMarkerTokenFilter";
}

// @public
export interface KeywordTokenizerV2 extends LexicalTokenizer {
    maxTokenLength?: number;
    odataType: "#Microsoft.Azure.Search.KeywordTokenizerV2";
}

// @public
export enum KnownVersions {
    V20240701 = "2024-07-01",
    V20250301Preview = "2025-03-01-preview"
}

// @public
export interface LanguageDetectionSkill extends SearchIndexerSkill {
    defaultCountryHint?: string;
    modelVersion?: string;
    odataType: "#Microsoft.Skills.Text.LanguageDetectionSkill";
}

// @public
export interface LengthTokenFilter extends TokenFilter {
    maxLength?: number;
    minLength?: number;
    odataType: "#Microsoft.Azure.Search.LengthTokenFilter";
}

// @public
export interface LexicalAnalyzer {
    name: string;
    odataType: string;
}

// @public
export type LexicalAnalyzerName = "ar.microsoft" | "ar.lucene" | "hy.lucene" | "bn.microsoft" | "eu.lucene" | "bg.microsoft" | "bg.lucene" | "ca.microsoft" | "ca.lucene" | "zh-Hans.microsoft" | "zh-Hans.lucene" | "zh-Hant.microsoft" | "zh-Hant.lucene" | "hr.microsoft" | "cs.microsoft" | "cs.lucene" | "da.microsoft" | "da.lucene" | "nl.microsoft" | "nl.lucene" | "en.microsoft" | "en.lucene" | "et.microsoft" | "fi.microsoft" | "fi.lucene" | "fr.microsoft" | "fr.lucene" | "gl.lucene" | "de.microsoft" | "de.lucene" | "el.microsoft" | "el.lucene" | "gu.microsoft" | "he.microsoft" | "hi.microsoft" | "hi.lucene" | "hu.microsoft" | "hu.lucene" | "is.microsoft" | "id.microsoft" | "id.lucene" | "ga.lucene" | "it.microsoft" | "it.lucene" | "ja.microsoft" | "ja.lucene" | "kn.microsoft" | "ko.microsoft" | "ko.lucene" | "lv.microsoft" | "lv.lucene" | "lt.microsoft" | "ml.microsoft" | "ms.microsoft" | "mr.microsoft" | "nb.microsoft" | "no.lucene" | "fa.lucene" | "pl.microsoft" | "pl.lucene" | "pt-BR.microsoft" | "pt-BR.lucene" | "pt-PT.microsoft" | "pt-PT.lucene" | "pa.microsoft" | "ro.microsoft" | "ro.lucene" | "ru.microsoft" | "ru.lucene" | "sr-cyrillic.microsoft" | "sr-latin.microsoft" | "sk.microsoft" | "sl.microsoft" | "es.microsoft" | "es.lucene" | "sv.microsoft" | "sv.lucene" | "ta.microsoft" | "te.microsoft" | "th.microsoft" | "th.lucene" | "tr.microsoft" | "tr.lucene" | "uk.microsoft" | "ur.microsoft" | "vi.microsoft" | "standard.lucene" | "standardasciifolding.lucene" | "keyword" | "pattern" | "simple" | "stop" | "whitespace";

// @public
export type LexicalAnalyzerUnion = CustomAnalyzer | PatternAnalyzer | LuceneStandardAnalyzer | StopAnalyzer | LexicalAnalyzer;

// @public
export interface LexicalNormalizer {
    name: string;
    odataType: string;
}

// @public
export type LexicalNormalizerName = "asciifolding" | "elision" | "lowercase" | "standard" | "uppercase";

// @public
export type LexicalNormalizerUnion = CustomNormalizer | LexicalNormalizer;

// @public
export interface LexicalTokenizer {
    name: string;
    odataType: string;
}

// @public
export type LexicalTokenizerName = "classic" | "edgeNGram" | "keyword_v2" | "letter" | "lowercase" | "microsoft_language_tokenizer" | "microsoft_language_stemming_tokenizer" | "nGram" | "path_hierarchy_v2" | "pattern" | "standard_v2" | "uax_url_email" | "whitespace";

// @public
export type LexicalTokenizerUnion = ClassicTokenizer | EdgeNGramTokenizer | KeywordTokenizerV2 | MicrosoftLanguageTokenizer | MicrosoftLanguageStemmingTokenizer | NGramTokenizer | PathHierarchyTokenizerV2 | PatternTokenizer | LuceneStandardTokenizerV2 | UaxUrlEmailTokenizer | LexicalTokenizer;

// @public
export interface LimitTokenFilter extends TokenFilter {
    consumeAllTokens?: boolean;
    maxTokenCount?: number;
    odataType: "#Microsoft.Azure.Search.LimitTokenFilter";
}

// @public
export interface ListDataSourcesResult {
    dataSources: SearchIndexerDataSource[];
}

// @public
export interface ListIndexersResult {
    indexers: SearchIndexer[];
}

// @public
export interface ListSkillsetsResult {
    skillsets: SearchIndexerSkillset[];
}

// @public
export interface ListSynonymMapsResult {
    synonymMaps: SynonymMap[];
}

// @public
export interface LookupDocument {
    additionalProperties?: Record<string, any>;
}

// @public
export interface LuceneStandardAnalyzer extends LexicalAnalyzer {
    maxTokenLength?: number;
    odataType: "#Microsoft.Azure.Search.StandardAnalyzer";
    stopwords?: string[];
}

// @public
export interface LuceneStandardTokenizerV2 extends LexicalTokenizer {
    maxTokenLength?: number;
    odataType: "#Microsoft.Azure.Search.StandardTokenizerV2";
}

// @public
export interface MagnitudeScoringFunction extends ScoringFunction {
    parameters: MagnitudeScoringParameters;
    type: "magnitude";
}

// @public
export interface MagnitudeScoringParameters {
    boostingRangeEnd: number;
    boostingRangeStart: number;
    shouldBoostBeyondRangeByConstant?: boolean;
}

// @public
export interface MappingCharFilter extends CharFilter {
    mappings: string[];
    odataType: "#Microsoft.Azure.Search.MappingCharFilter";
}

// @public
export type MarkdownHeaderDepth = "h1" | "h2" | "h3" | "h4" | "h5" | "h6";

// @public
export type MarkdownParsingSubmode = "oneToMany" | "oneToOne";

// @public
export interface MergeSkill extends SearchIndexerSkill {
    insertPostTag?: string;
    insertPreTag?: string;
    odataType: "#Microsoft.Skills.Text.MergeSkill";
}

// @public
export interface MicrosoftLanguageStemmingTokenizer extends LexicalTokenizer {
    isSearchTokenizer?: boolean;
    language?: MicrosoftStemmingTokenizerLanguage;
    maxTokenLength?: number;
    odataType: "#Microsoft.Azure.Search.MicrosoftLanguageStemmingTokenizer";
}

// @public
export interface MicrosoftLanguageTokenizer extends LexicalTokenizer {
    isSearchTokenizer?: boolean;
    language?: MicrosoftTokenizerLanguage;
    maxTokenLength?: number;
    odataType: "#Microsoft.Azure.Search.MicrosoftLanguageTokenizer";
}

// @public
export type MicrosoftStemmingTokenizerLanguage = "arabic" | "bangla" | "bulgarian" | "catalan" | "croatian" | "czech" | "danish" | "dutch" | "english" | "estonian" | "finnish" | "french" | "german" | "greek" | "gujarati" | "hebrew" | "hindi" | "hungarian" | "icelandic" | "indonesian" | "italian" | "kannada" | "latvian" | "lithuanian" | "malay" | "malayalam" | "marathi" | "norwegianBokmaal" | "polish" | "portuguese" | "portugueseBrazilian" | "punjabi" | "romanian" | "russian" | "serbianCyrillic" | "serbianLatin" | "slovak" | "slovenian" | "spanish" | "swedish" | "tamil" | "telugu" | "turkish" | "ukrainian" | "urdu";

// @public
export type MicrosoftTokenizerLanguage = "bangla" | "bulgarian" | "catalan" | "chineseSimplified" | "chineseTraditional" | "croatian" | "czech" | "danish" | "dutch" | "english" | "french" | "german" | "greek" | "gujarati" | "hindi" | "icelandic" | "indonesian" | "italian" | "japanese" | "kannada" | "korean" | "malay" | "malayalam" | "marathi" | "norwegianBokmaal" | "polish" | "portuguese" | "portugueseBrazilian" | "punjabi" | "romanian" | "russian" | "serbianCyrillic" | "serbianLatin" | "slovenian" | "spanish" | "swedish" | "tamil" | "telugu" | "thai" | "ukrainian" | "urdu" | "vietnamese";

// @public
export interface NativeBlobSoftDeleteDeletionDetectionPolicy extends DataDeletionDetectionPolicy {
    odataType: "#Microsoft.Azure.Search.NativeBlobSoftDeleteDeletionDetectionPolicy";
}

// @public
export interface NGramTokenFilterV2 extends TokenFilter {
    maxGram?: number;
    minGram?: number;
    odataType: "#Microsoft.Azure.Search.NGramTokenFilterV2";
}

// @public
export interface NGramTokenizer extends LexicalTokenizer {
    maxGram?: number;
    minGram?: number;
    odataType: "#Microsoft.Azure.Search.NGramTokenizer";
    tokenChars?: TokenCharacterKind[];
}

// @public
export type OcrLineEnding = "space" | "carriageReturn" | "lineFeed" | "carriageReturnLineFeed";

// @public
export interface OcrSkill extends SearchIndexerSkill {
    defaultLanguageCode?: OcrSkillLanguage;
    lineEnding?: OcrLineEnding;
    odataType: "#Microsoft.Skills.Vision.OcrSkill";
    shouldDetectOrientation?: boolean;
}

// @public
export type OcrSkillLanguage = "af" | "sq" | "anp" | "ar" | "ast" | "awa" | "az" | "bfy" | "eu" | "be" | "be-cyrl" | "be-latn" | "bho" | "bi" | "brx" | "bs" | "bra" | "br" | "bg" | "bns" | "bua" | "ca" | "ceb" | "rab" | "ch" | "hne" | "zh-Hans" | "zh-Hant" | "kw" | "co" | "crh" | "hr" | "cs" | "da" | "prs" | "dhi" | "doi" | "nl" | "en" | "myv" | "et" | "fo" | "fj" | "fil" | "fi" | "fr" | "fur" | "gag" | "gl" | "de" | "gil" | "gon" | "el" | "kl" | "gvr" | "ht" | "hlb" | "hni" | "bgc" | "haw" | "hi" | "mww" | "hoc" | "hu" | "is" | "smn" | "id" | "ia" | "iu" | "ga" | "it" | "ja" | "Jns" | "jv" | "kea" | "kac" | "xnr" | "krc" | "kaa-cyrl" | "kaa" | "csb" | "kk-cyrl" | "kk-latn" | "klr" | "kha" | "quc" | "ko" | "kfq" | "kpy" | "kos" | "kum" | "ku-arab" | "ku-latn" | "kru" | "ky" | "lkt" | "la" | "lt" | "dsb" | "smj" | "lb" | "bfz" | "ms" | "mt" | "kmj" | "gv" | "mi" | "mr" | "mn" | "cnr-cyrl" | "cnr-latn" | "nap" | "ne" | "niu" | "nog" | "sme" | "nb" | "no" | "oc" | "os" | "ps" | "fa" | "pl" | "pt" | "pa" | "ksh" | "ro" | "rm" | "ru" | "sck" | "sm" | "sa" | "sat" | "sco" | "gd" | "sr" | "sr-Cyrl" | "sr-Latn" | "xsr" | "srx" | "sms" | "sk" | "sl" | "so" | "sma" | "es" | "sw" | "sv" | "tg" | "tt" | "tet" | "thf" | "to" | "tr" | "tk" | "tyv" | "hsb" | "ur" | "ug" | "uz-arab" | "uz-cyrl" | "uz" | "vo" | "wae" | "cy" | "fy" | "yua" | "za" | "zu" | "unk";

// @public
export interface OutputFieldMappingEntry {
    name: string;
    targetName?: string;
}

// @public
export interface PagedAsyncIterableIterator<TElement, TPage = TElement[], TPageSettings extends PageSettings = PageSettings> {
    [Symbol.asyncIterator](): PagedAsyncIterableIterator<TElement, TPage, TPageSettings>;
    byPage: (settings?: TPageSettings) => AsyncIterableIterator<ContinuablePage<TElement, TPage>>;
    next(): Promise<IteratorResult<TElement>>;
}

// @public
export interface PageSettings {
    continuationToken?: string;
}

// @public
export interface PathHierarchyTokenizerV2 extends LexicalTokenizer {
    delimiter?: string;
    maxTokenLength?: number;
    numberOfTokensToSkip?: number;
    odataType: "#Microsoft.Azure.Search.PathHierarchyTokenizerV2";
    replacement?: string;
    reverseTokenOrder?: boolean;
}

// @public
export interface PatternAnalyzer extends LexicalAnalyzer {
    flags?: RegexFlags;
    lowerCaseTerms?: boolean;
    odataType: "#Microsoft.Azure.Search.PatternAnalyzer";
    pattern?: string;
    stopwords?: string[];
}

// @public
export interface PatternCaptureTokenFilter extends TokenFilter {
    odataType: "#Microsoft.Azure.Search.PatternCaptureTokenFilter";
    patterns: string[];
    preserveOriginal?: boolean;
}

// @public
export interface PatternReplaceCharFilter extends CharFilter {
    odataType: "#Microsoft.Azure.Search.PatternReplaceCharFilter";
    pattern: string;
    replacement: string;
}

// @public
export interface PatternReplaceTokenFilter extends TokenFilter {
    odataType: "#Microsoft.Azure.Search.PatternReplaceTokenFilter";
    pattern: string;
    replacement: string;
}

// @public
export interface PatternTokenizer extends LexicalTokenizer {
    flags?: RegexFlags;
    group?: number;
    odataType: "#Microsoft.Azure.Search.PatternTokenizer";
    pattern?: string;
}

// @public
export type PhoneticEncoder = "metaphone" | "doubleMetaphone" | "soundex" | "refinedSoundex" | "caverphone1" | "caverphone2" | "cologne" | "nysiis" | "koelnerPhonetik" | "haasePhonetik" | "beiderMorse";

// @public
export interface PhoneticTokenFilter extends TokenFilter {
    encoder?: PhoneticEncoder;
    odataType: "#Microsoft.Azure.Search.PhoneticTokenFilter";
    replaceOriginalTokens?: boolean;
}

// @public
export interface PIIDetectionSkill extends SearchIndexerSkill {
    defaultLanguageCode?: string;
    domain?: string;
    mask?: string;
    maskingMode?: PIIDetectionSkillMaskingMode;
    minimumPrecision?: number;
    modelVersion?: string;
    odataType: "#Microsoft.Skills.Text.PIIDetectionSkill";
    piiCategories?: string[];
}

// @public
export type PIIDetectionSkillMaskingMode = "none" | "replace";

// @public
export interface QueryAnswerResult {
    additionalProperties?: Record<string, any>;
    highlights?: string;
    key?: string;
    score?: number;
    text?: string;
}

// @public
export type QueryAnswerType = "none" | "extractive";

// @public
export interface QueryCaptionResult {
    additionalProperties?: Record<string, any>;
    highlights?: string;
    text?: string;
}

// @public
export type QueryCaptionType = "none" | "extractive";

// @public
export type QueryDebugMode = "disabled" | "semantic" | "vector" | "queryRewrites" | "all";

// @public
export type QueryLanguage = "none" | "en-us" | "en-gb" | "en-in" | "en-ca" | "en-au" | "fr-fr" | "fr-ca" | "de-de" | "es-es" | "es-mx" | "zh-cn" | "zh-tw" | "pt-br" | "pt-pt" | "it-it" | "ja-jp" | "ko-kr" | "ru-ru" | "cs-cz" | "nl-be" | "nl-nl" | "hu-hu" | "pl-pl" | "sv-se" | "tr-tr" | "hi-in" | "ar-sa" | "ar-eg" | "ar-ma" | "ar-kw" | "ar-jo" | "da-dk" | "no-no" | "bg-bg" | "hr-hr" | "hr-ba" | "ms-my" | "ms-bn" | "sl-sl" | "ta-in" | "vi-vn" | "el-gr" | "ro-ro" | "is-is" | "id-id" | "th-th" | "lt-lt" | "uk-ua" | "lv-lv" | "et-ee" | "ca-es" | "fi-fi" | "sr-ba" | "sr-me" | "sr-rs" | "sk-sk" | "nb-no" | "hy-am" | "bn-in" | "eu-es" | "gl-es" | "gu-in" | "he-il" | "ga-ie" | "kn-in" | "ml-in" | "mr-in" | "fa-ae" | "pa-in" | "te-in" | "ur-pk";

// @public
export interface QueryResultDocumentRerankerInput {
    readonly content?: string;
    readonly keywords?: string;
    readonly title?: string;
}

// @public
export interface QueryResultDocumentSemanticField {
    readonly name?: string;
    readonly state?: SemanticFieldState;
}

// @public
export interface QueryResultDocumentSubscores {
    readonly documentBoost?: number;
    readonly text?: TextResult;
    readonly vectors?: Record<string, SingleVectorFieldResult>[];
}

// @public
export interface QueryRewritesDebugInfo {
    readonly text?: QueryRewritesValuesDebugInfo;
    readonly vectors?: QueryRewritesValuesDebugInfo[];
}

// @public
export type QueryRewritesType = "none" | "generative";

// @public
export interface QueryRewritesValuesDebugInfo {
    readonly inputQuery?: string;
    readonly rewrites?: string[];
}

// @public
export type QuerySpellerType = "none" | "lexicon";

// @public
export type QueryType = "simple" | "full" | "semantic";

// @public
export type RegexFlags = "CANON_EQ" | "CASE_INSENSITIVE" | "COMMENTS" | "DOTALL" | "LITERAL" | "MULTILINE" | "UNICODE_CASE" | "UNIX_LINES";

// @public
export interface RescoringOptions {
    defaultOversampling?: number;
    enableRescoring?: boolean;
    rescoreStorageMethod?: VectorSearchCompressionRescoreStorageMethod;
}

// @public
export interface ResourceCounter {
    quota?: number;
    usage: number;
}

// @public
export interface ScalarQuantizationCompression extends VectorSearchCompression {
    kind: "scalarQuantization";
    parameters?: ScalarQuantizationParameters;
}

// @public
export interface ScalarQuantizationParameters {
    quantizedDataType?: VectorSearchCompressionTarget;
}

// @public
export interface ScoringFunction {
    boost: number;
    fieldName: string;
    interpolation?: ScoringFunctionInterpolation;
    type: string;
}

// @public
export type ScoringFunctionAggregation = "sum" | "average" | "minimum" | "maximum" | "firstMatching";

// @public
export type ScoringFunctionInterpolation = "linear" | "constant" | "quadratic" | "logarithmic";

// @public
export type ScoringFunctionUnion = DistanceScoringFunction | FreshnessScoringFunction | MagnitudeScoringFunction | TagScoringFunction | ScoringFunction;

// @public
export interface ScoringProfile {
    functionAggregation?: ScoringFunctionAggregation;
    functions?: ScoringFunctionUnion[];
    name: string;
    textWeights?: TextWeights;
}

// @public
export type ScoringStatistics = "local" | "global";

// @public
export interface SearchAlias {
    eTag?: string;
    indexes: string[];
    name: string;
}

// @public
export interface SearchDocumentsResult {
    answers?: QueryAnswerResult[];
    count?: number;
    coverage?: number;
    readonly debugInfo?: DebugInfo;
    facets?: Record<string, FacetResult[]>;
    nextLink?: string;
    nextPageParameters?: SearchRequest;
    results: SearchResult[];
    semanticPartialResponseReason?: SemanticErrorReason;
    semanticPartialResponseType?: SemanticSearchResultsType;
    readonly semanticQueryRewritesResultType?: SemanticQueryRewritesResultType;
}

// @public
export interface SearchField {
    analyzer?: LexicalAnalyzerName;
    facetable?: boolean;
    fields?: SearchField[];
    filterable?: boolean;
    indexAnalyzer?: LexicalAnalyzerName;
    key?: boolean;
    name: string;
    normalizer?: LexicalNormalizerName;
    retrievable?: boolean;
    searchable?: boolean;
    searchAnalyzer?: LexicalAnalyzerName;
    sortable?: boolean;
    stored?: boolean;
    synonymMaps?: string[];
    type: SearchFieldDataType;
    vectorEncodingFormat?: VectorEncodingFormat;
    vectorSearchDimensions?: number;
    vectorSearchProfileName?: string;
}

// @public
export type SearchFieldDataType = "Edm.String" | "Edm.Int32" | "Edm.Int64" | "Edm.Double" | "Edm.Boolean" | "Edm.DateTimeOffset" | "Edm.GeographyPoint" | "Edm.ComplexType" | "Edm.Single" | "Edm.Half" | "Edm.Int16" | "Edm.SByte" | "Edm.Byte";

// @public
export interface SearchIndex {
    analyzers?: LexicalAnalyzerUnion[];
    charFilters?: CharFilterUnion[];
    corsOptions?: CorsOptions;
    defaultScoringProfile?: string;
    encryptionKey?: SearchResourceEncryptionKey;
    eTag?: string;
    fields: SearchField[];
    name: string;
    normalizers?: LexicalNormalizerUnion[];
    scoringProfiles?: ScoringProfile[];
    semanticSearch?: SemanticSearch;
    similarity?: SimilarityAlgorithmUnion;
    suggesters?: SearchSuggester[];
    tokenFilters?: TokenFilterUnion[];
    tokenizers?: LexicalTokenizerUnion[];
    vectorSearch?: VectorSearch;
}

// @public (undocumented)
export class SearchIndexClient {
    constructor(endpointParam: string, credential: KeyCredential | TokenCredential, options?: SearchIndexClientOptionalParams);
    readonly documents: DocumentsOperations;
    readonly pipeline: Pipeline;
}

// @public
export interface SearchIndexClientOptionalParams extends ClientOptions {
    apiVersion?: string;
}

// @public
export interface SearchIndexer {
    cache?: SearchIndexerCache;
    dataSourceName: string;
    description?: string;
    encryptionKey?: SearchResourceEncryptionKey;
    eTag?: string;
    fieldMappings?: FieldMapping[];
    isDisabled?: boolean;
    name: string;
    outputFieldMappings?: FieldMapping[];
    parameters?: IndexingParameters;
    schedule?: IndexingSchedule;
    skillsetName?: string;
    targetIndexName: string;
}

// @public
export interface SearchIndexerCache {
    enableReprocessing?: boolean;
    id?: string;
    identity?: SearchIndexerDataIdentityUnion;
    storageConnectionString?: string;
}

// @public
export interface SearchIndexerDataContainer {
    name: string;
    query?: string;
}

// @public
export interface SearchIndexerDataIdentity {
    odataType: string;
}

// @public
export type SearchIndexerDataIdentityUnion = SearchIndexerDataNoneIdentity | SearchIndexerDataUserAssignedIdentity | SearchIndexerDataIdentity;

// @public
export interface SearchIndexerDataNoneIdentity extends SearchIndexerDataIdentity {
    odataType: "#Microsoft.Azure.Search.DataNoneIdentity";
}

// @public
export interface SearchIndexerDataSource {
    container: SearchIndexerDataContainer;
    credentials: DataSourceCredentials;
    dataChangeDetectionPolicy?: DataChangeDetectionPolicyUnion;
    dataDeletionDetectionPolicy?: DataDeletionDetectionPolicyUnion;
    description?: string;
    encryptionKey?: SearchResourceEncryptionKey;
    eTag?: string;
    identity?: SearchIndexerDataIdentityUnion;
    name: string;
    type: SearchIndexerDataSourceType;
}

// @public
export type SearchIndexerDataSourceType = "azuresql" | "cosmosdb" | "azureblob" | "azuretable" | "mysql" | "adlsgen2" | "onelake";

// @public
export interface SearchIndexerDataUserAssignedIdentity extends SearchIndexerDataIdentity {
    odataType: "#Microsoft.Azure.Search.DataUserAssignedIdentity";
    resourceId: string;
}

// @public
export interface SearchIndexerError {
    details?: string;
    documentationLink?: string;
    errorMessage: string;
    key?: string;
    name?: string;
    statusCode: number;
}

// @public
export interface SearchIndexerIndexProjection {
    parameters?: SearchIndexerIndexProjectionsParameters;
    selectors: SearchIndexerIndexProjectionSelector[];
}

// @public
export interface SearchIndexerIndexProjectionSelector {
    mappings: InputFieldMappingEntry[];
    parentKeyFieldName: string;
    sourceContext: string;
    targetIndexName: string;
}

// @public
export interface SearchIndexerIndexProjectionsParameters {
    additionalProperties?: Record<string, any>;
    projectionMode?: IndexProjectionMode;
}

// @public
export interface SearchIndexerKnowledgeStore {
    identity?: SearchIndexerDataIdentityUnion;
    parameters?: SearchIndexerKnowledgeStoreParameters;
    projections: SearchIndexerKnowledgeStoreProjection[];
    storageConnectionString: string;
}

// @public
export interface SearchIndexerKnowledgeStoreBlobProjectionSelector extends SearchIndexerKnowledgeStoreProjectionSelector {
    storageContainer: string;
}

// @public
export interface SearchIndexerKnowledgeStoreFileProjectionSelector extends SearchIndexerKnowledgeStoreBlobProjectionSelector {
}

// @public
export interface SearchIndexerKnowledgeStoreObjectProjectionSelector extends SearchIndexerKnowledgeStoreBlobProjectionSelector {
}

// @public
export interface SearchIndexerKnowledgeStoreParameters {
    additionalProperties?: Record<string, any>;
    synthesizeGeneratedKeyName?: boolean;
}

// @public
export interface SearchIndexerKnowledgeStoreProjection {
    files?: SearchIndexerKnowledgeStoreFileProjectionSelector[];
    objects?: SearchIndexerKnowledgeStoreObjectProjectionSelector[];
    tables?: SearchIndexerKnowledgeStoreTableProjectionSelector[];
}

// @public
export interface SearchIndexerKnowledgeStoreProjectionSelector {
    generatedKeyName?: string;
    inputs?: InputFieldMappingEntry[];
    referenceKeyName?: string;
    source?: string;
    sourceContext?: string;
}

// @public
export interface SearchIndexerKnowledgeStoreTableProjectionSelector extends SearchIndexerKnowledgeStoreProjectionSelector {
    tableName: string;
}

// @public
export interface SearchIndexerLimits {
    maxDocumentContentCharactersToExtract?: number;
    maxDocumentExtractionSize?: number;
    maxRunTime?: string;
}

// @public
export interface SearchIndexerSkill {
    context?: string;
    description?: string;
    inputs: InputFieldMappingEntry[];
    name?: string;
    odataType: string;
    outputs: OutputFieldMappingEntry[];
}

// @public
export interface SearchIndexerSkillset {
    cognitiveServicesAccount?: CognitiveServicesAccountUnion;
    description?: string;
    encryptionKey?: SearchResourceEncryptionKey;
    eTag?: string;
    indexProjection?: SearchIndexerIndexProjection;
    knowledgeStore?: SearchIndexerKnowledgeStore;
    name: string;
    skills: SearchIndexerSkillUnion[];
}

// @public
export type SearchIndexerSkillUnion = ConditionalSkill | KeyPhraseExtractionSkill | OcrSkill | ImageAnalysisSkill | LanguageDetectionSkill | ShaperSkill | MergeSkill | EntityRecognitionSkill | SentimentSkill | SentimentSkillV3 | EntityLinkingSkill | EntityRecognitionSkillV3 | PIIDetectionSkill | SplitSkill | CustomEntityLookupSkill | TextTranslationSkill | DocumentExtractionSkill | DocumentIntelligenceLayoutSkill | WebApiSkill | AzureMachineLearningSkill | AzureOpenAIEmbeddingSkill | VisionVectorizeSkill | SearchIndexerSkill;

// @public
export interface SearchIndexerStatus {
    executionHistory: IndexerExecutionResult[];
    lastResult?: IndexerExecutionResult;
    limits: SearchIndexerLimits;
    status: IndexerStatus;
}

// @public
export interface SearchIndexerWarning {
    details?: string;
    documentationLink?: string;
    key?: string;
    message: string;
    name?: string;
}

// @public
export type SearchMode = "any" | "all";

// @public
export interface SearchRequest {
    answers?: QueryAnswerType;
    captions?: QueryCaptionType;
    debug?: QueryDebugMode;
    facets?: string[];
    filter?: string;
    highlightFields?: string;
    highlightPostTag?: string;
    highlightPreTag?: string;
    hybridSearch?: HybridSearch;
    includeTotalResultCount?: boolean;
    minimumCoverage?: number;
    orderBy?: string;
    queryLanguage?: QueryLanguage;
    queryRewrites?: QueryRewritesType;
    queryType?: QueryType;
    scoringParameters?: string[];
    scoringProfile?: string;
    scoringStatistics?: ScoringStatistics;
    searchFields?: string;
    searchMode?: SearchMode;
    searchText?: string;
    select?: string;
    semanticConfiguration?: string;
    semanticErrorHandling?: SemanticErrorMode;
    semanticFields?: string;
    semanticMaxWaitInMilliseconds?: number;
    semanticQuery?: string;
    sessionId?: string;
    skip?: number;
    speller?: QuerySpellerType;
    top?: number;
    vectorFilterMode?: VectorFilterMode;
    vectorQueries?: VectorQueryUnion[];
}

// @public
export interface SearchResourceEncryptionKey {
    accessCredentials?: AzureActiveDirectoryApplicationCredentials;
    identity?: SearchIndexerDataIdentityUnion;
    keyName: string;
    keyVersion?: string;
    vaultUri: string;
}

// @public
export interface SearchResult {
    additionalProperties?: Record<string, any>;
    captions?: QueryCaptionResult[];
    readonly documentDebugInfo?: DocumentDebugInfo[];
    highlights?: Record<string, string[]>;
    rerankerScore?: number;
    score: number;
}

// @public
export interface SearchScoreThreshold extends VectorThreshold {
    kind: "searchScore";
    value: number;
}

// @public (undocumented)
export class SearchServiceClient {
    constructor(endpointParam: string, credential: KeyCredential | TokenCredential, options?: SearchServiceClientOptionalParams);
    readonly aliases: AliasesOperations;
    readonly dataSources: DataSourcesOperations;
    getIndexStatsSummary(options?: GetIndexStatsSummaryOptionalParams): PagedAsyncIterableIterator<IndexStatisticsSummary>;
    getServiceStatistics(options?: GetServiceStatisticsOptionalParams): Promise<SearchServiceStatistics>;
    readonly indexers: IndexersOperations;
    readonly indexes: IndexesOperations;
    readonly pipeline: Pipeline;
    readonly skillsets: SkillsetsOperations;
    readonly synonymMaps: SynonymMapsOperations;
}

// @public
export interface SearchServiceClientOptionalParams extends ClientOptions {
    apiVersion?: string;
}

// @public
export interface SearchServiceCounters {
    aliasCounter: ResourceCounter;
    dataSourceCounter: ResourceCounter;
    documentCounter: ResourceCounter;
    indexCounter: ResourceCounter;
    indexerCounter: ResourceCounter;
    skillsetCounter: ResourceCounter;
    storageSizeCounter: ResourceCounter;
    synonymMapCounter: ResourceCounter;
    vectorIndexSizeCounter: ResourceCounter;
}

// @public
export interface SearchServiceLimits {
    maxComplexCollectionFieldsPerIndex?: number;
    maxComplexObjectsInCollectionsPerDocument?: number;
    maxFieldNestingDepthPerIndex?: number;
    maxFieldsPerIndex?: number;
    maxStoragePerIndexInBytes?: number;
}

// @public
export interface SearchServiceStatistics {
    counters: SearchServiceCounters;
    limits: SearchServiceLimits;
}

// @public
export interface SearchSuggester {
    name: string;
    searchMode: "analyzingInfixMatching";
    sourceFields: string[];
}

// @public
export interface SemanticConfiguration {
    flightingOptIn?: boolean;
    name: string;
    prioritizedFields: SemanticPrioritizedFields;
}

// @public
export interface SemanticDebugInfo {
    readonly contentFields?: QueryResultDocumentSemanticField[];
    readonly keywordFields?: QueryResultDocumentSemanticField[];
    readonly rerankerInput?: QueryResultDocumentRerankerInput;
    readonly titleField?: QueryResultDocumentSemanticField;
}

// @public
export type SemanticErrorMode = "partial" | "fail";

// @public
export type SemanticErrorReason = "maxWaitExceeded" | "capacityOverloaded" | "transient";

// @public
export interface SemanticField {
    fieldName: string;
}

// @public
export type SemanticFieldState = "used" | "unused" | "partial";

// @public
export interface SemanticPrioritizedFields {
    contentFields?: SemanticField[];
    keywordsFields?: SemanticField[];
    titleField?: SemanticField;
}

// @public
export type SemanticQueryRewritesResultType = "originalQueryOnly";

// @public
export interface SemanticSearch {
    configurations?: SemanticConfiguration[];
    defaultConfigurationName?: string;
}

// @public
export type SemanticSearchResultsType = "baseResults" | "rerankedResults";

// @public
export interface SentimentSkill extends SearchIndexerSkill {
    defaultLanguageCode?: SentimentSkillLanguage;
    odataType: "#Microsoft.Skills.Text.SentimentSkill";
}

// @public
export type SentimentSkillLanguage = "da" | "nl" | "en" | "fi" | "fr" | "de" | "el" | "it" | "no" | "pl" | "pt-PT" | "ru" | "es" | "sv" | "tr";

// @public
export interface SentimentSkillV3 extends SearchIndexerSkill {
    defaultLanguageCode?: string;
    includeOpinionMining?: boolean;
    modelVersion?: string;
    odataType: "#Microsoft.Skills.Text.V3.SentimentSkill";
}

// @public
export interface ShaperSkill extends SearchIndexerSkill {
    odataType: "#Microsoft.Skills.Util.ShaperSkill";
}

// @public
export interface ShingleTokenFilter extends TokenFilter {
    filterToken?: string;
    maxShingleSize?: number;
    minShingleSize?: number;
    odataType: "#Microsoft.Azure.Search.ShingleTokenFilter";
    outputUnigrams?: boolean;
    outputUnigramsIfNoShingles?: boolean;
    tokenSeparator?: string;
}

// @public
export interface SimilarityAlgorithm {
    odataType: string;
}

// @public
export type SimilarityAlgorithmUnion = ClassicSimilarityAlgorithm | BM25SimilarityAlgorithm | SimilarityAlgorithm;

// @public
export interface SingleVectorFieldResult {
    readonly searchScore?: number;
    readonly vectorSimilarity?: number;
}

// @public
export interface SkillNames {
    skillNames?: string[];
}

// @public
export interface SkillsetsCreateOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface SkillsetsCreateOrUpdateOptionalParams extends OperationOptions {
    clientRequestId?: string;
    disableCacheReprocessingChangeDetection?: boolean;
    ifMatch?: string;
    ifNoneMatch?: string;
    skipIndexerResetRequirementForCache?: boolean;
}

// @public
export interface SkillsetsDeleteOptionalParams extends OperationOptions {
    clientRequestId?: string;
    ifMatch?: string;
    ifNoneMatch?: string;
}

// @public
export interface SkillsetsGetOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface SkillsetsListOptionalParams extends OperationOptions {
    clientRequestId?: string;
    select?: string;
}

// @public
export interface SkillsetsOperations {
    create: (skillset: SearchIndexerSkillset, options?: SkillsetsCreateOptionalParams) => Promise<SearchIndexerSkillset>;
    createOrUpdate: (skillset: SearchIndexerSkillset, skillsetName: string, options?: SkillsetsCreateOrUpdateOptionalParams) => Promise<SearchIndexerSkillset>;
    delete: (skillsetName: string, options?: SkillsetsDeleteOptionalParams) => Promise<void>;
    get: (skillsetName: string, options?: SkillsetsGetOptionalParams) => Promise<SearchIndexerSkillset>;
    list: (options?: SkillsetsListOptionalParams) => Promise<ListSkillsetsResult>;
    resetSkills: (skillNames: SkillNames, skillsetName: string, options?: SkillsetsResetSkillsOptionalParams) => Promise<void>;
}

// @public
export interface SkillsetsResetSkillsOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface SnowballTokenFilter extends TokenFilter {
    language: SnowballTokenFilterLanguage;
    odataType: "#Microsoft.Azure.Search.SnowballTokenFilter";
}

// @public
export type SnowballTokenFilterLanguage = "armenian" | "basque" | "catalan" | "danish" | "dutch" | "english" | "finnish" | "french" | "german" | "german2" | "hungarian" | "italian" | "kp" | "lovins" | "norwegian" | "porter" | "portuguese" | "romanian" | "russian" | "spanish" | "swedish" | "turkish";

// @public
export interface SoftDeleteColumnDeletionDetectionPolicy extends DataDeletionDetectionPolicy {
    odataType: "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy";
    softDeleteColumnName?: string;
    softDeleteMarkerValue?: string;
}

// @public
export interface SplitSkill extends SearchIndexerSkill {
    azureOpenAITokenizerParameters?: AzureOpenAITokenizerParameters;
    defaultLanguageCode?: SplitSkillLanguage;
    maximumPageLength?: number;
    maximumPagesToTake?: number;
    odataType: "#Microsoft.Skills.Text.SplitSkill";
    pageOverlapLength?: number;
    textSplitMode?: TextSplitMode;
    unit?: SplitSkillUnit;
}

// @public
export type SplitSkillEncoderModelName = "r50k_base" | "p50k_base" | "p50k_edit" | "cl100k_base";

// @public
export type SplitSkillLanguage = "am" | "bs" | "cs" | "da" | "de" | "en" | "es" | "et" | "fi" | "fr" | "he" | "hi" | "hr" | "hu" | "id" | "is" | "it" | "ja" | "ko" | "lv" | "nb" | "nl" | "pl" | "pt" | "pt-br" | "ru" | "sk" | "sl" | "sr" | "sv" | "tr" | "ur" | "zh";

// @public
export type SplitSkillUnit = "characters" | "azureOpenAITokens";

// @public
export interface SqlIntegratedChangeTrackingPolicy extends DataChangeDetectionPolicy {
    odataType: "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy";
}

// @public
export interface StemmerOverrideTokenFilter extends TokenFilter {
    odataType: "#Microsoft.Azure.Search.StemmerOverrideTokenFilter";
    rules: string[];
}

// @public
export interface StemmerTokenFilter extends TokenFilter {
    language: StemmerTokenFilterLanguage;
    odataType: "#Microsoft.Azure.Search.StemmerTokenFilter";
}

// @public
export type StemmerTokenFilterLanguage = "arabic" | "armenian" | "basque" | "brazilian" | "bulgarian" | "catalan" | "czech" | "danish" | "dutch" | "dutchKp" | "english" | "lightEnglish" | "minimalEnglish" | "possessiveEnglish" | "porter2" | "lovins" | "finnish" | "lightFinnish" | "french" | "lightFrench" | "minimalFrench" | "galician" | "minimalGalician" | "german" | "german2" | "lightGerman" | "minimalGerman" | "greek" | "hindi" | "hungarian" | "lightHungarian" | "indonesian" | "irish" | "italian" | "lightItalian" | "sorani" | "latvian" | "norwegian" | "lightNorwegian" | "minimalNorwegian" | "lightNynorsk" | "minimalNynorsk" | "portuguese" | "lightPortuguese" | "minimalPortuguese" | "portugueseRslp" | "romanian" | "russian" | "lightRussian" | "spanish" | "lightSpanish" | "swedish" | "lightSwedish" | "turkish";

// @public
export interface StopAnalyzer extends LexicalAnalyzer {
    odataType: "#Microsoft.Azure.Search.StopAnalyzer";
    stopwords?: string[];
}

// @public
export type StopwordsList = "arabic" | "armenian" | "basque" | "brazilian" | "bulgarian" | "catalan" | "czech" | "danish" | "dutch" | "english" | "finnish" | "french" | "galician" | "german" | "greek" | "hindi" | "hungarian" | "indonesian" | "irish" | "italian" | "latvian" | "norwegian" | "persian" | "portuguese" | "romanian" | "russian" | "sorani" | "spanish" | "swedish" | "thai" | "turkish";

// @public
export interface StopwordsTokenFilter extends TokenFilter {
    ignoreCase?: boolean;
    odataType: "#Microsoft.Azure.Search.StopwordsTokenFilter";
    removeTrailingStopWords?: boolean;
    stopwords?: string[];
    stopwordsList?: StopwordsList;
}

// @public
export interface SuggestDocumentsResult {
    coverage?: number;
    results: SuggestResult[];
}

// @public
export interface SuggestRequest {
    filter?: string;
    highlightPostTag?: string;
    highlightPreTag?: string;
    minimumCoverage?: number;
    orderBy?: string;
    searchFields?: string;
    searchText: string;
    select?: string;
    suggesterName: string;
    top?: number;
    useFuzzyMatching?: boolean;
}

// @public
export interface SuggestResult {
    additionalProperties?: Record<string, any>;
    text: string;
}

// @public
export interface SynonymMap {
    encryptionKey?: SearchResourceEncryptionKey;
    eTag?: string;
    format: "solr";
    name: string;
    synonyms: string;
}

// @public
export interface SynonymMapsCreateOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface SynonymMapsCreateOrUpdateOptionalParams extends OperationOptions {
    clientRequestId?: string;
    ifMatch?: string;
    ifNoneMatch?: string;
}

// @public
export interface SynonymMapsDeleteOptionalParams extends OperationOptions {
    clientRequestId?: string;
    ifMatch?: string;
    ifNoneMatch?: string;
}

// @public
export interface SynonymMapsGetOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface SynonymMapsListOptionalParams extends OperationOptions {
    clientRequestId?: string;
    select?: string;
}

// @public
export interface SynonymMapsOperations {
    create: (synonymMap: SynonymMap, options?: SynonymMapsCreateOptionalParams) => Promise<SynonymMap>;
    createOrUpdate: (synonymMap: SynonymMap, synonymMapName: string, options?: SynonymMapsCreateOrUpdateOptionalParams) => Promise<SynonymMap>;
    delete: (synonymMapName: string, options?: SynonymMapsDeleteOptionalParams) => Promise<void>;
    get: (synonymMapName: string, options?: SynonymMapsGetOptionalParams) => Promise<SynonymMap>;
    list: (options?: SynonymMapsListOptionalParams) => Promise<ListSynonymMapsResult>;
}

// @public
export interface SynonymTokenFilter extends TokenFilter {
    expand?: boolean;
    ignoreCase?: boolean;
    odataType: "#Microsoft.Azure.Search.SynonymTokenFilter";
    synonyms: string[];
}

// @public
export interface TagScoringFunction extends ScoringFunction {
    parameters: TagScoringParameters;
    type: "tag";
}

// @public
export interface TagScoringParameters {
    tagsParameter: string;
}

// @public
export interface TextResult {
    readonly searchScore?: number;
}

// @public
export type TextSplitMode = "pages" | "sentences";

// @public
export interface TextTranslationSkill extends SearchIndexerSkill {
    defaultFromLanguageCode?: TextTranslationSkillLanguage;
    defaultToLanguageCode: TextTranslationSkillLanguage;
    odataType: "#Microsoft.Skills.Text.TranslationSkill";
    suggestedFrom?: TextTranslationSkillLanguage;
}

// @public
export type TextTranslationSkillLanguage = "af" | "ar" | "bn" | "bs" | "bg" | "yue" | "ca" | "zh-Hans" | "zh-Hant" | "hr" | "cs" | "da" | "nl" | "en" | "et" | "fj" | "fil" | "fi" | "fr" | "de" | "el" | "ht" | "he" | "hi" | "mww" | "hu" | "is" | "id" | "it" | "ja" | "sw" | "tlh" | "tlh-Latn" | "tlh-Piqd" | "ko" | "lv" | "lt" | "mg" | "ms" | "mt" | "nb" | "fa" | "pl" | "pt" | "pt-br" | "pt-PT" | "otq" | "ro" | "ru" | "sm" | "sr-Cyrl" | "sr-Latn" | "sk" | "sl" | "es" | "sv" | "ty" | "ta" | "te" | "th" | "to" | "tr" | "uk" | "ur" | "vi" | "cy" | "yua" | "ga" | "kn" | "mi" | "ml" | "pa";

// @public
export interface TextWeights {
    weights: Record<string, number>;
}

// @public
export type TokenCharacterKind = "letter" | "digit" | "whitespace" | "punctuation" | "symbol";

// @public
export interface TokenFilter {
    name: string;
    odataType: string;
}

// @public
export type TokenFilterName = "arabic_normalization" | "apostrophe" | "asciifolding" | "cjk_bigram" | "cjk_width" | "classic" | "common_grams" | "edgeNGram_v2" | "elision" | "german_normalization" | "hindi_normalization" | "indic_normalization" | "keyword_repeat" | "kstem" | "length" | "limit" | "lowercase" | "nGram_v2" | "persian_normalization" | "phonetic" | "porter_stem" | "reverse" | "scandinavian_normalization" | "scandinavian_folding" | "shingle" | "snowball" | "sorani_normalization" | "stemmer" | "stopwords" | "trim" | "truncate" | "unique" | "uppercase" | "word_delimiter";

// @public
export type TokenFilterUnion = AsciiFoldingTokenFilter | CjkBigramTokenFilter | CommonGramTokenFilter | DictionaryDecompounderTokenFilter | EdgeNGramTokenFilterV2 | ElisionTokenFilter | KeepTokenFilter | KeywordMarkerTokenFilter | LengthTokenFilter | LimitTokenFilter | NGramTokenFilterV2 | PatternCaptureTokenFilter | PatternReplaceTokenFilter | PhoneticTokenFilter | ShingleTokenFilter | SnowballTokenFilter | StemmerTokenFilter | StemmerOverrideTokenFilter | StopwordsTokenFilter | SynonymTokenFilter | TruncateTokenFilter | UniqueTokenFilter | WordDelimiterTokenFilter | TokenFilter;

// @public
export interface TruncateTokenFilter extends TokenFilter {
    length?: number;
    odataType: "#Microsoft.Azure.Search.TruncateTokenFilter";
}

// @public
export interface UaxUrlEmailTokenizer extends LexicalTokenizer {
    maxTokenLength?: number;
    odataType: "#Microsoft.Azure.Search.UaxUrlEmailTokenizer";
}

// @public
export interface UniqueTokenFilter extends TokenFilter {
    odataType: "#Microsoft.Azure.Search.UniqueTokenFilter";
    onlyOnSamePosition?: boolean;
}

// @public
export type VectorEncodingFormat = "packedBit";

// @public
export type VectorFilterMode = "postFilter" | "preFilter";

// @public
export interface VectorizableImageBinaryQuery extends VectorQuery {
    base64Image?: string;
    kind: "imageBinary";
}

// @public
export interface VectorizableImageUrlQuery extends VectorQuery {
    kind: "imageUrl";
    url?: string;
}

// @public
export interface VectorizableTextQuery extends VectorQuery {
    kind: "text";
    queryRewrites?: QueryRewritesType;
    text: string;
}

// @public
export interface VectorizedQuery extends VectorQuery {
    kind: "vector";
    vector: number[];
}

// @public
export interface VectorQuery {
    exhaustive?: boolean;
    fields?: string;
    filterOverride?: string;
    kind: VectorQueryKind;
    kNearestNeighbors?: number;
    oversampling?: number;
    threshold?: VectorThresholdUnion;
    weight?: number;
}

// @public
export type VectorQueryKind = "vector" | "text" | "imageUrl" | "imageBinary";

// @public
export type VectorQueryUnion = VectorizedQuery | VectorizableTextQuery | VectorizableImageUrlQuery | VectorizableImageBinaryQuery | VectorQuery;

// @public
export interface VectorsDebugInfo {
    readonly subscores?: QueryResultDocumentSubscores;
}

// @public
export interface VectorSearch {
    algorithms?: VectorSearchAlgorithmConfigurationUnion[];
    compressions?: VectorSearchCompressionUnion[];
    profiles?: VectorSearchProfile[];
    vectorizers?: VectorSearchVectorizerUnion[];
}

// @public
export interface VectorSearchAlgorithmConfiguration {
    kind: VectorSearchAlgorithmKind;
    name: string;
}

// @public
export type VectorSearchAlgorithmConfigurationUnion = HnswAlgorithmConfiguration | ExhaustiveKnnAlgorithmConfiguration | VectorSearchAlgorithmConfiguration;

// @public
export type VectorSearchAlgorithmKind = "hnsw" | "exhaustiveKnn";

// @public
export type VectorSearchAlgorithmMetric = "cosine" | "euclidean" | "dotProduct" | "hamming";

// @public
export interface VectorSearchCompression {
    compressionName: string;
    defaultOversampling?: number;
    kind: VectorSearchCompressionKind;
    rerankWithOriginalVectors?: boolean;
    rescoringOptions?: RescoringOptions;
    truncationDimension?: number;
}

// @public
export type VectorSearchCompressionKind = "scalarQuantization" | "binaryQuantization";

// @public
export type VectorSearchCompressionRescoreStorageMethod = "preserveOriginals" | "discardOriginals";

// @public
export type VectorSearchCompressionTarget = "int8";

// @public
export type VectorSearchCompressionUnion = ScalarQuantizationCompression | BinaryQuantizationCompression | VectorSearchCompression;

// @public
export interface VectorSearchProfile {
    algorithmConfigurationName: string;
    compressionName?: string;
    name: string;
    vectorizerName?: string;
}

// @public
export interface VectorSearchVectorizer {
    kind: VectorSearchVectorizerKind;
    vectorizerName: string;
}

// @public
export type VectorSearchVectorizerKind = "azureOpenAI" | "customWebApi" | "aiServicesVision" | "aml";

// @public
export type VectorSearchVectorizerUnion = AzureOpenAIVectorizer | WebApiVectorizer | AIServicesVisionVectorizer | AzureMachineLearningVectorizer | VectorSearchVectorizer;

// @public
export interface VectorSimilarityThreshold extends VectorThreshold {
    kind: "vectorSimilarity";
    value: number;
}

// @public
export interface VectorThreshold {
    kind: VectorThresholdKind;
}

// @public
export type VectorThresholdKind = "vectorSimilarity" | "searchScore";

// @public
export type VectorThresholdUnion = VectorSimilarityThreshold | SearchScoreThreshold | VectorThreshold;

// @public
export interface VisionVectorizeSkill extends SearchIndexerSkill {
    modelVersion: string;
    odataType: "#Microsoft.Skills.Vision.VectorizeSkill";
}

// @public
export type VisualFeature = "adult" | "brands" | "categories" | "description" | "faces" | "objects" | "tags";

// @public
export interface WebApiSkill extends SearchIndexerSkill {
    authIdentity?: SearchIndexerDataIdentityUnion;
    authResourceId?: string;
    batchSize?: number;
    degreeOfParallelism?: number;
    httpHeaders?: Record<string, string>;
    httpMethod?: string;
    odataType: "#Microsoft.Skills.Custom.WebApiSkill";
    timeout?: string;
    uri: string;
}

// @public
export interface WebApiVectorizer extends VectorSearchVectorizer {
    kind: "customWebApi";
    webApiParameters?: WebApiVectorizerParameters;
}

// @public
export interface WebApiVectorizerParameters {
    authIdentity?: SearchIndexerDataIdentityUnion;
    authResourceId?: string;
    httpHeaders?: Record<string, string>;
    httpMethod?: string;
    timeout?: string;
    url?: string;
}

// @public
export interface WordDelimiterTokenFilter extends TokenFilter {
    catenateAll?: boolean;
    catenateNumbers?: boolean;
    catenateWords?: boolean;
    generateNumberParts?: boolean;
    generateWordParts?: boolean;
    odataType: "#Microsoft.Azure.Search.WordDelimiterTokenFilter";
    preserveOriginal?: boolean;
    protectedWords?: string[];
    splitOnCaseChange?: boolean;
    splitOnNumerics?: boolean;
    stemEnglishPossessive?: boolean;
}

// (No @packageDocumentation comment for this package)

```
