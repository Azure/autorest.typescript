## API Report File for "@azure-rest/health-insights-radiologyinsights"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

<<<<<<< HEAD
=======
import { AbortSignalLike } from '@azure/abort-controller';
import { CancelOnProgress } from '@azure/core-lro';
import { Client } from '@azure-rest/core-client';
>>>>>>> main
import { ClientOptions } from '@azure-rest/core-client';
import { ErrorModel } from '@azure-rest/core-client';
import { KeyCredential } from '@azure/core-auth';
<<<<<<< HEAD
import { OperationOptions } from '@azure-rest/core-client';
import { Pipeline } from '@azure/core-rest-pipeline';
=======
import { OperationState } from '@azure/core-lro';
import { RawHttpHeaders } from '@azure/core-rest-pipeline';
import { RawHttpHeadersInput } from '@azure/core-rest-pipeline';
import { RequestParameters } from '@azure-rest/core-client';
import { StreamableMethod } from '@azure-rest/core-client';
>>>>>>> main

// @public
export interface AgeMismatchInference extends RadiologyInsightsInference {
    kind: "ageMismatch";
}

// @public
export interface Annotation extends Element {
    authorString?: string;
    text: string;
    time?: string;
}

// @public (undocumented)
export type ApiVersion = "2023-09-01-preview";

// @public (undocumented)
export type ClinicalDocumentType = "consultation" | "dischargeSummary" | "historyAndPhysical" | "radiologyReport" | "procedure" | "progress" | "laboratory" | "pathologyReport";

// @public
export interface CodeableConcept extends Element {
    coding?: Array<Coding>;
    text?: string;
}

// @public
export interface Coding extends Element {
    code?: string;
    display?: string;
    system?: string;
    version?: string;
}

// @public
export interface CompleteOrderDiscrepancyInference extends RadiologyInsightsInference {
    kind: "completeOrderDiscrepancy";
    missingBodyPartMeasurements?: Array<CodeableConcept>;
    missingBodyParts?: Array<CodeableConcept>;
    orderType: CodeableConcept;
}

// @public
export interface Condition extends DomainResource {
    abatementAge?: Quantity;
    abatementDateTime?: string;
    abatementPeriod?: Period;
    abatementRange?: Range;
    abatementString?: string;
    bodySite?: Array<CodeableConcept>;
    category?: Array<CodeableConcept>;
    clinicalStatus?: CodeableConcept;
    code?: CodeableConcept;
    encounter?: Reference;
    identifier?: Array<Identifier>;
    note?: Array<Annotation>;
    onsetAge?: Quantity;
    onsetDateTime?: string;
    onsetPeriod?: Period;
    onsetRange?: Range;
    onsetString?: string;
    recordedDate?: string;
    resourceType: "Condition";
    severity?: CodeableConcept;
    stage?: Array<ConditionStage>;
    verificationStatus?: CodeableConcept;
}

// @public
export interface ConditionStage {
    summary?: CodeableConcept;
    type?: CodeableConcept;
}

// @public
export interface ContactDetail extends Element {
    name?: string;
    telecom?: Array<ContactPoint>;
}

// @public
export interface ContactPoint {
    period?: Period;
    rank?: number;
    system?: ContactPointSystem;
    use?: ContactPointUse;
    value?: string;
}

// @public (undocumented)
export type ContactPointSystem = "phone" | "fax" | "email" | "pager" | "url" | "sms" | "other";

// @public (undocumented)
export type ContactPointUse = "home" | "work" | "temp" | "old" | "mobile";

// @public
export interface CriticalResult {
    description: string;
    finding?: Observation;
}

// @public
export interface CriticalResultInference extends RadiologyInsightsInference {
    kind: "criticalResult";
    result: CriticalResult;
}

// @public
export interface DocumentAdministrativeMetadata {
    encounterId?: string;
    orderedProcedures?: OrderedProcedure[];
}

// @public
export interface DocumentAuthor {
    fullName?: string;
    id?: string;
}

// @public
export interface DocumentContent {
    sourceType: DocumentContentSourceType;
    value: string;
}

// @public (undocumented)
export type DocumentContentSourceType = "inline" | "reference";

// @public (undocumented)
export type DocumentType = "note" | "fhirBundle" | "dicom" | "genomicSequencing";

// @public
export interface DomainResource extends Resource {
    contained?: Array<Resource>;
    extension?: Array<Extension>;
    modifierExtension?: Array<Extension>;
    resourceType: string;
    text?: Narrative;
}

// @public
export type DomainResourceUnion = Observation | Condition | ResearchStudy | DomainResource;

// @public
export interface Element {
    extension?: Array<Extension>;
    id?: string;
}

// @public
export interface Encounter {
    class?: EncounterClass;
    id: string;
    period?: TimePeriod;
}

// @public (undocumented)
export type EncounterClass = "inpatient" | "ambulatory" | "observation" | "emergency" | "virtual" | "healthHome";

// @public
export interface Extendible {
    extension?: Extension[];
}

// @public
export interface Extension extends Element {
    url: string;
    valueBoolean?: boolean;
    valueCodeableConcept?: CodeableConcept;
    valueDateTime?: string;
    valueInteger?: number;
    valuePeriod?: Period;
    valueQuantity?: Quantity;
    valueRange?: Range;
    valueRatio?: Ratio;
    valueReference?: Reference;
    valueSampledData?: SampledData;
    valueString?: string;
    valueTime?: Date;
}

// @public
export interface FindingInference extends RadiologyInsightsInference {
    finding: Observation;
    kind: "finding";
}

// @public
export interface FindingOptions {
    provideFocusedSentenceEvidence?: boolean;
}

// @public
export interface FollowupCommunicationInference extends RadiologyInsightsInference {
    dateTime?: Date[];
    kind: "followupCommunication";
    recipient?: Array<MedicalProfessionalType>;
    wasAcknowledged: boolean;
}

// @public
export interface FollowupRecommendationInference extends RadiologyInsightsInference {
    effectiveDateTime?: string;
    effectivePeriod?: Period;
    findings?: Array<RecommendationFinding>;
    isConditional: boolean;
    isGuideline: boolean;
    isHedging: boolean;
    isOption: boolean;
    kind: "followupRecommendation";
    recommendedProcedure: ProcedureRecommendationUnion;
}

// @public
export interface FollowupRecommendationOptions {
    includeRecommendationsInReferences?: boolean;
    includeRecommendationsWithNoSpecifiedModality?: boolean;
    provideFocusedSentenceEvidence?: boolean;
}

// @public
export interface GenericProcedureRecommendation extends ProcedureRecommendation {
    code: CodeableConcept;
    description?: string;
    kind: "genericProcedureRecommendation";
}

// @public
export interface HealthInsightsOperationStatusError {
    readonly createdDateTime?: Date;
    error?: ErrorModel;
    readonly expirationDateTime?: Date;
    readonly id: string;
    readonly lastUpdateDateTime?: Date;
    readonly status: JobStatus;
}

// @public
export interface Identifier extends Element {
    assigner?: Reference;
    period?: Period;
    system?: string;
    type?: CodeableConcept;
    use?: string;
    value?: string;
}

// @public
export interface ImagingProcedure {
    anatomy: CodeableConcept;
    contrast?: RadiologyCodeWithTypes;
    laterality?: CodeableConcept;
    modality: CodeableConcept;
    view?: RadiologyCodeWithTypes;
}

// @public
export interface ImagingProcedureRecommendation extends ProcedureRecommendation {
    imagingProcedures: Array<ImagingProcedure>;
    kind: "imagingProcedureRecommendation";
    procedureCodes?: Array<CodeableConcept>;
}

// @public (undocumented)
export interface InferRadiologyInsightsOptionalParams extends OperationOptions {
    repeatabilityFirstSent?: Date;
    repeatabilityRequestId?: string;
}

// @public (undocumented)
export type JobStatus = "notStarted" | "running" | "succeeded" | "failed" | "canceled";

// @public
export interface LateralityDiscrepancyInference extends RadiologyInsightsInference {
    discrepancyType: LateralityDiscrepancyType;
    kind: "lateralityDiscrepancy";
    lateralityIndication?: CodeableConcept;
}

// @public (undocumented)
export type LateralityDiscrepancyType = "orderLateralityMismatch" | "textLateralityContradiction" | "textLateralityMissing";

// @public
export interface LimitedOrderDiscrepancyInference extends RadiologyInsightsInference {
    kind: "limitedOrderDiscrepancy";
    orderType: CodeableConcept;
    presentBodyPartMeasurements?: Array<CodeableConcept>;
    presentBodyParts?: Array<CodeableConcept>;
}

// @public (undocumented)
export type MedicalProfessionalType = "unknown" | "doctor" | "nurse" | "midwife" | "physicianAssistant";

// @public
export interface Meta {
    lastUpdated?: string;
    profile?: string[];
    security?: Coding[];
    source?: string;
    tag?: Coding[];
    versionId?: string;
}

// @public
export interface Narrative extends Element {
    div: string;
    status: string;
}

// @public
export interface Observation extends DomainResource {
    bodySite?: CodeableConcept;
    category?: Array<CodeableConcept>;
    code: CodeableConcept;
    component?: Array<ObservationComponent>;
    dataAbsentReason?: CodeableConcept;
    derivedFrom?: Array<Reference>;
    effectiveDateTime?: string;
    effectiveInstant?: string;
    effectivePeriod?: Period;
    encounter?: Reference;
    hasMember?: Array<Reference>;
    identifier?: Array<Identifier>;
    interpretation?: Array<CodeableConcept>;
    issued?: string;
    method?: CodeableConcept;
    note?: Array<Annotation>;
    referenceRange?: Array<ObservationReferenceRange>;
    resourceType: "Observation";
    status: ObservationStatusCodeType;
    subject?: Reference;
    valueBoolean?: boolean;
    valueCodeableConcept?: CodeableConcept;
    valueDateTime?: string;
    valueInteger?: number;
    valuePeriod?: Period;
    valueQuantity?: Quantity;
    valueRange?: Range;
    valueRatio?: Ratio;
    valueSampledData?: SampledData;
    valueString?: string;
    valueTime?: Date;
}

// @public
export interface ObservationComponent extends Element {
    code: CodeableConcept;
    dataAbsentReason?: CodeableConcept;
    interpretation?: Array<CodeableConcept>;
    referenceRange?: Array<ObservationReferenceRange>;
    valueBoolean?: boolean;
    valueCodeableConcept?: CodeableConcept;
    valueDateTime?: string;
    valueInteger?: number;
    valuePeriod?: Period;
    valueQuantity?: Quantity;
    valueRange?: Range;
    valueRatio?: Ratio;
    valueReference?: Reference;
    valueSampledData?: SampledData;
    valueString?: string;
    valueTime?: Date;
}

// @public
export interface ObservationReferenceRange {
    age?: Range;
    appliesTo?: Array<CodeableConcept>;
    high?: Quantity;
    low?: Quantity;
    text?: string;
    type?: CodeableConcept;
}

// @public (undocumented)
export type ObservationStatusCodeType = "registered" | "preliminary" | "final" | "amended" | "corrected" | "cancelled" | "entered-in-error" | "unknown";

// @public
export interface OrderedProcedure extends Extendible {
    code?: CodeableConcept;
    description?: string;
}

// @public
export interface PatientDocument {
    administrativeMetadata?: DocumentAdministrativeMetadata;
    authors?: Array<DocumentAuthor>;
    clinicalType?: ClinicalDocumentType;
    content: DocumentContent;
    createdDateTime?: Date;
    id: string;
    language?: string;
    specialtyType?: SpecialtyType;
    type: DocumentType;
}

// @public
export interface PatientInfo {
    birthDate?: Date;
    clinicalInfo?: Resource[];
    sex?: PatientInfoSex;
}

// @public (undocumented)
export type PatientInfoSex = "female" | "male" | "unspecified";

// @public
export interface PatientRecord {
    encounters?: Encounter[];
    id: string;
    info?: PatientInfo;
    patientDocuments?: PatientDocument[];
}

// @public
export interface Period extends Element {
    end?: string;
    start?: string;
}

// @public
export interface ProcedureRecommendation {
    kind: string;
}

// @public
export type ProcedureRecommendationUnion = GenericProcedureRecommendation | ImagingProcedureRecommendation | ProcedureRecommendation;

// @public
export interface Quantity extends Element {
    code?: string;
    comparator?: string;
    system?: string;
    unit?: string;
    value?: number;
}

// @public
export interface RadiologyCodeWithTypes {
    code: CodeableConcept;
    types: Array<CodeableConcept>;
}

// @public (undocumented)
export class RadiologyInsightsClient {
    constructor(endpointParam: string, credential: KeyCredential, options?: RadiologyInsightsClientOptions);
    inferRadiologyInsights(body: RadiologyInsightsData, options?: InferRadiologyInsightsOptionalParams): Promise<HealthInsightsOperationStatusError>;
    readonly pipeline: Pipeline;
}

// @public (undocumented)
export interface RadiologyInsightsClientOptions extends ClientOptions {
    apiVersion?: string;
}

// @public
export interface RadiologyInsightsData {
    configuration?: RadiologyInsightsModelConfiguration;
    patients: Array<PatientRecord>;
}

// @public
export interface RadiologyInsightsInference extends Extendible {
    kind: string;
}

// @public
export interface RadiologyInsightsInferenceOptions {
    finding?: FindingOptions;
    followupRecommendation?: FollowupRecommendationOptions;
}

// @public
export interface RadiologyInsightsInferenceResult {
    modelVersion: string;
    patientResults: Array<RadiologyInsightsPatientResult>;
}

// @public (undocumented)
export type RadiologyInsightsInferenceType = "ageMismatch" | "lateralityDiscrepancy" | "sexMismatch" | "completeOrderDiscrepancy" | "limitedOrderDiscrepancy" | "finding" | "criticalResult" | "followupRecommendation" | "followupCommunication" | "radiologyProcedure";

// @public
export type RadiologyInsightsInferenceUnion = AgeMismatchInference | SexMismatchInference | LateralityDiscrepancyInference | CompleteOrderDiscrepancyInference | LimitedOrderDiscrepancyInference | FindingInference | CriticalResultInference | RadiologyProcedureInference | FollowupRecommendationInference | FollowupCommunicationInference | RadiologyInsightsInference;

// @public
export interface RadiologyInsightsModelConfiguration {
    includeEvidence?: boolean;
    inferenceOptions?: RadiologyInsightsInferenceOptions;
    inferenceTypes?: RadiologyInsightsInferenceType[];
    locale?: string;
    verbose?: boolean;
}

// @public
export interface RadiologyInsightsPatientResult {
    inferences: Array<RadiologyInsightsInferenceUnion>;
    patientId: string;
}

// @public
export interface RadiologyInsightsResult {
    readonly createdDateTime?: Date;
    error?: ErrorModel;
    readonly expirationDateTime?: Date;
    readonly id: string;
    readonly lastUpdateDateTime?: Date;
    result?: RadiologyInsightsInferenceResult;
    readonly status: JobStatus;
}

// @public
export interface RadiologyProcedureInference extends RadiologyInsightsInference {
    imagingProcedures: Array<ImagingProcedure>;
    kind: "radiologyProcedure";
    orderedProcedure: OrderedProcedure;
    procedureCodes?: Array<CodeableConcept>;
}

// @public
export interface Range extends Element {
    high?: Quantity;
    low?: Quantity;
}

// @public
export interface Ratio extends Element {
    denominator?: Quantity;
    numerator?: Quantity;
}

// @public
export interface RecommendationFinding extends Extendible {
    criticalFinding?: CriticalResult;
    finding?: Observation;
    recommendationFindingStatus: RecommendationFindingStatusType;
}

// @public (undocumented)
export type RecommendationFindingStatusType = "present" | "differential" | "ruleOut" | "conditional";

// @public
export interface Reference extends Element {
    display?: string;
    identifier?: Identifier;
    reference?: string;
    type?: string;
}

// @public (undocumented)
export type RepeatabilityResult = "accepted" | "rejected";

// @public
export interface ResearchStudy extends DomainResource {
    arm?: {
        name: string;
        type?: CodeableConcept;
        description?: string;
    }[];
    category?: Array<CodeableConcept>;
    condition?: Array<CodeableConcept>;
    contact?: Array<ContactDetail>;
    description?: string;
    enrollment?: Array<Reference>;
    focus?: Array<CodeableConcept>;
    identifier?: Array<Identifier>;
    keyword?: Array<CodeableConcept>;
    location?: Array<CodeableConcept>;
    note?: Array<Annotation>;
    objective?: {
        name: string;
        type?: CodeableConcept;
    }[];
    partOf?: Array<Reference>;
    period?: Period;
    phase?: CodeableConcept;
    primaryPurposeType?: CodeableConcept;
    principalInvestigator?: Reference;
    protocol?: Array<Reference>;
    reasonStopped?: CodeableConcept;
    resourceType: "ResearchStudy";
    site?: Array<Reference>;
    sponsor?: Reference;
    status: ResearchStudyStatusCodeType;
    title?: string;
}

// @public (undocumented)
export type ResearchStudyStatusCodeType = "active" | "administratively-completed" | "approved" | "closed-to-accrual" | "closed-to-accrual-and-intervention" | "completed" | "disapproved" | "in-review" | "temporarily-closed-to-accrual" | "temporarily-closed-to-accrual-and-intervention" | "withdrawn";

// @public
export interface Resource {
    id?: string;
    implicitRules?: string;
    language?: string;
    meta?: Meta;
    resourceType: string;
}

// @public
export interface SampledData extends Element {
    data?: string;
    dimensions: number;
    factor?: number;
    lowerLimit?: number;
    origin: Quantity;
    period: number;
    upperLimit?: number;
}

// @public
export interface SexMismatchInference extends RadiologyInsightsInference {
    kind: "sexMismatch";
    sexIndication: CodeableConcept;
}

<<<<<<< HEAD
// @public (undocumented)
=======
// @public
export interface SexMismatchInferenceOutput extends RadiologyInsightsInferenceOutputParent {
    kind: "sexMismatch";
    sexIndication: CodeableConceptOutput;
}

// @public
export interface SimplePollerLike<TState extends OperationState<TResult>, TResult> {
    getOperationState(): TState;
    getResult(): TResult | undefined;
    isDone(): boolean;
    isStopped(): boolean;
    onProgress(callback: (state: TState) => void): CancelOnProgress;
    poll(options?: {
        abortSignal?: AbortSignalLike;
    }): Promise<TState>;
    pollUntilDone(pollOptions?: {
        abortSignal?: AbortSignalLike;
    }): Promise<TResult>;
    serialize(): Promise<string>;
    // @deprecated
    stopPolling(): void;
    submitted(): Promise<void>;
    // @deprecated
    toString(): string;
}

// @public
>>>>>>> main
export type SpecialtyType = "pathology" | "radiology";

// @public
export interface TimePeriod {
    end?: Date;
    start?: Date;
}

// (No @packageDocumentation comment for this package)

```
