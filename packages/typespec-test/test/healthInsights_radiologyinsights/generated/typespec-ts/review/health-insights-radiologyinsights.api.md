## API Report File for "@azure-rest/health-insights-radiologyinsights"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbortSignalLike } from '@azure/abort-controller';
import { ClientOptions } from '@azure-rest/core-client';
import { KeyCredential } from '@azure/core-auth';
import { OperationOptions } from '@azure-rest/core-client';
import { OperationState } from '@azure/core-lro';
import { PathUncheckedResponse } from '@azure-rest/core-client';
import { Pipeline } from '@azure/core-rest-pipeline';
import { PollerLike } from '@azure/core-lro';

// @public
export interface AgeMismatchInference extends RadiologyInsightsInference {
    kind: "ageMismatch";
}

// @public
export interface Annotation extends Element {
    authorString?: string;
    text: string;
    time?: string;
}

// @public
export type ClinicalDocumentType = "consultation" | "dischargeSummary" | "historyAndPhysical" | "radiologyReport" | "procedure" | "progress" | "laboratory" | "pathologyReport";

// @public
export interface CodeableConcept extends Element {
    coding?: Coding[];
    text?: string;
}

// @public
export interface Coding extends Element {
    code?: string;
    display?: string;
    system?: string;
    version?: string;
}

// @public
export interface CompleteOrderDiscrepancyInference extends RadiologyInsightsInference {
    kind: "completeOrderDiscrepancy";
    missingBodyPartMeasurements?: CodeableConcept[];
    missingBodyParts?: CodeableConcept[];
    orderType: CodeableConcept;
}

// @public
export interface CriticalResult {
    description: string;
    finding?: Observation;
}

// @public
export interface CriticalResultInference extends RadiologyInsightsInference {
    kind: "criticalResult";
    result: CriticalResult;
}

// @public
export interface DocumentAdministrativeMetadata {
    encounterId?: string;
    orderedProcedures?: OrderedProcedure[];
}

// @public
export interface DocumentAuthor {
    fullName?: string;
    id?: string;
}

// @public
export interface DocumentContent {
    sourceType: DocumentContentSourceType;
    value: string;
}

// @public
export type DocumentContentSourceType = "inline" | "reference";

// @public
export type DocumentType = "note" | "fhirBundle" | "dicom" | "genomicSequencing";

// @public
export interface DomainResource extends Resource {
    contained?: Resource[];
    extension?: Extension[];
    modifierExtension?: Extension[];
    resourceType: string;
    text?: Narrative;
}

// @public
export type DomainResourceUnion = Observation | DomainResource;

// @public
export interface Element {
    extension?: Extension[];
    id?: string;
}

// @public
export interface Encounter {
    class?: EncounterClass;
    id: string;
    period?: TimePeriod;
}

// @public
export type EncounterClass = "inpatient" | "ambulatory" | "observation" | "emergency" | "virtual" | "healthHome";

// @public
export interface Extendible {
    extension?: Extension[];
}

// @public
export interface Extension extends Element {
    url: string;
    valueBoolean?: boolean;
    valueCodeableConcept?: CodeableConcept;
    valueDateTime?: string;
    valueInteger?: number;
    valuePeriod?: Period;
    valueQuantity?: Quantity;
    valueRange?: Range;
    valueRatio?: Ratio;
    valueReference?: Reference;
    valueSampledData?: SampledData;
    valueString?: string;
    valueTime?: string;
}

// @public
export interface FindingInference extends RadiologyInsightsInference {
    finding: Observation;
    kind: "finding";
}

// @public
export interface FindingOptions {
    provideFocusedSentenceEvidence?: boolean;
}

// @public
export interface FollowupCommunicationInference extends RadiologyInsightsInference {
    dateTime?: Date[];
    kind: "followupCommunication";
    recipient?: MedicalProfessionalType[];
    wasAcknowledged: boolean;
}

// @public
export interface FollowupRecommendationInference extends RadiologyInsightsInference {
    effectiveDateTime?: string;
    effectivePeriod?: Period;
    findings?: RecommendationFinding[];
    isConditional: boolean;
    isGuideline: boolean;
    isHedging: boolean;
    isOption: boolean;
    kind: "followupRecommendation";
    recommendedProcedure: ProcedureRecommendationUnion;
}

// @public
export interface FollowupRecommendationOptions {
    includeRecommendationsInReferences?: boolean;
    includeRecommendationsWithNoSpecifiedModality?: boolean;
    provideFocusedSentenceEvidence?: boolean;
}

// @public
export interface GenericProcedureRecommendation extends ProcedureRecommendation {
    code: CodeableConcept;
    description?: string;
    kind: "genericProcedureRecommendation";
}

// @public
export interface Identifier extends Element {
    assigner?: Reference;
    period?: Period;
    system?: string;
    type?: CodeableConcept;
    use?: string;
    value?: string;
}

// @public
export interface ImagingProcedure {
    anatomy: CodeableConcept;
    contrast?: RadiologyCodeWithTypes;
    laterality?: CodeableConcept;
    modality: CodeableConcept;
    view?: RadiologyCodeWithTypes;
}

// @public
export interface ImagingProcedureRecommendation extends ProcedureRecommendation {
    imagingProcedures: ImagingProcedure[];
    kind: "imagingProcedureRecommendation";
    procedureCodes?: CodeableConcept[];
}

// @public
export interface InferRadiologyInsightsOptionalParams extends OperationOptions {
    configuration?: RadiologyInsightsModelConfiguration;
    repeatabilityFirstSent?: Date;
    repeatabilityRequestId?: string;
    updateIntervalInMs?: number;
}

// @public
export enum KnownApiVersion {
    // (undocumented)
    v2023_09_01_Preview = "2023-09-01-preview"
}

// @public
export interface LateralityDiscrepancyInference extends RadiologyInsightsInference {
    discrepancyType: LateralityDiscrepancyType;
    kind: "lateralityDiscrepancy";
    lateralityIndication?: CodeableConcept;
}

// @public
export type LateralityDiscrepancyType = "orderLateralityMismatch" | "textLateralityContradiction" | "textLateralityMissing";

// @public
export interface LimitedOrderDiscrepancyInference extends RadiologyInsightsInference {
    kind: "limitedOrderDiscrepancy";
    orderType: CodeableConcept;
    presentBodyPartMeasurements?: CodeableConcept[];
    presentBodyParts?: CodeableConcept[];
}

// @public
export type MedicalProfessionalType = "unknown" | "doctor" | "nurse" | "midwife" | "physicianAssistant";

// @public
export interface Meta {
    lastUpdated?: string;
    profile?: string[];
    security?: Coding[];
    source?: string;
    tag?: Coding[];
    versionId?: string;
}

// @public
export interface Narrative extends Element {
    div: string;
    status: string;
}

// @public
export interface Observation extends DomainResource {
    bodySite?: CodeableConcept;
    category?: CodeableConcept[];
    code: CodeableConcept;
    component?: ObservationComponent[];
    dataAbsentReason?: CodeableConcept;
    derivedFrom?: Reference[];
    effectiveDateTime?: string;
    effectiveInstant?: string;
    effectivePeriod?: Period;
    encounter?: Reference;
    hasMember?: Reference[];
    identifier?: Identifier[];
    interpretation?: CodeableConcept[];
    issued?: string;
    method?: CodeableConcept;
    note?: Annotation[];
    referenceRange?: ObservationReferenceRange[];
    resourceType: "Observation";
    status: ObservationStatusCodeType;
    subject?: Reference;
    valueBoolean?: boolean;
    valueCodeableConcept?: CodeableConcept;
    valueDateTime?: string;
    valueInteger?: number;
    valuePeriod?: Period;
    valueQuantity?: Quantity;
    valueRange?: Range;
    valueRatio?: Ratio;
    valueSampledData?: SampledData;
    valueString?: string;
    valueTime?: string;
}

// @public
export interface ObservationComponent extends Element {
    code: CodeableConcept;
    dataAbsentReason?: CodeableConcept;
    interpretation?: CodeableConcept[];
    referenceRange?: ObservationReferenceRange[];
    valueBoolean?: boolean;
    valueCodeableConcept?: CodeableConcept;
    valueDateTime?: string;
    valueInteger?: number;
    valuePeriod?: Period;
    valueQuantity?: Quantity;
    valueRange?: Range;
    valueRatio?: Ratio;
    valueReference?: Reference;
    valueSampledData?: SampledData;
    valueString?: string;
    valueTime?: string;
}

// @public
export interface ObservationReferenceRange {
    age?: Range;
    appliesTo?: CodeableConcept[];
    high?: Quantity;
    low?: Quantity;
    text?: string;
    type?: CodeableConcept;
}

// @public
export type ObservationStatusCodeType = "registered" | "preliminary" | "final" | "amended" | "corrected" | "cancelled" | "entered-in-error" | "unknown";

// @public
export interface OrderedProcedure extends Extendible {
    code?: CodeableConcept;
    description?: string;
}

// @public
export interface PatientDocument {
    administrativeMetadata?: DocumentAdministrativeMetadata;
    authors?: DocumentAuthor[];
    clinicalType?: ClinicalDocumentType;
    content: DocumentContent;
    createdDateTime?: Date;
    id: string;
    language?: string;
    specialtyType?: SpecialtyType;
    type: DocumentType;
}

// @public
export interface PatientInfo {
    birthDate?: string;
    clinicalInfo?: Resource[];
    sex?: PatientInfoSex;
}

// @public
export type PatientInfoSex = "female" | "male" | "unspecified";

// @public
export interface PatientRecord {
    encounters?: Encounter[];
    id: string;
    info?: PatientInfo;
    patientDocuments?: PatientDocument[];
}

// @public
export interface Period extends Element {
    end?: string;
    start?: string;
}

// @public
export interface ProcedureRecommendation {
    kind: string;
}

// @public
export type ProcedureRecommendationUnion = GenericProcedureRecommendation | ImagingProcedureRecommendation | ProcedureRecommendation;

// @public
export interface Quantity extends Element {
    code?: string;
    comparator?: string;
    system?: string;
    unit?: string;
    value?: number;
}

// @public
export interface RadiologyCodeWithTypes {
    code: CodeableConcept;
    types: CodeableConcept[];
}

// @public (undocumented)
export class RadiologyInsightsClient {
    constructor(endpointParam: string, credential: KeyCredential, options?: RadiologyInsightsClientOptionalParams);
    inferRadiologyInsights(patients: PatientRecord[], options?: InferRadiologyInsightsOptionalParams): PollerLike<OperationState<RadiologyInsightsInferenceResult>, RadiologyInsightsInferenceResult>;
    readonly pipeline: Pipeline;
}

// @public
export interface RadiologyInsightsClientOptionalParams extends ClientOptions {
    apiVersion?: string;
}

// @public
export interface RadiologyInsightsInference extends Extendible {
    kind: RadiologyInsightsInferenceType;
}

// @public
export interface RadiologyInsightsInferenceOptions {
    finding?: FindingOptions;
    followupRecommendation?: FollowupRecommendationOptions;
}

// @public
export interface RadiologyInsightsInferenceResult {
    modelVersion: string;
    patientResults: RadiologyInsightsPatientResult[];
}

// @public
export type RadiologyInsightsInferenceType = "ageMismatch" | "lateralityDiscrepancy" | "sexMismatch" | "completeOrderDiscrepancy" | "limitedOrderDiscrepancy" | "finding" | "criticalResult" | "followupRecommendation" | "followupCommunication" | "radiologyProcedure";

// @public
export type RadiologyInsightsInferenceUnion = AgeMismatchInference | SexMismatchInference | LateralityDiscrepancyInference | CompleteOrderDiscrepancyInference | LimitedOrderDiscrepancyInference | FindingInference | CriticalResultInference | RadiologyProcedureInference | FollowupRecommendationInference | FollowupCommunicationInference | RadiologyInsightsInference;

// @public
export interface RadiologyInsightsModelConfiguration {
    includeEvidence?: boolean;
    inferenceOptions?: RadiologyInsightsInferenceOptions;
    inferenceTypes?: RadiologyInsightsInferenceType[];
    locale?: string;
    verbose?: boolean;
}

// @public
export interface RadiologyInsightsPatientResult {
    inferences: RadiologyInsightsInferenceUnion[];
    patientId: string;
}

// @public
export interface RadiologyProcedureInference extends RadiologyInsightsInference {
    imagingProcedures: ImagingProcedure[];
    kind: "radiologyProcedure";
    orderedProcedure: OrderedProcedure;
    procedureCodes?: CodeableConcept[];
}

// @public
export interface Range extends Element {
    high?: Quantity;
    low?: Quantity;
}

// @public
export interface Ratio extends Element {
    denominator?: Quantity;
    numerator?: Quantity;
}

// @public
export interface RecommendationFinding extends Extendible {
    criticalFinding?: CriticalResult;
    finding?: Observation;
    recommendationFindingStatus: RecommendationFindingStatusType;
}

// @public
export type RecommendationFindingStatusType = "present" | "differential" | "ruleOut" | "conditional";

// @public
export interface Reference extends Element {
    display?: string;
    identifier?: Identifier;
    reference?: string;
    type?: string;
}

// @public
export type RepeatabilityResult = "accepted" | "rejected";

// @public
export interface Resource {
    additionalProperties?: Record<string, any>;
    id?: string;
    implicitRules?: string;
    language?: string;
    meta?: Meta;
    resourceType: string;
}

// @public
export function restorePoller<TResponse extends PathUncheckedResponse, TResult>(client: RadiologyInsightsClient, serializedState: string, sourceOperation: (...args: any[]) => PollerLike<OperationState<TResult>, TResult>, options?: RestorePollerOptions<TResult>): PollerLike<OperationState<TResult>, TResult>;

// @public (undocumented)
export interface RestorePollerOptions<TResult, TResponse extends PathUncheckedResponse = PathUncheckedResponse> extends OperationOptions {
    abortSignal?: AbortSignalLike;
    processResponseBody?: (result: TResponse) => Promise<TResult>;
    updateIntervalInMs?: number;
}

// @public
export interface SampledData extends Element {
    data?: string;
    dimensions: number;
    factor?: number;
    lowerLimit?: number;
    origin: Quantity;
    period: number;
    upperLimit?: number;
}

// @public
export interface SexMismatchInference extends RadiologyInsightsInference {
    kind: "sexMismatch";
    sexIndication: CodeableConcept;
}

// @public
export type SpecialtyType = "pathology" | "radiology";

// @public
export interface TimePeriod {
    end?: Date;
    start?: Date;
}

// (No @packageDocumentation comment for this package)

```
