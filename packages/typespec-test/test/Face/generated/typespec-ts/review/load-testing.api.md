## API Report File for "@azure/load-testing"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbortSignalLike } from '@azure/abort-controller';
import { ClientOptions } from '@azure-rest/core-client';
import { KeyCredential } from '@azure/core-auth';
import { OperationOptions } from '@azure-rest/core-client';
import { OperationState as OperationState_2 } from '@azure/core-lro';
import { PathUncheckedResponse } from '@azure-rest/core-client';
import { Pipeline } from '@azure/core-rest-pipeline';
import { PollerLike } from '@azure/core-lro';
import { TokenCredential } from '@azure/core-auth';

// @public
export interface AbuseMonitoringResult {
    isAbuseDetected: HttpPart2;
    otherFlaggedSessions: OtherFlaggedSessions[];
}

// @public
export interface AccessoryItem {
    confidence: number;
    type: AccessoryType;
}

// @public
export type AccessoryType = "headwear" | "glasses" | "mask";

// @public
export interface AddFaceResult {
    persistedFaceId: string;
}

// @public
export type BlurLevel = "low" | "medium" | "high";

// @public
export interface BlurProperties {
    blurLevel: BlurLevel;
    value: number;
}

// @public
export interface ClientInformation {
    ip: string;
}

// @public
export interface CreateLivenessSessionContent {
    authTokenTimeToLiveInSeconds?: number;
    deviceCorrelationId?: string;
    deviceCorrelationIdSetInClient?: boolean;
    enableSessionImage?: boolean;
    expectedClientIpAddress?: string;
    livenessModelVersion?: LivenessModel;
    livenessOperationMode: LivenessOperationMode;
    numberOfClientAttemptsAllowed?: HttpPart;
    userCorrelationId?: string;
    userCorrelationIdSetInClient?: boolean;
}

// @public
export interface CreateLivenessSessionOptionalParams extends OperationOptions {
}

// @public
export interface CreateLivenessWithVerifySessionContent {
    authTokenTimeToLiveInSeconds?: number;
    deviceCorrelationId?: string;
    deviceCorrelationIdSetInClient?: boolean;
    enableSessionImage?: boolean;
    livenessModelVersion?: LivenessModel;
    livenessOperationMode: LivenessOperationMode;
    numberOfClientAttemptsAllowed?: number;
    returnVerifyImageHash?: boolean;
    verifyConfidenceThreshold?: number;
    verifyImage: FileContents | {
        contents: FileContents;
        contentType?: string;
        filename?: string;
    };
}

// @public
export interface CreateLivenessWithVerifySessionOptionalParams extends OperationOptions {
}

// @public
export interface CreatePersonResult {
    personId: string;
}

// @public
export interface DeleteLivenessSessionOptionalParams extends OperationOptions {
}

// @public
export interface DeleteLivenessWithVerifySessionOptionalParams extends OperationOptions {
}

// @public
export interface DetectFromSessionImageOptionalParams extends OperationOptions {
    detectionModel?: FaceDetectionModel;
    faceIdTimeToLive?: number;
    recognitionModel?: FaceRecognitionModel;
    returnFaceAttributes?: FaceAttributeType[];
    returnFaceId?: boolean;
    returnFaceLandmarks?: boolean;
    returnRecognitionModel?: boolean;
}

// @public
export interface DetectFromUrlOptionalParams extends OperationOptions {
    detectionModel?: FaceDetectionModel;
    faceIdTimeToLive?: number;
    recognitionModel?: FaceRecognitionModel;
    returnFaceAttributes?: FaceAttributeType[];
    returnFaceId?: boolean;
    returnFaceLandmarks?: boolean;
    returnRecognitionModel?: boolean;
}

// @public
export interface DetectOptionalParams extends OperationOptions {
    detectionModel?: FaceDetectionModel;
    faceIdTimeToLive?: number;
    recognitionModel?: FaceRecognitionModel;
    returnFaceAttributes?: FaceAttributeType[];
    returnFaceId?: boolean;
    returnFaceLandmarks?: boolean;
    returnRecognitionModel?: boolean;
}

// @public
export type ExposureLevel = "underExposure" | "goodExposure" | "overExposure";

// @public
export interface ExposureProperties {
    exposureLevel: ExposureLevel;
    value: number;
}

// @public (undocumented)
export class FaceAdministrationClient {
    constructor(endpointParam: string, credential: KeyCredential | TokenCredential, options?: FaceAdministrationClientOptionalParams);
    readonly largeFaceList: LargeFaceListOperations;
    readonly largePersonGroup: LargePersonGroupOperations;
    readonly pipeline: Pipeline;
}

// @public
export interface FaceAdministrationClientOptionalParams extends ClientOptions {
    apiVersion?: string;
}

// @public
export interface FaceAttributes {
    accessories?: AccessoryItem[];
    age?: number;
    blur?: BlurProperties;
    exposure?: ExposureProperties;
    facialHair?: FacialHair;
    glasses?: GlassesType;
    hair?: HairProperties;
    headPose?: HeadPose;
    mask?: MaskProperties;
    noise?: NoiseProperties;
    occlusion?: OcclusionProperties;
    qualityForRecognition?: QualityForRecognition;
    smile?: number;
}

// @public
export type FaceAttributeType = "headPose" | "glasses" | "occlusion" | "accessories" | "blur" | "exposure" | "noise" | "mask" | "qualityForRecognition" | "age" | "smile" | "facialHair" | "hair";

// @public (undocumented)
export class FaceClient {
    constructor(endpointParam: string, credential: KeyCredential | TokenCredential, options?: FaceClientOptionalParams);
    detect(imageContent: Uint8Array, options?: DetectOptionalParams): Promise<FaceDetectionResult[]>;
    detectFromUrl(url: string, options?: DetectFromUrlOptionalParams): Promise<FaceDetectionResult[]>;
    findSimilar(faceId: string, faceIds: string[], options?: FindSimilarOptionalParams): Promise<FaceFindSimilarResult[]>;
    findSimilarFromLargeFaceList(faceId: string, largeFaceListId: string, options?: FindSimilarFromLargeFaceListOptionalParams): Promise<FaceFindSimilarResult[]>;
    group(faceIds: string[], options?: GroupOptionalParams): Promise<FaceGroupingResult>;
    identifyFromLargePersonGroup(faceIds: string[], largePersonGroupId: string, options?: IdentifyFromLargePersonGroupOptionalParams): Promise<FaceIdentificationResult[]>;
    readonly pipeline: Pipeline;
    verifyFaceToFace(faceId1: string, faceId2: string, options?: VerifyFaceToFaceOptionalParams): Promise<FaceVerificationResult>;
    verifyFromLargePersonGroup(faceId: string, largePersonGroupId: string, personId: string, options?: VerifyFromLargePersonGroupOptionalParams): Promise<FaceVerificationResult>;
}

// @public
export interface FaceClientOptionalParams extends ClientOptions {
    apiVersion?: string;
}

// @public
export type FaceDetectionModel = "detection_01" | "detection_02" | "detection_03";

// @public
export interface FaceDetectionResult {
    faceAttributes?: FaceAttributes;
    faceId?: string;
    faceLandmarks?: FaceLandmarks;
    faceRectangle: FaceRectangle;
    recognitionModel?: FaceRecognitionModel;
}

// @public
export interface FaceError {
    code: string;
    message: string;
}

// @public
export interface FaceErrorResponse {
    error: FaceError;
}

// @public
export interface FaceFindSimilarResult {
    confidence: number;
    faceId?: string;
    persistedFaceId?: string;
}

// @public
export interface FaceGroupingResult {
    groups: string[][];
    messyGroup: string[];
}

// @public
export interface FaceIdentificationCandidate {
    confidence: number;
    personId: string;
}

// @public
export interface FaceIdentificationResult {
    candidates: FaceIdentificationCandidate[];
    faceId: string;
}

// @public
export type FaceImageType = "Color" | "Infrared" | "Depth";

// @public
export interface FaceLandmarks {
    eyebrowLeftInner: LandmarkCoordinate;
    eyebrowLeftOuter: LandmarkCoordinate;
    eyebrowRightInner: LandmarkCoordinate;
    eyebrowRightOuter: LandmarkCoordinate;
    eyeLeftBottom: LandmarkCoordinate;
    eyeLeftInner: LandmarkCoordinate;
    eyeLeftOuter: LandmarkCoordinate;
    eyeLeftTop: LandmarkCoordinate;
    eyeRightBottom: LandmarkCoordinate;
    eyeRightInner: LandmarkCoordinate;
    eyeRightOuter: LandmarkCoordinate;
    eyeRightTop: LandmarkCoordinate;
    mouthLeft: LandmarkCoordinate;
    mouthRight: LandmarkCoordinate;
    noseLeftAlarOutTip: LandmarkCoordinate;
    noseLeftAlarTop: LandmarkCoordinate;
    noseRightAlarOutTip: LandmarkCoordinate;
    noseRightAlarTop: LandmarkCoordinate;
    noseRootLeft: LandmarkCoordinate;
    noseRootRight: LandmarkCoordinate;
    noseTip: LandmarkCoordinate;
    pupilLeft: LandmarkCoordinate;
    pupilRight: LandmarkCoordinate;
    underLipBottom: LandmarkCoordinate;
    underLipTop: LandmarkCoordinate;
    upperLipBottom: LandmarkCoordinate;
    upperLipTop: LandmarkCoordinate;
}

// @public
export type FaceLivenessDecision = "uncertain" | "realface" | "spoofface";

// @public
export type FaceOperationStatus = "notStarted" | "running" | "succeeded" | "failed";

// @public
export type FaceRecognitionModel = "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04";

// @public
export interface FaceRectangle {
    height: number;
    left: number;
    top: number;
    width: number;
}

// @public (undocumented)
export class FaceSessionClient {
    constructor(endpointParam: string, credential: KeyCredential | TokenCredential, options?: FaceSessionClientOptionalParams);
    createLivenessSession(body: CreateLivenessSessionContent, options?: CreateLivenessSessionOptionalParams): Promise<LivenessSession>;
    createLivenessWithVerifySession(body: CreateLivenessWithVerifySessionContent, options?: CreateLivenessWithVerifySessionOptionalParams): Promise<LivenessWithVerifySession>;
    deleteLivenessSession(sessionId: string, options?: DeleteLivenessSessionOptionalParams): Promise<void>;
    deleteLivenessWithVerifySession(sessionId: string, options?: DeleteLivenessWithVerifySessionOptionalParams): Promise<void>;
    detectFromSessionImage(sessionImageId: string, options?: DetectFromSessionImageOptionalParams): Promise<FaceDetectionResult[]>;
    getLivenessSessionResult(sessionId: string, options?: GetLivenessSessionResultOptionalParams): Promise<LivenessSession>;
    getLivenessWithVerifySessionResult(sessionId: string, options?: GetLivenessWithVerifySessionResultOptionalParams): Promise<LivenessWithVerifySession>;
    getSessionImage(sessionImageId: string, options?: GetSessionImageOptionalParams): Promise<Uint8Array>;
    readonly pipeline: Pipeline;
}

// @public
export interface FaceSessionClientOptionalParams extends ClientOptions {
    apiVersion?: string;
}

// @public
export interface FaceTrainingResult {
    createdDateTime: Date;
    lastActionDateTime: Date;
    lastSuccessfulTrainingDateTime: Date;
    message?: string;
    status: FaceOperationStatus;
}

// @public
export interface FaceVerificationResult {
    confidence: number;
    isIdentical: boolean;
}

// @public
export interface FacialHair {
    beard: number;
    moustache: number;
    sideburns: number;
}

// @public
export type FileContents = string | NodeJS.ReadableStream | ReadableStream<Uint8Array> | Uint8Array | Blob;

// @public
export interface FindSimilarFromLargeFaceListOptionalParams extends OperationOptions {
    maxNumOfCandidatesReturned?: number;
    mode?: FindSimilarMatchMode;
}

// @public
export type FindSimilarMatchMode = "matchPerson" | "matchFace";

// @public
export interface FindSimilarOptionalParams extends OperationOptions {
    maxNumOfCandidatesReturned?: number;
    mode?: FindSimilarMatchMode;
}

// @public
export interface GetLivenessSessionResultOptionalParams extends OperationOptions {
}

// @public
export interface GetLivenessWithVerifySessionResultOptionalParams extends OperationOptions {
}

// @public
export interface GetSessionImageOptionalParams extends OperationOptions {
}

// @public
export type GlassesType = "noGlasses" | "readingGlasses" | "sunglasses" | "swimmingGoggles";

// @public
export interface GroupOptionalParams extends OperationOptions {
}

// @public
export interface HairColor {
    color: HairColorType;
    confidence: number;
}

// @public
export type HairColorType = "unknown" | "white" | "gray" | "blond" | "brown" | "red" | "black" | "other";

// @public
export interface HairProperties {
    bald: number;
    hairColor: HairColor[];
    invisible: boolean;
}

// @public
export interface HeadPose {
    pitch: number;
    roll: number;
    yaw: number;
}

// @public
export interface HttpPart {
}

// @public
export interface HttpPart1 {
}

// @public
export interface HttpPart2 {
}

// @public
export interface IdentifyFromLargePersonGroupOptionalParams extends OperationOptions {
    confidenceThreshold?: number;
    maxNumOfCandidatesReturned?: number;
}

// @public
export interface LandmarkCoordinate {
    x: number;
    y: number;
}

// @public
export interface LargeFaceList {
    readonly largeFaceListId: string;
    name: string;
    recognitionModel?: FaceRecognitionModel;
    userData?: string;
}

// @public
export interface LargeFaceListAddFaceFromUrlOptionalParams extends OperationOptions {
    detectionModel?: FaceDetectionModel;
    targetFace?: number[];
    userData?: string;
}

// @public
export interface LargeFaceListAddFaceOptionalParams extends OperationOptions {
    detectionModel?: FaceDetectionModel;
    targetFace?: number[];
    userData?: string;
}

// @public
export interface LargeFaceListCreateOptionalParams extends OperationOptions {
    recognitionModel?: FaceRecognitionModel;
    userData?: string;
}

// @public
export interface LargeFaceListDeleteFaceOptionalParams extends OperationOptions {
}

// @public
export interface LargeFaceListDeleteOptionalParams extends OperationOptions {
}

// @public
export interface LargeFaceListFace {
    readonly persistedFaceId: string;
    userData?: string;
}

// @public
export interface LargeFaceListGetFaceOptionalParams extends OperationOptions {
}

// @public
export interface LargeFaceListGetFacesOptionalParams extends OperationOptions {
    start?: string;
    top?: number;
}

// @public
export interface LargeFaceListGetLargeFaceListsOptionalParams extends OperationOptions {
    returnRecognitionModel?: boolean;
    start?: string;
    top?: number;
}

// @public
export interface LargeFaceListGetOptionalParams extends OperationOptions {
    returnRecognitionModel?: boolean;
}

// @public
export interface LargeFaceListGetTrainingStatusOptionalParams extends OperationOptions {
}

// @public
export interface LargeFaceListOperations {
    addFace: (largeFaceListId: string, imageContent: Uint8Array, options?: LargeFaceListAddFaceOptionalParams) => Promise<AddFaceResult>;
    addFaceFromUrl: (largeFaceListId: string, url: string, options?: LargeFaceListAddFaceFromUrlOptionalParams) => Promise<AddFaceResult>;
    create: (largeFaceListId: string, name: string, options?: LargeFaceListCreateOptionalParams) => Promise<void>;
    delete: (largeFaceListId: string, options?: LargeFaceListDeleteOptionalParams) => Promise<void>;
    deleteFace: (largeFaceListId: string, persistedFaceId: string, options?: LargeFaceListDeleteFaceOptionalParams) => Promise<void>;
    get: (largeFaceListId: string, options?: LargeFaceListGetOptionalParams) => Promise<LargeFaceList>;
    getFace: (largeFaceListId: string, persistedFaceId: string, options?: LargeFaceListGetFaceOptionalParams) => Promise<LargeFaceListFace>;
    getFaces: (largeFaceListId: string, options?: LargeFaceListGetFacesOptionalParams) => Promise<LargeFaceListFace[]>;
    getLargeFaceLists: (options?: LargeFaceListGetLargeFaceListsOptionalParams) => Promise<LargeFaceList[]>;
    getTrainingStatus: (largeFaceListId: string, options?: LargeFaceListGetTrainingStatusOptionalParams) => Promise<FaceTrainingResult>;
    train: (largeFaceListId: string, options?: LargeFaceListTrainOptionalParams) => PollerLike<OperationState_2<void>, void>;
    update: (largeFaceListId: string, options?: LargeFaceListUpdateOptionalParams) => Promise<void>;
    updateFace: (largeFaceListId: string, persistedFaceId: string, options?: LargeFaceListUpdateFaceOptionalParams) => Promise<void>;
}

// @public
export interface LargeFaceListTrainOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface LargeFaceListUpdateFaceOptionalParams extends OperationOptions {
    userData?: string;
}

// @public
export interface LargeFaceListUpdateOptionalParams extends OperationOptions {
    name?: string;
    userData?: string;
}

// @public
export interface LargePersonGroup {
    readonly largePersonGroupId: string;
    name: string;
    recognitionModel?: FaceRecognitionModel;
    userData?: string;
}

// @public
export interface LargePersonGroupAddFaceFromUrlOptionalParams extends OperationOptions {
    detectionModel?: FaceDetectionModel;
    targetFace?: number[];
    userData?: string;
}

// @public
export interface LargePersonGroupAddFaceOptionalParams extends OperationOptions {
    detectionModel?: FaceDetectionModel;
    targetFace?: number[];
    userData?: string;
}

// @public
export interface LargePersonGroupCreateOptionalParams extends OperationOptions {
    recognitionModel?: FaceRecognitionModel;
    userData?: string;
}

// @public
export interface LargePersonGroupCreatePersonOptionalParams extends OperationOptions {
    userData?: string;
}

// @public
export interface LargePersonGroupDeleteFaceOptionalParams extends OperationOptions {
}

// @public
export interface LargePersonGroupDeleteOptionalParams extends OperationOptions {
}

// @public
export interface LargePersonGroupDeletePersonOptionalParams extends OperationOptions {
}

// @public
export interface LargePersonGroupGetFaceOptionalParams extends OperationOptions {
}

// @public
export interface LargePersonGroupGetLargePersonGroupsOptionalParams extends OperationOptions {
    returnRecognitionModel?: boolean;
    start?: string;
    top?: number;
}

// @public
export interface LargePersonGroupGetOptionalParams extends OperationOptions {
    returnRecognitionModel?: boolean;
}

// @public
export interface LargePersonGroupGetPersonOptionalParams extends OperationOptions {
}

// @public
export interface LargePersonGroupGetPersonsOptionalParams extends OperationOptions {
    start?: string;
    top?: number;
}

// @public
export interface LargePersonGroupGetTrainingStatusOptionalParams extends OperationOptions {
}

// @public
export interface LargePersonGroupOperations {
    addFace: (largePersonGroupId: string, personId: string, imageContent: Uint8Array, options?: LargePersonGroupAddFaceOptionalParams) => Promise<AddFaceResult>;
    addFaceFromUrl: (largePersonGroupId: string, personId: string, url: string, options?: LargePersonGroupAddFaceFromUrlOptionalParams) => Promise<AddFaceResult>;
    create: (largePersonGroupId: string, name: string, options?: LargePersonGroupCreateOptionalParams) => Promise<void>;
    createPerson: (largePersonGroupId: string, name: string, options?: LargePersonGroupCreatePersonOptionalParams) => Promise<CreatePersonResult>;
    delete: (largePersonGroupId: string, options?: LargePersonGroupDeleteOptionalParams) => Promise<void>;
    deleteFace: (largePersonGroupId: string, personId: string, persistedFaceId: string, options?: LargePersonGroupDeleteFaceOptionalParams) => Promise<void>;
    deletePerson: (largePersonGroupId: string, personId: string, options?: LargePersonGroupDeletePersonOptionalParams) => Promise<void>;
    get: (largePersonGroupId: string, options?: LargePersonGroupGetOptionalParams) => Promise<LargePersonGroup>;
    getFace: (largePersonGroupId: string, personId: string, persistedFaceId: string, options?: LargePersonGroupGetFaceOptionalParams) => Promise<LargePersonGroupPersonFace>;
    getLargePersonGroups: (options?: LargePersonGroupGetLargePersonGroupsOptionalParams) => Promise<LargePersonGroup[]>;
    getPerson: (largePersonGroupId: string, personId: string, options?: LargePersonGroupGetPersonOptionalParams) => Promise<LargePersonGroupPerson>;
    getPersons: (largePersonGroupId: string, options?: LargePersonGroupGetPersonsOptionalParams) => Promise<LargePersonGroupPerson[]>;
    getTrainingStatus: (largePersonGroupId: string, options?: LargePersonGroupGetTrainingStatusOptionalParams) => Promise<FaceTrainingResult>;
    train: (largePersonGroupId: string, options?: LargePersonGroupTrainOptionalParams) => PollerLike<OperationState_2<void>, void>;
    update: (largePersonGroupId: string, options?: LargePersonGroupUpdateOptionalParams) => Promise<void>;
    updateFace: (largePersonGroupId: string, personId: string, persistedFaceId: string, options?: LargePersonGroupUpdateFaceOptionalParams) => Promise<void>;
    updatePerson: (largePersonGroupId: string, personId: string, options?: LargePersonGroupUpdatePersonOptionalParams) => Promise<void>;
}

// @public
export interface LargePersonGroupPerson {
    name: string;
    persistedFaceIds?: string[];
    readonly personId: string;
    userData?: string;
}

// @public
export interface LargePersonGroupPersonFace {
    readonly persistedFaceId: string;
    userData?: string;
}

// @public
export interface LargePersonGroupTrainOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface LargePersonGroupUpdateFaceOptionalParams extends OperationOptions {
    userData?: string;
}

// @public
export interface LargePersonGroupUpdateOptionalParams extends OperationOptions {
    name?: string;
    userData?: string;
}

// @public
export interface LargePersonGroupUpdatePersonOptionalParams extends OperationOptions {
    name?: string;
    userData?: string;
}

// @public
export interface LivenessColorDecisionTarget {
    faceRectangle: FaceRectangle;
}

// @public
export interface LivenessDecisionTargets {
    color: LivenessColorDecisionTarget;
}

// @public
export interface LivenessError {
    code: string;
    message: string;
    targets: LivenessDecisionTargets;
}

// @public
export type LivenessModel = "2024-11-15";

// @public
export type LivenessOperationMode = "Passive" | "PassiveActive";

// @public
export interface LivenessResult {
    digest: string;
    livenessDecision?: FaceLivenessDecision;
    sessionImageId?: string;
    targets: LivenessDecisionTargets;
}

// @public
export interface LivenessSession {
    authToken: string;
    expectedClientIpAddress?: string;
    isAbuseMonitoringEnabled?: HttpPart1;
    modelVersion?: LivenessModel;
    results: LivenessSessionResults;
    readonly sessionId: string;
    status: OperationState;
}

// @public
export interface LivenessSessionAttempt {
    abuseMonitoringResult?: AbuseMonitoringResult;
    attemptId: number;
    attemptStatus: OperationState;
    clientInformation?: ClientInformation[];
    error?: LivenessError;
    result?: LivenessResult;
}

// @public
export interface LivenessSessionResults {
    attempts: LivenessSessionAttempt[];
}

// @public
export interface LivenessWithVerifyOutputs {
    isIdentical: boolean;
    matchConfidence: number;
}

// @public
export interface LivenessWithVerifyReference {
    faceRectangle: FaceRectangle;
    qualityForRecognition: QualityForRecognition;
    referenceType: FaceImageType;
}

// @public
export interface LivenessWithVerifyResult {
    digest: string;
    livenessDecision?: FaceLivenessDecision;
    sessionImageId?: string;
    targets: LivenessDecisionTargets;
    verifyImageHash?: string;
    verifyResult?: LivenessWithVerifyOutputs;
}

// @public
export interface LivenessWithVerifySession {
    authToken: string;
    expectedClientIpAddress?: string;
    isAbuseMonitoringEnabled?: HttpPart1;
    modelVersion?: LivenessModel;
    results: LivenessWithVerifySessionResults;
    readonly sessionId: string;
    status: OperationState;
}

// @public
export interface LivenessWithVerifySessionAttempt {
    abuseMonitoringResult?: AbuseMonitoringResult;
    attemptId: number;
    attemptStatus: OperationState;
    clientInformation?: ClientInformation[];
    error?: LivenessError;
    result?: LivenessWithVerifyResult;
}

// @public
export interface LivenessWithVerifySessionResults {
    attempts: LivenessWithVerifySessionAttempt[];
    verifyReferences: LivenessWithVerifyReference[];
}

// @public
export interface MaskProperties {
    noseAndMouthCovered: boolean;
    type: MaskType;
}

// @public
export type MaskType = "faceMask" | "noMask" | "otherMaskOrOcclusion" | "uncertain";

// @public
export type NoiseLevel = "low" | "medium" | "high";

// @public
export interface NoiseProperties {
    noiseLevel: NoiseLevel;
    value: number;
}

// @public
export interface OcclusionProperties {
    eyeOccluded: boolean;
    foreheadOccluded: boolean;
    mouthOccluded: boolean;
}

// @public
export type OperationState = "NotStarted" | "Running" | "Succeeded" | "Failed" | "Canceled";

// @public
export interface OtherFlaggedSessions {
    attemptId: number;
    sessionId: string;
    sessionImageId?: string;
}

// @public
export type QualityForRecognition = "low" | "medium" | "high";

// @public
export function restorePoller<TResponse extends PathUncheckedResponse, TResult>(client: FaceAdministrationClient, serializedState: string, sourceOperation: (...args: any[]) => PollerLike<OperationState_2<TResult>, TResult>, options?: RestorePollerOptions<TResult>): PollerLike<OperationState_2<TResult>, TResult>;

// @public (undocumented)
export interface RestorePollerOptions<TResult, TResponse extends PathUncheckedResponse = PathUncheckedResponse> extends OperationOptions {
    abortSignal?: AbortSignalLike;
    processResponseBody?: (result: TResponse) => Promise<TResult>;
    updateIntervalInMs?: number;
}

// @public
export interface VerifyFaceToFaceOptionalParams extends OperationOptions {
}

// @public
export interface VerifyFromLargePersonGroupOptionalParams extends OperationOptions {
}

// @public
export type Versions = "v1.1-preview.1" | "v1.2-preview.1" | "v1.2" | "v1.3-preview.1";

// (No @packageDocumentation comment for this package)

```
