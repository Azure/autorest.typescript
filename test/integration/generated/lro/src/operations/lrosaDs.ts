/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { tracingClient } from "../tracing";
import { LrosaDs } from "../operationsInterfaces";
import * as coreClient from "@azure/core-client";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
import { LROClient } from "../lROClient";
import { PollerLike, PollOperationState, LroEngine } from "@azure/core-lro";
import { LroImpl } from "../lroImpl";
import {
  LrosaDsPutNonRetry400OptionalParams,
  LrosaDsPutNonRetry400Response,
  LrosaDsPutNonRetry201Creating400OptionalParams,
  LrosaDsPutNonRetry201Creating400Response,
  LrosaDsPutNonRetry201Creating400InvalidJsonOptionalParams,
  LrosaDsPutNonRetry201Creating400InvalidJsonResponse,
  LrosaDsPutAsyncRelativeRetry400OptionalParams,
  LrosaDsPutAsyncRelativeRetry400Response,
  LrosaDsDeleteNonRetry400OptionalParams,
  LrosaDsDeleteNonRetry400Response,
  LrosaDsDelete202NonRetry400OptionalParams,
  LrosaDsDelete202NonRetry400Response,
  LrosaDsDeleteAsyncRelativeRetry400OptionalParams,
  LrosaDsDeleteAsyncRelativeRetry400Response,
  LrosaDsPostNonRetry400OptionalParams,
  LrosaDsPostNonRetry400Response,
  LrosaDsPost202NonRetry400OptionalParams,
  LrosaDsPost202NonRetry400Response,
  LrosaDsPostAsyncRelativeRetry400OptionalParams,
  LrosaDsPostAsyncRelativeRetry400Response,
  LrosaDsPutError201NoProvisioningStatePayloadOptionalParams,
  LrosaDsPutError201NoProvisioningStatePayloadResponse,
  LrosaDsPutAsyncRelativeRetryNoStatusOptionalParams,
  LrosaDsPutAsyncRelativeRetryNoStatusResponse,
  LrosaDsPutAsyncRelativeRetryNoStatusPayloadOptionalParams,
  LrosaDsPutAsyncRelativeRetryNoStatusPayloadResponse,
  LrosaDsDelete204SucceededOptionalParams,
  LrosaDsDeleteAsyncRelativeRetryNoStatusOptionalParams,
  LrosaDsDeleteAsyncRelativeRetryNoStatusResponse,
  LrosaDsPost202NoLocationOptionalParams,
  LrosaDsPost202NoLocationResponse,
  LrosaDsPostAsyncRelativeRetryNoPayloadOptionalParams,
  LrosaDsPostAsyncRelativeRetryNoPayloadResponse,
  LrosaDsPut200InvalidJsonOptionalParams,
  LrosaDsPut200InvalidJsonResponse,
  LrosaDsPutAsyncRelativeRetryInvalidHeaderOptionalParams,
  LrosaDsPutAsyncRelativeRetryInvalidHeaderResponse,
  LrosaDsPutAsyncRelativeRetryInvalidJsonPollingOptionalParams,
  LrosaDsPutAsyncRelativeRetryInvalidJsonPollingResponse,
  LrosaDsDelete202RetryInvalidHeaderOptionalParams,
  LrosaDsDelete202RetryInvalidHeaderResponse,
  LrosaDsDeleteAsyncRelativeRetryInvalidHeaderOptionalParams,
  LrosaDsDeleteAsyncRelativeRetryInvalidHeaderResponse,
  LrosaDsDeleteAsyncRelativeRetryInvalidJsonPollingOptionalParams,
  LrosaDsDeleteAsyncRelativeRetryInvalidJsonPollingResponse,
  LrosaDsPost202RetryInvalidHeaderOptionalParams,
  LrosaDsPost202RetryInvalidHeaderResponse,
  LrosaDsPostAsyncRelativeRetryInvalidHeaderOptionalParams,
  LrosaDsPostAsyncRelativeRetryInvalidHeaderResponse,
  LrosaDsPostAsyncRelativeRetryInvalidJsonPollingOptionalParams,
  LrosaDsPostAsyncRelativeRetryInvalidJsonPollingResponse
} from "../models";

/** Class containing LrosaDs operations. */
export class LrosaDsImpl implements LrosaDs {
  private readonly client: LROClient;

  /**
   * Initialize a new instance of the class LrosaDs class.
   * @param client Reference to the service client
   */
  constructor(client: LROClient) {
    this.client = client;
  }

  /**
   * Long running put request, service returns a 400 to the initial request
   * @param options The options parameters.
   */
  async beginPutNonRetry400(
    options?: LrosaDsPutNonRetry400OptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrosaDsPutNonRetry400Response>,
      LrosaDsPutNonRetry400Response
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrosaDsPutNonRetry400Response> => {
      return tracingClient.withSpan(
        "LROClient.beginPutNonRetry400",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(args, spec) as Promise<
            LrosaDsPutNonRetry400Response
          >;
        }
      );
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      putNonRetry400OperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running put request, service returns a 400 to the initial request
   * @param options The options parameters.
   */
  async beginPutNonRetry400AndWait(
    options?: LrosaDsPutNonRetry400OptionalParams
  ): Promise<LrosaDsPutNonRetry400Response> {
    const poller = await this.beginPutNonRetry400(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201
   * response code
   * @param options The options parameters.
   */
  async beginPutNonRetry201Creating400(
    options?: LrosaDsPutNonRetry201Creating400OptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrosaDsPutNonRetry201Creating400Response>,
      LrosaDsPutNonRetry201Creating400Response
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrosaDsPutNonRetry201Creating400Response> => {
      return tracingClient.withSpan(
        "LROClient.beginPutNonRetry201Creating400",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(args, spec) as Promise<
            LrosaDsPutNonRetry201Creating400Response
          >;
        }
      );
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      putNonRetry201Creating400OperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201
   * response code
   * @param options The options parameters.
   */
  async beginPutNonRetry201Creating400AndWait(
    options?: LrosaDsPutNonRetry201Creating400OptionalParams
  ): Promise<LrosaDsPutNonRetry201Creating400Response> {
    const poller = await this.beginPutNonRetry201Creating400(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201
   * response code
   * @param options The options parameters.
   */
  async beginPutNonRetry201Creating400InvalidJson(
    options?: LrosaDsPutNonRetry201Creating400InvalidJsonOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrosaDsPutNonRetry201Creating400InvalidJsonResponse>,
      LrosaDsPutNonRetry201Creating400InvalidJsonResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrosaDsPutNonRetry201Creating400InvalidJsonResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPutNonRetry201Creating400InvalidJson",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(args, spec) as Promise<
            LrosaDsPutNonRetry201Creating400InvalidJsonResponse
          >;
        }
      );
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      putNonRetry201Creating400InvalidJsonOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201
   * response code
   * @param options The options parameters.
   */
  async beginPutNonRetry201Creating400InvalidJsonAndWait(
    options?: LrosaDsPutNonRetry201Creating400InvalidJsonOptionalParams
  ): Promise<LrosaDsPutNonRetry201Creating400InvalidJsonResponse> {
    const poller = await this.beginPutNonRetry201Creating400InvalidJson(
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 200 with ProvisioningState=’Creating’. Poll the endpoint
   * indicated in the Azure-AsyncOperation header for operation status
   * @param options The options parameters.
   */
  async beginPutAsyncRelativeRetry400(
    options?: LrosaDsPutAsyncRelativeRetry400OptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrosaDsPutAsyncRelativeRetry400Response>,
      LrosaDsPutAsyncRelativeRetry400Response
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrosaDsPutAsyncRelativeRetry400Response> => {
      return tracingClient.withSpan(
        "LROClient.beginPutAsyncRelativeRetry400",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(args, spec) as Promise<
            LrosaDsPutAsyncRelativeRetry400Response
          >;
        }
      );
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      putAsyncRelativeRetry400OperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running put request, service returns a 200 with ProvisioningState=’Creating’. Poll the endpoint
   * indicated in the Azure-AsyncOperation header for operation status
   * @param options The options parameters.
   */
  async beginPutAsyncRelativeRetry400AndWait(
    options?: LrosaDsPutAsyncRelativeRetry400OptionalParams
  ): Promise<LrosaDsPutAsyncRelativeRetry400Response> {
    const poller = await this.beginPutAsyncRelativeRetry400(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running delete request, service returns a 400 with an error body
   * @param options The options parameters.
   */
  async beginDeleteNonRetry400(
    options?: LrosaDsDeleteNonRetry400OptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrosaDsDeleteNonRetry400Response>,
      LrosaDsDeleteNonRetry400Response
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrosaDsDeleteNonRetry400Response> => {
      return tracingClient.withSpan(
        "LROClient.beginDeleteNonRetry400",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(args, spec) as Promise<
            LrosaDsDeleteNonRetry400Response
          >;
        }
      );
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      deleteNonRetry400OperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running delete request, service returns a 400 with an error body
   * @param options The options parameters.
   */
  async beginDeleteNonRetry400AndWait(
    options?: LrosaDsDeleteNonRetry400OptionalParams
  ): Promise<LrosaDsDeleteNonRetry400Response> {
    const poller = await this.beginDeleteNonRetry400(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running delete request, service returns a 202 with a location header
   * @param options The options parameters.
   */
  async beginDelete202NonRetry400(
    options?: LrosaDsDelete202NonRetry400OptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrosaDsDelete202NonRetry400Response>,
      LrosaDsDelete202NonRetry400Response
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrosaDsDelete202NonRetry400Response> => {
      return tracingClient.withSpan(
        "LROClient.beginDelete202NonRetry400",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(args, spec) as Promise<
            LrosaDsDelete202NonRetry400Response
          >;
        }
      );
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      delete202NonRetry400OperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running delete request, service returns a 202 with a location header
   * @param options The options parameters.
   */
  async beginDelete202NonRetry400AndWait(
    options?: LrosaDsDelete202NonRetry400OptionalParams
  ): Promise<LrosaDsDelete202NonRetry400Response> {
    const poller = await this.beginDelete202NonRetry400(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Poll the endpoint
   * indicated in the Azure-AsyncOperation header for operation status
   * @param options The options parameters.
   */
  async beginDeleteAsyncRelativeRetry400(
    options?: LrosaDsDeleteAsyncRelativeRetry400OptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrosaDsDeleteAsyncRelativeRetry400Response>,
      LrosaDsDeleteAsyncRelativeRetry400Response
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrosaDsDeleteAsyncRelativeRetry400Response> => {
      return tracingClient.withSpan(
        "LROClient.beginDeleteAsyncRelativeRetry400",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(args, spec) as Promise<
            LrosaDsDeleteAsyncRelativeRetry400Response
          >;
        }
      );
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      deleteAsyncRelativeRetry400OperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Poll the endpoint
   * indicated in the Azure-AsyncOperation header for operation status
   * @param options The options parameters.
   */
  async beginDeleteAsyncRelativeRetry400AndWait(
    options?: LrosaDsDeleteAsyncRelativeRetry400OptionalParams
  ): Promise<LrosaDsDeleteAsyncRelativeRetry400Response> {
    const poller = await this.beginDeleteAsyncRelativeRetry400(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running post request, service returns a 400 with no error body
   * @param options The options parameters.
   */
  async beginPostNonRetry400(
    options?: LrosaDsPostNonRetry400OptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrosaDsPostNonRetry400Response>,
      LrosaDsPostNonRetry400Response
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrosaDsPostNonRetry400Response> => {
      return tracingClient.withSpan(
        "LROClient.beginPostNonRetry400",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(args, spec) as Promise<
            LrosaDsPostNonRetry400Response
          >;
        }
      );
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      postNonRetry400OperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running post request, service returns a 400 with no error body
   * @param options The options parameters.
   */
  async beginPostNonRetry400AndWait(
    options?: LrosaDsPostNonRetry400OptionalParams
  ): Promise<LrosaDsPostNonRetry400Response> {
    const poller = await this.beginPostNonRetry400(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running post request, service returns a 202 with a location header
   * @param options The options parameters.
   */
  async beginPost202NonRetry400(
    options?: LrosaDsPost202NonRetry400OptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrosaDsPost202NonRetry400Response>,
      LrosaDsPost202NonRetry400Response
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrosaDsPost202NonRetry400Response> => {
      return tracingClient.withSpan(
        "LROClient.beginPost202NonRetry400",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(args, spec) as Promise<
            LrosaDsPost202NonRetry400Response
          >;
        }
      );
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      post202NonRetry400OperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running post request, service returns a 202 with a location header
   * @param options The options parameters.
   */
  async beginPost202NonRetry400AndWait(
    options?: LrosaDsPost202NonRetry400OptionalParams
  ): Promise<LrosaDsPost202NonRetry400Response> {
    const poller = await this.beginPost202NonRetry400(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running post request, service returns a 202 to the initial request Poll the endpoint indicated
   * in the Azure-AsyncOperation header for operation status
   * @param options The options parameters.
   */
  async beginPostAsyncRelativeRetry400(
    options?: LrosaDsPostAsyncRelativeRetry400OptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrosaDsPostAsyncRelativeRetry400Response>,
      LrosaDsPostAsyncRelativeRetry400Response
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrosaDsPostAsyncRelativeRetry400Response> => {
      return tracingClient.withSpan(
        "LROClient.beginPostAsyncRelativeRetry400",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(args, spec) as Promise<
            LrosaDsPostAsyncRelativeRetry400Response
          >;
        }
      );
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      postAsyncRelativeRetry400OperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running post request, service returns a 202 to the initial request Poll the endpoint indicated
   * in the Azure-AsyncOperation header for operation status
   * @param options The options parameters.
   */
  async beginPostAsyncRelativeRetry400AndWait(
    options?: LrosaDsPostAsyncRelativeRetry400OptionalParams
  ): Promise<LrosaDsPostAsyncRelativeRetry400Response> {
    const poller = await this.beginPostAsyncRelativeRetry400(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 201 to the initial request with no payload
   * @param options The options parameters.
   */
  async beginPutError201NoProvisioningStatePayload(
    options?: LrosaDsPutError201NoProvisioningStatePayloadOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrosaDsPutError201NoProvisioningStatePayloadResponse>,
      LrosaDsPutError201NoProvisioningStatePayloadResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrosaDsPutError201NoProvisioningStatePayloadResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPutError201NoProvisioningStatePayload",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(args, spec) as Promise<
            LrosaDsPutError201NoProvisioningStatePayloadResponse
          >;
        }
      );
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      putError201NoProvisioningStatePayloadOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running put request, service returns a 201 to the initial request with no payload
   * @param options The options parameters.
   */
  async beginPutError201NoProvisioningStatePayloadAndWait(
    options?: LrosaDsPutError201NoProvisioningStatePayloadOptionalParams
  ): Promise<LrosaDsPutError201NoProvisioningStatePayloadResponse> {
    const poller = await this.beginPutError201NoProvisioningStatePayload(
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
   * operation status
   * @param options The options parameters.
   */
  async beginPutAsyncRelativeRetryNoStatus(
    options?: LrosaDsPutAsyncRelativeRetryNoStatusOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrosaDsPutAsyncRelativeRetryNoStatusResponse>,
      LrosaDsPutAsyncRelativeRetryNoStatusResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrosaDsPutAsyncRelativeRetryNoStatusResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPutAsyncRelativeRetryNoStatus",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(args, spec) as Promise<
            LrosaDsPutAsyncRelativeRetryNoStatusResponse
          >;
        }
      );
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      putAsyncRelativeRetryNoStatusOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
   * operation status
   * @param options The options parameters.
   */
  async beginPutAsyncRelativeRetryNoStatusAndWait(
    options?: LrosaDsPutAsyncRelativeRetryNoStatusOptionalParams
  ): Promise<LrosaDsPutAsyncRelativeRetryNoStatusResponse> {
    const poller = await this.beginPutAsyncRelativeRetryNoStatus(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
   * operation status
   * @param options The options parameters.
   */
  async beginPutAsyncRelativeRetryNoStatusPayload(
    options?: LrosaDsPutAsyncRelativeRetryNoStatusPayloadOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrosaDsPutAsyncRelativeRetryNoStatusPayloadResponse>,
      LrosaDsPutAsyncRelativeRetryNoStatusPayloadResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrosaDsPutAsyncRelativeRetryNoStatusPayloadResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPutAsyncRelativeRetryNoStatusPayload",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(args, spec) as Promise<
            LrosaDsPutAsyncRelativeRetryNoStatusPayloadResponse
          >;
        }
      );
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      putAsyncRelativeRetryNoStatusPayloadOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
   * operation status
   * @param options The options parameters.
   */
  async beginPutAsyncRelativeRetryNoStatusPayloadAndWait(
    options?: LrosaDsPutAsyncRelativeRetryNoStatusPayloadOptionalParams
  ): Promise<LrosaDsPutAsyncRelativeRetryNoStatusPayloadResponse> {
    const poller = await this.beginPutAsyncRelativeRetryNoStatusPayload(
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Long running delete request, service returns a 204 to the initial request, indicating success.
   * @param options The options parameters.
   */
  async beginDelete204Succeeded(
    options?: LrosaDsDelete204SucceededOptionalParams
  ): Promise<PollerLike<PollOperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<void> => {
      return tracingClient.withSpan(
        "LROClient.beginDelete204Succeeded",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(args, spec) as Promise<void>;
        }
      );
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      delete204SucceededOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running delete request, service returns a 204 to the initial request, indicating success.
   * @param options The options parameters.
   */
  async beginDelete204SucceededAndWait(
    options?: LrosaDsDelete204SucceededOptionalParams
  ): Promise<void> {
    const poller = await this.beginDelete204Succeeded(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Poll the endpoint
   * indicated in the Azure-AsyncOperation header for operation status
   * @param options The options parameters.
   */
  async beginDeleteAsyncRelativeRetryNoStatus(
    options?: LrosaDsDeleteAsyncRelativeRetryNoStatusOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrosaDsDeleteAsyncRelativeRetryNoStatusResponse>,
      LrosaDsDeleteAsyncRelativeRetryNoStatusResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrosaDsDeleteAsyncRelativeRetryNoStatusResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginDeleteAsyncRelativeRetryNoStatus",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(args, spec) as Promise<
            LrosaDsDeleteAsyncRelativeRetryNoStatusResponse
          >;
        }
      );
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      deleteAsyncRelativeRetryNoStatusOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Poll the endpoint
   * indicated in the Azure-AsyncOperation header for operation status
   * @param options The options parameters.
   */
  async beginDeleteAsyncRelativeRetryNoStatusAndWait(
    options?: LrosaDsDeleteAsyncRelativeRetryNoStatusOptionalParams
  ): Promise<LrosaDsDeleteAsyncRelativeRetryNoStatusResponse> {
    const poller = await this.beginDeleteAsyncRelativeRetryNoStatus(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running post request, service returns a 202 to the initial request, without a location header.
   * @param options The options parameters.
   */
  async beginPost202NoLocation(
    options?: LrosaDsPost202NoLocationOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrosaDsPost202NoLocationResponse>,
      LrosaDsPost202NoLocationResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrosaDsPost202NoLocationResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPost202NoLocation",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(args, spec) as Promise<
            LrosaDsPost202NoLocationResponse
          >;
        }
      );
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      post202NoLocationOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running post request, service returns a 202 to the initial request, without a location header.
   * @param options The options parameters.
   */
  async beginPost202NoLocationAndWait(
    options?: LrosaDsPost202NoLocationOptionalParams
  ): Promise<LrosaDsPost202NoLocationResponse> {
    const poller = await this.beginPost202NoLocation(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation
   * header for operation status
   * @param options The options parameters.
   */
  async beginPostAsyncRelativeRetryNoPayload(
    options?: LrosaDsPostAsyncRelativeRetryNoPayloadOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrosaDsPostAsyncRelativeRetryNoPayloadResponse>,
      LrosaDsPostAsyncRelativeRetryNoPayloadResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrosaDsPostAsyncRelativeRetryNoPayloadResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPostAsyncRelativeRetryNoPayload",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(args, spec) as Promise<
            LrosaDsPostAsyncRelativeRetryNoPayloadResponse
          >;
        }
      );
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      postAsyncRelativeRetryNoPayloadOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation
   * header for operation status
   * @param options The options parameters.
   */
  async beginPostAsyncRelativeRetryNoPayloadAndWait(
    options?: LrosaDsPostAsyncRelativeRetryNoPayloadOptionalParams
  ): Promise<LrosaDsPostAsyncRelativeRetryNoPayloadResponse> {
    const poller = await this.beginPostAsyncRelativeRetryNoPayload(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that is not a
   * valid json
   * @param options The options parameters.
   */
  async beginPut200InvalidJson(
    options?: LrosaDsPut200InvalidJsonOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrosaDsPut200InvalidJsonResponse>,
      LrosaDsPut200InvalidJsonResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrosaDsPut200InvalidJsonResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPut200InvalidJson",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(args, spec) as Promise<
            LrosaDsPut200InvalidJsonResponse
          >;
        }
      );
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      put200InvalidJsonOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that is not a
   * valid json
   * @param options The options parameters.
   */
  async beginPut200InvalidJsonAndWait(
    options?: LrosaDsPut200InvalidJsonOptionalParams
  ): Promise<LrosaDsPut200InvalidJsonResponse> {
    const poller = await this.beginPut200InvalidJson(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’. The endpoint indicated in the Azure-AsyncOperation header is invalid.
   * @param options The options parameters.
   */
  async beginPutAsyncRelativeRetryInvalidHeader(
    options?: LrosaDsPutAsyncRelativeRetryInvalidHeaderOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrosaDsPutAsyncRelativeRetryInvalidHeaderResponse>,
      LrosaDsPutAsyncRelativeRetryInvalidHeaderResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrosaDsPutAsyncRelativeRetryInvalidHeaderResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPutAsyncRelativeRetryInvalidHeader",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(args, spec) as Promise<
            LrosaDsPutAsyncRelativeRetryInvalidHeaderResponse
          >;
        }
      );
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      putAsyncRelativeRetryInvalidHeaderOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’. The endpoint indicated in the Azure-AsyncOperation header is invalid.
   * @param options The options parameters.
   */
  async beginPutAsyncRelativeRetryInvalidHeaderAndWait(
    options?: LrosaDsPutAsyncRelativeRetryInvalidHeaderOptionalParams
  ): Promise<LrosaDsPutAsyncRelativeRetryInvalidHeaderResponse> {
    const poller = await this.beginPutAsyncRelativeRetryInvalidHeader(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
   * operation status
   * @param options The options parameters.
   */
  async beginPutAsyncRelativeRetryInvalidJsonPolling(
    options?: LrosaDsPutAsyncRelativeRetryInvalidJsonPollingOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        LrosaDsPutAsyncRelativeRetryInvalidJsonPollingResponse
      >,
      LrosaDsPutAsyncRelativeRetryInvalidJsonPollingResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrosaDsPutAsyncRelativeRetryInvalidJsonPollingResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPutAsyncRelativeRetryInvalidJsonPolling",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(args, spec) as Promise<
            LrosaDsPutAsyncRelativeRetryInvalidJsonPollingResponse
          >;
        }
      );
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      putAsyncRelativeRetryInvalidJsonPollingOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
   * operation status
   * @param options The options parameters.
   */
  async beginPutAsyncRelativeRetryInvalidJsonPollingAndWait(
    options?: LrosaDsPutAsyncRelativeRetryInvalidJsonPollingOptionalParams
  ): Promise<LrosaDsPutAsyncRelativeRetryInvalidJsonPollingResponse> {
    const poller = await this.beginPutAsyncRelativeRetryInvalidJsonPolling(
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Long running delete request, service returns a 202 to the initial request receing a reponse with an
   * invalid 'Location' and 'Retry-After' headers
   * @param options The options parameters.
   */
  async beginDelete202RetryInvalidHeader(
    options?: LrosaDsDelete202RetryInvalidHeaderOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrosaDsDelete202RetryInvalidHeaderResponse>,
      LrosaDsDelete202RetryInvalidHeaderResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrosaDsDelete202RetryInvalidHeaderResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginDelete202RetryInvalidHeader",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(args, spec) as Promise<
            LrosaDsDelete202RetryInvalidHeaderResponse
          >;
        }
      );
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      delete202RetryInvalidHeaderOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running delete request, service returns a 202 to the initial request receing a reponse with an
   * invalid 'Location' and 'Retry-After' headers
   * @param options The options parameters.
   */
  async beginDelete202RetryInvalidHeaderAndWait(
    options?: LrosaDsDelete202RetryInvalidHeaderOptionalParams
  ): Promise<LrosaDsDelete202RetryInvalidHeaderResponse> {
    const poller = await this.beginDelete202RetryInvalidHeader(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. The endpoint indicated in
   * the Azure-AsyncOperation header is invalid
   * @param options The options parameters.
   */
  async beginDeleteAsyncRelativeRetryInvalidHeader(
    options?: LrosaDsDeleteAsyncRelativeRetryInvalidHeaderOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrosaDsDeleteAsyncRelativeRetryInvalidHeaderResponse>,
      LrosaDsDeleteAsyncRelativeRetryInvalidHeaderResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrosaDsDeleteAsyncRelativeRetryInvalidHeaderResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginDeleteAsyncRelativeRetryInvalidHeader",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(args, spec) as Promise<
            LrosaDsDeleteAsyncRelativeRetryInvalidHeaderResponse
          >;
        }
      );
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      deleteAsyncRelativeRetryInvalidHeaderOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. The endpoint indicated in
   * the Azure-AsyncOperation header is invalid
   * @param options The options parameters.
   */
  async beginDeleteAsyncRelativeRetryInvalidHeaderAndWait(
    options?: LrosaDsDeleteAsyncRelativeRetryInvalidHeaderOptionalParams
  ): Promise<LrosaDsDeleteAsyncRelativeRetryInvalidHeaderResponse> {
    const poller = await this.beginDeleteAsyncRelativeRetryInvalidHeader(
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Poll the endpoint
   * indicated in the Azure-AsyncOperation header for operation status
   * @param options The options parameters.
   */
  async beginDeleteAsyncRelativeRetryInvalidJsonPolling(
    options?: LrosaDsDeleteAsyncRelativeRetryInvalidJsonPollingOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        LrosaDsDeleteAsyncRelativeRetryInvalidJsonPollingResponse
      >,
      LrosaDsDeleteAsyncRelativeRetryInvalidJsonPollingResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrosaDsDeleteAsyncRelativeRetryInvalidJsonPollingResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginDeleteAsyncRelativeRetryInvalidJsonPolling",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(args, spec) as Promise<
            LrosaDsDeleteAsyncRelativeRetryInvalidJsonPollingResponse
          >;
        }
      );
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      deleteAsyncRelativeRetryInvalidJsonPollingOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Poll the endpoint
   * indicated in the Azure-AsyncOperation header for operation status
   * @param options The options parameters.
   */
  async beginDeleteAsyncRelativeRetryInvalidJsonPollingAndWait(
    options?: LrosaDsDeleteAsyncRelativeRetryInvalidJsonPollingOptionalParams
  ): Promise<LrosaDsDeleteAsyncRelativeRetryInvalidJsonPollingResponse> {
    const poller = await this.beginDeleteAsyncRelativeRetryInvalidJsonPolling(
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with invalid 'Location' and
   * 'Retry-After' headers.
   * @param options The options parameters.
   */
  async beginPost202RetryInvalidHeader(
    options?: LrosaDsPost202RetryInvalidHeaderOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrosaDsPost202RetryInvalidHeaderResponse>,
      LrosaDsPost202RetryInvalidHeaderResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrosaDsPost202RetryInvalidHeaderResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPost202RetryInvalidHeader",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(args, spec) as Promise<
            LrosaDsPost202RetryInvalidHeaderResponse
          >;
        }
      );
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      post202RetryInvalidHeaderOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with invalid 'Location' and
   * 'Retry-After' headers.
   * @param options The options parameters.
   */
  async beginPost202RetryInvalidHeaderAndWait(
    options?: LrosaDsPost202RetryInvalidHeaderOptionalParams
  ): Promise<LrosaDsPost202RetryInvalidHeaderResponse> {
    const poller = await this.beginPost202RetryInvalidHeader(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’. The endpoint indicated in the Azure-AsyncOperation header is
   * invalid.
   * @param options The options parameters.
   */
  async beginPostAsyncRelativeRetryInvalidHeader(
    options?: LrosaDsPostAsyncRelativeRetryInvalidHeaderOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<LrosaDsPostAsyncRelativeRetryInvalidHeaderResponse>,
      LrosaDsPostAsyncRelativeRetryInvalidHeaderResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrosaDsPostAsyncRelativeRetryInvalidHeaderResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPostAsyncRelativeRetryInvalidHeader",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(args, spec) as Promise<
            LrosaDsPostAsyncRelativeRetryInvalidHeaderResponse
          >;
        }
      );
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      postAsyncRelativeRetryInvalidHeaderOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’. The endpoint indicated in the Azure-AsyncOperation header is
   * invalid.
   * @param options The options parameters.
   */
  async beginPostAsyncRelativeRetryInvalidHeaderAndWait(
    options?: LrosaDsPostAsyncRelativeRetryInvalidHeaderOptionalParams
  ): Promise<LrosaDsPostAsyncRelativeRetryInvalidHeaderResponse> {
    const poller = await this.beginPostAsyncRelativeRetryInvalidHeader(options);
    return poller.pollUntilDone();
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation
   * header for operation status
   * @param options The options parameters.
   */
  async beginPostAsyncRelativeRetryInvalidJsonPolling(
    options?: LrosaDsPostAsyncRelativeRetryInvalidJsonPollingOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        LrosaDsPostAsyncRelativeRetryInvalidJsonPollingResponse
      >,
      LrosaDsPostAsyncRelativeRetryInvalidJsonPollingResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<LrosaDsPostAsyncRelativeRetryInvalidJsonPollingResponse> => {
      return tracingClient.withSpan(
        "LROClient.beginPostAsyncRelativeRetryInvalidJsonPolling",
        options ?? {},
        async () => {
          return this.client.sendOperationRequest(args, spec) as Promise<
            LrosaDsPostAsyncRelativeRetryInvalidJsonPollingResponse
          >;
        }
      );
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { options },
      postAsyncRelativeRetryInvalidJsonPollingOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation
   * header for operation status
   * @param options The options parameters.
   */
  async beginPostAsyncRelativeRetryInvalidJsonPollingAndWait(
    options?: LrosaDsPostAsyncRelativeRetryInvalidJsonPollingOptionalParams
  ): Promise<LrosaDsPostAsyncRelativeRetryInvalidJsonPollingResponse> {
    const poller = await this.beginPostAsyncRelativeRetryInvalidJsonPolling(
      options
    );
    return poller.pollUntilDone();
  }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);

const putNonRetry400OperationSpec: coreClient.OperationSpec = {
  path: "/lro/nonretryerror/put/400",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const putNonRetry201Creating400OperationSpec: coreClient.OperationSpec = {
  path: "/lro/nonretryerror/put/201/creating/400",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const putNonRetry201Creating400InvalidJsonOperationSpec: coreClient.OperationSpec = {
  path: "/lro/nonretryerror/put/201/creating/400/invalidjson",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const putAsyncRelativeRetry400OperationSpec: coreClient.OperationSpec = {
  path: "/lro/nonretryerror/putasync/retry/400",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrosaDsPutAsyncRelativeRetry400Headers
    },
    201: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrosaDsPutAsyncRelativeRetry400Headers
    },
    202: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrosaDsPutAsyncRelativeRetry400Headers
    },
    204: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrosaDsPutAsyncRelativeRetry400Headers
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const deleteNonRetry400OperationSpec: coreClient.OperationSpec = {
  path: "/lro/nonretryerror/delete/400",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.LrosaDsDeleteNonRetry400Headers
    },
    201: {
      headersMapper: Mappers.LrosaDsDeleteNonRetry400Headers
    },
    202: {
      headersMapper: Mappers.LrosaDsDeleteNonRetry400Headers
    },
    204: {
      headersMapper: Mappers.LrosaDsDeleteNonRetry400Headers
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer
};
const delete202NonRetry400OperationSpec: coreClient.OperationSpec = {
  path: "/lro/nonretryerror/delete/202/retry/400",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.LrosaDsDelete202NonRetry400Headers
    },
    201: {
      headersMapper: Mappers.LrosaDsDelete202NonRetry400Headers
    },
    202: {
      headersMapper: Mappers.LrosaDsDelete202NonRetry400Headers
    },
    204: {
      headersMapper: Mappers.LrosaDsDelete202NonRetry400Headers
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer
};
const deleteAsyncRelativeRetry400OperationSpec: coreClient.OperationSpec = {
  path: "/lro/nonretryerror/deleteasync/retry/400",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.LrosaDsDeleteAsyncRelativeRetry400Headers
    },
    201: {
      headersMapper: Mappers.LrosaDsDeleteAsyncRelativeRetry400Headers
    },
    202: {
      headersMapper: Mappers.LrosaDsDeleteAsyncRelativeRetry400Headers
    },
    204: {
      headersMapper: Mappers.LrosaDsDeleteAsyncRelativeRetry400Headers
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer
};
const postNonRetry400OperationSpec: coreClient.OperationSpec = {
  path: "/lro/nonretryerror/post/400",
  httpMethod: "POST",
  responses: {
    200: {
      headersMapper: Mappers.LrosaDsPostNonRetry400Headers
    },
    201: {
      headersMapper: Mappers.LrosaDsPostNonRetry400Headers
    },
    202: {
      headersMapper: Mappers.LrosaDsPostNonRetry400Headers
    },
    204: {
      headersMapper: Mappers.LrosaDsPostNonRetry400Headers
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const post202NonRetry400OperationSpec: coreClient.OperationSpec = {
  path: "/lro/nonretryerror/post/202/retry/400",
  httpMethod: "POST",
  responses: {
    200: {
      headersMapper: Mappers.LrosaDsPost202NonRetry400Headers
    },
    201: {
      headersMapper: Mappers.LrosaDsPost202NonRetry400Headers
    },
    202: {
      headersMapper: Mappers.LrosaDsPost202NonRetry400Headers
    },
    204: {
      headersMapper: Mappers.LrosaDsPost202NonRetry400Headers
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const postAsyncRelativeRetry400OperationSpec: coreClient.OperationSpec = {
  path: "/lro/nonretryerror/postasync/retry/400",
  httpMethod: "POST",
  responses: {
    200: {
      headersMapper: Mappers.LrosaDsPostAsyncRelativeRetry400Headers
    },
    201: {
      headersMapper: Mappers.LrosaDsPostAsyncRelativeRetry400Headers
    },
    202: {
      headersMapper: Mappers.LrosaDsPostAsyncRelativeRetry400Headers
    },
    204: {
      headersMapper: Mappers.LrosaDsPostAsyncRelativeRetry400Headers
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const putError201NoProvisioningStatePayloadOperationSpec: coreClient.OperationSpec = {
  path: "/lro/error/put/201/noprovisioningstatepayload",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const putAsyncRelativeRetryNoStatusOperationSpec: coreClient.OperationSpec = {
  path: "/lro/error/putasync/retry/nostatus",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrosaDsPutAsyncRelativeRetryNoStatusHeaders
    },
    201: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrosaDsPutAsyncRelativeRetryNoStatusHeaders
    },
    202: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrosaDsPutAsyncRelativeRetryNoStatusHeaders
    },
    204: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrosaDsPutAsyncRelativeRetryNoStatusHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const putAsyncRelativeRetryNoStatusPayloadOperationSpec: coreClient.OperationSpec = {
  path: "/lro/error/putasync/retry/nostatuspayload",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrosaDsPutAsyncRelativeRetryNoStatusPayloadHeaders
    },
    201: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrosaDsPutAsyncRelativeRetryNoStatusPayloadHeaders
    },
    202: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrosaDsPutAsyncRelativeRetryNoStatusPayloadHeaders
    },
    204: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrosaDsPutAsyncRelativeRetryNoStatusPayloadHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const delete204SucceededOperationSpec: coreClient.OperationSpec = {
  path: "/lro/error/delete/204/nolocation",
  httpMethod: "DELETE",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer
};
const deleteAsyncRelativeRetryNoStatusOperationSpec: coreClient.OperationSpec = {
  path: "/lro/error/deleteasync/retry/nostatus",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.LrosaDsDeleteAsyncRelativeRetryNoStatusHeaders
    },
    201: {
      headersMapper: Mappers.LrosaDsDeleteAsyncRelativeRetryNoStatusHeaders
    },
    202: {
      headersMapper: Mappers.LrosaDsDeleteAsyncRelativeRetryNoStatusHeaders
    },
    204: {
      headersMapper: Mappers.LrosaDsDeleteAsyncRelativeRetryNoStatusHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer
};
const post202NoLocationOperationSpec: coreClient.OperationSpec = {
  path: "/lro/error/post/202/nolocation",
  httpMethod: "POST",
  responses: {
    200: {
      headersMapper: Mappers.LrosaDsPost202NoLocationHeaders
    },
    201: {
      headersMapper: Mappers.LrosaDsPost202NoLocationHeaders
    },
    202: {
      headersMapper: Mappers.LrosaDsPost202NoLocationHeaders
    },
    204: {
      headersMapper: Mappers.LrosaDsPost202NoLocationHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const postAsyncRelativeRetryNoPayloadOperationSpec: coreClient.OperationSpec = {
  path: "/lro/error/postasync/retry/nopayload",
  httpMethod: "POST",
  responses: {
    200: {
      headersMapper: Mappers.LrosaDsPostAsyncRelativeRetryNoPayloadHeaders
    },
    201: {
      headersMapper: Mappers.LrosaDsPostAsyncRelativeRetryNoPayloadHeaders
    },
    202: {
      headersMapper: Mappers.LrosaDsPostAsyncRelativeRetryNoPayloadHeaders
    },
    204: {
      headersMapper: Mappers.LrosaDsPostAsyncRelativeRetryNoPayloadHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const put200InvalidJsonOperationSpec: coreClient.OperationSpec = {
  path: "/lro/error/put/200/invalidjson",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const putAsyncRelativeRetryInvalidHeaderOperationSpec: coreClient.OperationSpec = {
  path: "/lro/error/putasync/retry/invalidheader",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrosaDsPutAsyncRelativeRetryInvalidHeaderHeaders
    },
    201: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrosaDsPutAsyncRelativeRetryInvalidHeaderHeaders
    },
    202: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrosaDsPutAsyncRelativeRetryInvalidHeaderHeaders
    },
    204: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LrosaDsPutAsyncRelativeRetryInvalidHeaderHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const putAsyncRelativeRetryInvalidJsonPollingOperationSpec: coreClient.OperationSpec = {
  path: "/lro/error/putasync/retry/invalidjsonpolling",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
      headersMapper:
        Mappers.LrosaDsPutAsyncRelativeRetryInvalidJsonPollingHeaders
    },
    201: {
      bodyMapper: Mappers.Product,
      headersMapper:
        Mappers.LrosaDsPutAsyncRelativeRetryInvalidJsonPollingHeaders
    },
    202: {
      bodyMapper: Mappers.Product,
      headersMapper:
        Mappers.LrosaDsPutAsyncRelativeRetryInvalidJsonPollingHeaders
    },
    204: {
      bodyMapper: Mappers.Product,
      headersMapper:
        Mappers.LrosaDsPutAsyncRelativeRetryInvalidJsonPollingHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const delete202RetryInvalidHeaderOperationSpec: coreClient.OperationSpec = {
  path: "/lro/error/delete/202/retry/invalidheader",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.LrosaDsDelete202RetryInvalidHeaderHeaders
    },
    201: {
      headersMapper: Mappers.LrosaDsDelete202RetryInvalidHeaderHeaders
    },
    202: {
      headersMapper: Mappers.LrosaDsDelete202RetryInvalidHeaderHeaders
    },
    204: {
      headersMapper: Mappers.LrosaDsDelete202RetryInvalidHeaderHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer
};
const deleteAsyncRelativeRetryInvalidHeaderOperationSpec: coreClient.OperationSpec = {
  path: "/lro/error/deleteasync/retry/invalidheader",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.LrosaDsDeleteAsyncRelativeRetryInvalidHeaderHeaders
    },
    201: {
      headersMapper: Mappers.LrosaDsDeleteAsyncRelativeRetryInvalidHeaderHeaders
    },
    202: {
      headersMapper: Mappers.LrosaDsDeleteAsyncRelativeRetryInvalidHeaderHeaders
    },
    204: {
      headersMapper: Mappers.LrosaDsDeleteAsyncRelativeRetryInvalidHeaderHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer
};
const deleteAsyncRelativeRetryInvalidJsonPollingOperationSpec: coreClient.OperationSpec = {
  path: "/lro/error/deleteasync/retry/invalidjsonpolling",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper:
        Mappers.LrosaDsDeleteAsyncRelativeRetryInvalidJsonPollingHeaders
    },
    201: {
      headersMapper:
        Mappers.LrosaDsDeleteAsyncRelativeRetryInvalidJsonPollingHeaders
    },
    202: {
      headersMapper:
        Mappers.LrosaDsDeleteAsyncRelativeRetryInvalidJsonPollingHeaders
    },
    204: {
      headersMapper:
        Mappers.LrosaDsDeleteAsyncRelativeRetryInvalidJsonPollingHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.accept],
  serializer
};
const post202RetryInvalidHeaderOperationSpec: coreClient.OperationSpec = {
  path: "/lro/error/post/202/retry/invalidheader",
  httpMethod: "POST",
  responses: {
    200: {
      headersMapper: Mappers.LrosaDsPost202RetryInvalidHeaderHeaders
    },
    201: {
      headersMapper: Mappers.LrosaDsPost202RetryInvalidHeaderHeaders
    },
    202: {
      headersMapper: Mappers.LrosaDsPost202RetryInvalidHeaderHeaders
    },
    204: {
      headersMapper: Mappers.LrosaDsPost202RetryInvalidHeaderHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const postAsyncRelativeRetryInvalidHeaderOperationSpec: coreClient.OperationSpec = {
  path: "/lro/error/postasync/retry/invalidheader",
  httpMethod: "POST",
  responses: {
    200: {
      headersMapper: Mappers.LrosaDsPostAsyncRelativeRetryInvalidHeaderHeaders
    },
    201: {
      headersMapper: Mappers.LrosaDsPostAsyncRelativeRetryInvalidHeaderHeaders
    },
    202: {
      headersMapper: Mappers.LrosaDsPostAsyncRelativeRetryInvalidHeaderHeaders
    },
    204: {
      headersMapper: Mappers.LrosaDsPostAsyncRelativeRetryInvalidHeaderHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const postAsyncRelativeRetryInvalidJsonPollingOperationSpec: coreClient.OperationSpec = {
  path: "/lro/error/postasync/retry/invalidjsonpolling",
  httpMethod: "POST",
  responses: {
    200: {
      headersMapper:
        Mappers.LrosaDsPostAsyncRelativeRetryInvalidJsonPollingHeaders
    },
    201: {
      headersMapper:
        Mappers.LrosaDsPostAsyncRelativeRetryInvalidJsonPollingHeaders
    },
    202: {
      headersMapper:
        Mappers.LrosaDsPostAsyncRelativeRetryInvalidJsonPollingHeaders
    },
    204: {
      headersMapper:
        Mappers.LrosaDsPostAsyncRelativeRetryInvalidJsonPollingHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
