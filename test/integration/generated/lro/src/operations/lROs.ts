/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as coreHttp from "@azure/core-http";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
import { LROClient } from "../lROClient";
import { LROPoller, shouldDeserializeLRO } from "../lro";
import {
  LROsPut200SucceededOptionalParams,
  LROsPut200SucceededResponse,
  LROsPut201SucceededOptionalParams,
  LROsPut201SucceededResponse,
  LROsPost202ListResponse,
  LROsPut200SucceededNoStateOptionalParams,
  LROsPut200SucceededNoStateResponse,
  LROsPut202Retry200OptionalParams,
  LROsPut202Retry200Response,
  LROsPut201CreatingSucceeded200OptionalParams,
  LROsPut201CreatingSucceeded200Response,
  LROsPut200UpdatingSucceeded204OptionalParams,
  LROsPut200UpdatingSucceeded204Response,
  LROsPut201CreatingFailed200OptionalParams,
  LROsPut201CreatingFailed200Response,
  LROsPut200Acceptedcanceled200OptionalParams,
  LROsPut200Acceptedcanceled200Response,
  LROsPutNoHeaderInRetryOptionalParams,
  LROsPutNoHeaderInRetryResponse,
  LROsPutAsyncRetrySucceededOptionalParams,
  LROsPutAsyncRetrySucceededResponse,
  LROsPutAsyncNoRetrySucceededOptionalParams,
  LROsPutAsyncNoRetrySucceededResponse,
  LROsPutAsyncRetryFailedOptionalParams,
  LROsPutAsyncRetryFailedResponse,
  LROsPutAsyncNoRetrycanceledOptionalParams,
  LROsPutAsyncNoRetrycanceledResponse,
  LROsPutAsyncNoHeaderInRetryOptionalParams,
  LROsPutAsyncNoHeaderInRetryResponse,
  LROsPutNonResourceOptionalParams,
  LROsPutNonResourceResponse,
  LROsPutAsyncNonResourceOptionalParams,
  LROsPutAsyncNonResourceResponse,
  LROsPutSubResourceOptionalParams,
  LROsPutSubResourceResponse,
  LROsPutAsyncSubResourceOptionalParams,
  LROsPutAsyncSubResourceResponse,
  LROsDeleteProvisioning202Accepted200SucceededResponse,
  LROsDeleteProvisioning202DeletingFailed200Response,
  LROsDeleteProvisioning202Deletingcanceled200Response,
  LROsDelete202Retry200Response,
  LROsDelete202NoRetry204Response,
  LROsDeleteNoHeaderInRetryResponse,
  LROsDeleteAsyncNoHeaderInRetryResponse,
  LROsDeleteAsyncRetrySucceededResponse,
  LROsDeleteAsyncNoRetrySucceededResponse,
  LROsDeleteAsyncRetryFailedResponse,
  LROsDeleteAsyncRetrycanceledResponse,
  LROsPost200WithPayloadResponse,
  LROsPost202Retry200OptionalParams,
  LROsPost202Retry200Response,
  LROsPost202NoRetry204OptionalParams,
  LROsPost202NoRetry204Response,
  LROsPostDoubleHeadersFinalLocationGetResponse,
  LROsPostDoubleHeadersFinalAzureHeaderGetResponse,
  LROsPostDoubleHeadersFinalAzureHeaderGetDefaultResponse,
  LROsPostAsyncRetrySucceededOptionalParams,
  LROsPostAsyncRetrySucceededResponse,
  LROsPostAsyncNoRetrySucceededOptionalParams,
  LROsPostAsyncNoRetrySucceededResponse,
  LROsPostAsyncRetryFailedOptionalParams,
  LROsPostAsyncRetryFailedResponse,
  LROsPostAsyncRetrycanceledOptionalParams,
  LROsPostAsyncRetrycanceledResponse
} from "../models";

/**
 * Class representing a LROs.
 */
export class LROs {
  private readonly client: LROClient;

  /**
   * Initialize a new instance of the class LROs class.
   * @param client Reference to the service client
   */
  constructor(client: LROClient) {
    this.client = client;
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Succeeded’.
   * @param options The options parameters.
   */
  async put200Succeeded(
    options?: LROsPut200SucceededOptionalParams
  ): Promise<LROPoller<LROsPut200SucceededResponse>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsPut200SucceededResponse
      >;
    const initialOperationResult = await sendOperation(
      args,
      put200SucceededOperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: put200SucceededOperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running put request, service returns a 201 to the initial request, with an entity that contains
   * ProvisioningState=’Succeeded’.
   * @param options The options parameters.
   */
  async put201Succeeded(
    options?: LROsPut201SucceededOptionalParams
  ): Promise<LROPoller<LROsPut201SucceededResponse>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsPut201SucceededResponse
      >;
    const initialOperationResult = await sendOperation(
      args,
      put201SucceededOperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: put201SucceededOperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running put request, service returns a 202 with empty body to first request, returns a 200 with
   * body [{ 'id': '100', 'name': 'foo' }].
   * @param options The options parameters.
   */
  async post202List(
    options?: coreHttp.OperationOptions
  ): Promise<LROPoller<LROsPost202ListResponse>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsPost202ListResponse
      >;
    const initialOperationResult = await sendOperation(
      args,
      post202ListOperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: post202ListOperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that does not
   * contain ProvisioningState=’Succeeded’.
   * @param options The options parameters.
   */
  async put200SucceededNoState(
    options?: LROsPut200SucceededNoStateOptionalParams
  ): Promise<LROPoller<LROsPut200SucceededNoStateResponse>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsPut200SucceededNoStateResponse
      >;
    const initialOperationResult = await sendOperation(
      args,
      put200SucceededNoStateOperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: put200SucceededNoStateOperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running put request, service returns a 202 to the initial request, with a location header that
   * points to a polling URL that returns a 200 and an entity that doesn't contains ProvisioningState
   * @param options The options parameters.
   */
  async put202Retry200(
    options?: LROsPut202Retry200OptionalParams
  ): Promise<LROPoller<LROsPut202Retry200Response>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsPut202Retry200Response
      >;
    const initialOperationResult = await sendOperation(
      args,
      put202Retry200OperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: put202Retry200OperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running put request, service returns a 201 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with
   * ProvisioningState=’Succeeded’
   * @param options The options parameters.
   */
  async put201CreatingSucceeded200(
    options?: LROsPut201CreatingSucceeded200OptionalParams
  ): Promise<LROPoller<LROsPut201CreatingSucceeded200Response>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsPut201CreatingSucceeded200Response
      >;
    const initialOperationResult = await sendOperation(
      args,
      put201CreatingSucceeded200OperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: put201CreatingSucceeded200OperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running put request, service returns a 201 to the initial request, with an entity that contains
   * ProvisioningState=’Updating’.  Polls return this value until the last poll returns a ‘200’ with
   * ProvisioningState=’Succeeded’
   * @param options The options parameters.
   */
  async put200UpdatingSucceeded204(
    options?: LROsPut200UpdatingSucceeded204OptionalParams
  ): Promise<LROPoller<LROsPut200UpdatingSucceeded204Response>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsPut200UpdatingSucceeded204Response
      >;
    const initialOperationResult = await sendOperation(
      args,
      put200UpdatingSucceeded204OperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: put200UpdatingSucceeded204OperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running put request, service returns a 201 to the initial request, with an entity that contains
   * ProvisioningState=’Created’.  Polls return this value until the last poll returns a ‘200’ with
   * ProvisioningState=’Failed’
   * @param options The options parameters.
   */
  async put201CreatingFailed200(
    options?: LROsPut201CreatingFailed200OptionalParams
  ): Promise<LROPoller<LROsPut201CreatingFailed200Response>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsPut201CreatingFailed200Response
      >;
    const initialOperationResult = await sendOperation(
      args,
      put201CreatingFailed200OperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: put201CreatingFailed200OperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running put request, service returns a 201 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with
   * ProvisioningState=’Canceled’
   * @param options The options parameters.
   */
  async put200Acceptedcanceled200(
    options?: LROsPut200Acceptedcanceled200OptionalParams
  ): Promise<LROPoller<LROsPut200Acceptedcanceled200Response>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsPut200Acceptedcanceled200Response
      >;
    const initialOperationResult = await sendOperation(
      args,
      put200Acceptedcanceled200OperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: put200Acceptedcanceled200OperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running put request, service returns a 202 to the initial request with location header.
   * Subsequent calls to operation status do not contain location header.
   * @param options The options parameters.
   */
  async putNoHeaderInRetry(
    options?: LROsPutNoHeaderInRetryOptionalParams
  ): Promise<LROPoller<LROsPutNoHeaderInRetryResponse>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsPutNoHeaderInRetryResponse
      >;
    const initialOperationResult = await sendOperation(
      args,
      putNoHeaderInRetryOperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: putNoHeaderInRetryOperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
   * operation status
   * @param options The options parameters.
   */
  async putAsyncRetrySucceeded(
    options?: LROsPutAsyncRetrySucceededOptionalParams
  ): Promise<LROPoller<LROsPutAsyncRetrySucceededResponse>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsPutAsyncRetrySucceededResponse
      >;
    const initialOperationResult = await sendOperation(
      args,
      putAsyncRetrySucceededOperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: putAsyncRetrySucceededOperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
   * operation status
   * @param options The options parameters.
   */
  async putAsyncNoRetrySucceeded(
    options?: LROsPutAsyncNoRetrySucceededOptionalParams
  ): Promise<LROPoller<LROsPutAsyncNoRetrySucceededResponse>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsPutAsyncNoRetrySucceededResponse
      >;
    const initialOperationResult = await sendOperation(
      args,
      putAsyncNoRetrySucceededOperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: putAsyncNoRetrySucceededOperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
   * operation status
   * @param options The options parameters.
   */
  async putAsyncRetryFailed(
    options?: LROsPutAsyncRetryFailedOptionalParams
  ): Promise<LROPoller<LROsPutAsyncRetryFailedResponse>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsPutAsyncRetryFailedResponse
      >;
    const initialOperationResult = await sendOperation(
      args,
      putAsyncRetryFailedOperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: putAsyncRetryFailedOperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running put request, service returns a 200 to the initial request, with an entity that contains
   * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
   * operation status
   * @param options The options parameters.
   */
  async putAsyncNoRetrycanceled(
    options?: LROsPutAsyncNoRetrycanceledOptionalParams
  ): Promise<LROPoller<LROsPutAsyncNoRetrycanceledResponse>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsPutAsyncNoRetrycanceledResponse
      >;
    const initialOperationResult = await sendOperation(
      args,
      putAsyncNoRetrycanceledOperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: putAsyncNoRetrycanceledOperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation
   * header. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
   * @param options The options parameters.
   */
  async putAsyncNoHeaderInRetry(
    options?: LROsPutAsyncNoHeaderInRetryOptionalParams
  ): Promise<LROPoller<LROsPutAsyncNoHeaderInRetryResponse>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsPutAsyncNoHeaderInRetryResponse
      >;
    const initialOperationResult = await sendOperation(
      args,
      putAsyncNoHeaderInRetryOperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: putAsyncNoHeaderInRetryOperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running put request with non resource.
   * @param options The options parameters.
   */
  async putNonResource(
    options?: LROsPutNonResourceOptionalParams
  ): Promise<LROPoller<LROsPutNonResourceResponse>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsPutNonResourceResponse
      >;
    const initialOperationResult = await sendOperation(
      args,
      putNonResourceOperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: putNonResourceOperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running put request with non resource.
   * @param options The options parameters.
   */
  async putAsyncNonResource(
    options?: LROsPutAsyncNonResourceOptionalParams
  ): Promise<LROPoller<LROsPutAsyncNonResourceResponse>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsPutAsyncNonResourceResponse
      >;
    const initialOperationResult = await sendOperation(
      args,
      putAsyncNonResourceOperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: putAsyncNonResourceOperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running put request with sub resource.
   * @param options The options parameters.
   */
  async putSubResource(
    options?: LROsPutSubResourceOptionalParams
  ): Promise<LROPoller<LROsPutSubResourceResponse>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsPutSubResourceResponse
      >;
    const initialOperationResult = await sendOperation(
      args,
      putSubResourceOperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: putSubResourceOperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running put request with sub resource.
   * @param options The options parameters.
   */
  async putAsyncSubResource(
    options?: LROsPutAsyncSubResourceOptionalParams
  ): Promise<LROPoller<LROsPutAsyncSubResourceResponse>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsPutAsyncSubResourceResponse
      >;
    const initialOperationResult = await sendOperation(
      args,
      putAsyncSubResourceOperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: putAsyncSubResourceOperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running delete request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Accepted’.  Polls return this value until the last poll returns a ‘200’
   * with ProvisioningState=’Succeeded’
   * @param options The options parameters.
   */
  async deleteProvisioning202Accepted200Succeeded(
    options?: coreHttp.OperationOptions
  ): Promise<LROPoller<LROsDeleteProvisioning202Accepted200SucceededResponse>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsDeleteProvisioning202Accepted200SucceededResponse
      >;
    const initialOperationResult = await sendOperation(
      args,
      deleteProvisioning202Accepted200SucceededOperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: deleteProvisioning202Accepted200SucceededOperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running delete request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’
   * with ProvisioningState=’Failed’
   * @param options The options parameters.
   */
  async deleteProvisioning202DeletingFailed200(
    options?: coreHttp.OperationOptions
  ): Promise<LROPoller<LROsDeleteProvisioning202DeletingFailed200Response>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsDeleteProvisioning202DeletingFailed200Response
      >;
    const initialOperationResult = await sendOperation(
      args,
      deleteProvisioning202DeletingFailed200OperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: deleteProvisioning202DeletingFailed200OperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running delete request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’
   * with ProvisioningState=’Canceled’
   * @param options The options parameters.
   */
  async deleteProvisioning202Deletingcanceled200(
    options?: coreHttp.OperationOptions
  ): Promise<LROPoller<LROsDeleteProvisioning202Deletingcanceled200Response>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsDeleteProvisioning202Deletingcanceled200Response
      >;
    const initialOperationResult = await sendOperation(
      args,
      deleteProvisioning202Deletingcanceled200OperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: deleteProvisioning202Deletingcanceled200OperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running delete succeeds and returns right away
   * @param options The options parameters.
   */
  async delete204Succeeded(
    options?: coreHttp.OperationOptions
  ): Promise<LROPoller<coreHttp.RestResponse>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        coreHttp.RestResponse
      >;
    const initialOperationResult = await sendOperation(
      args,
      delete204SucceededOperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: delete204SucceededOperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Polls return this value
   * until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
   * @param options The options parameters.
   */
  async delete202Retry200(
    options?: coreHttp.OperationOptions
  ): Promise<LROPoller<LROsDelete202Retry200Response>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsDelete202Retry200Response
      >;
    const initialOperationResult = await sendOperation(
      args,
      delete202Retry200OperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: delete202Retry200OperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Polls return this value
   * until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
   * @param options The options parameters.
   */
  async delete202NoRetry204(
    options?: coreHttp.OperationOptions
  ): Promise<LROPoller<LROsDelete202NoRetry204Response>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsDelete202NoRetry204Response
      >;
    const initialOperationResult = await sendOperation(
      args,
      delete202NoRetry204OperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: delete202NoRetry204OperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running delete request, service returns a location header in the initial request. Subsequent
   * calls to operation status do not contain location header.
   * @param options The options parameters.
   */
  async deleteNoHeaderInRetry(
    options?: coreHttp.OperationOptions
  ): Promise<LROPoller<LROsDeleteNoHeaderInRetryResponse>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsDeleteNoHeaderInRetryResponse
      >;
    const initialOperationResult = await sendOperation(
      args,
      deleteNoHeaderInRetryOperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: deleteNoHeaderInRetryOperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running delete request, service returns an Azure-AsyncOperation header in the initial request.
   * Subsequent calls to operation status do not contain Azure-AsyncOperation header.
   * @param options The options parameters.
   */
  async deleteAsyncNoHeaderInRetry(
    options?: coreHttp.OperationOptions
  ): Promise<LROPoller<LROsDeleteAsyncNoHeaderInRetryResponse>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsDeleteAsyncNoHeaderInRetryResponse
      >;
    const initialOperationResult = await sendOperation(
      args,
      deleteAsyncNoHeaderInRetryOperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: deleteAsyncNoHeaderInRetryOperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Poll the endpoint
   * indicated in the Azure-AsyncOperation header for operation status
   * @param options The options parameters.
   */
  async deleteAsyncRetrySucceeded(
    options?: coreHttp.OperationOptions
  ): Promise<LROPoller<LROsDeleteAsyncRetrySucceededResponse>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsDeleteAsyncRetrySucceededResponse
      >;
    const initialOperationResult = await sendOperation(
      args,
      deleteAsyncRetrySucceededOperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: deleteAsyncRetrySucceededOperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Poll the endpoint
   * indicated in the Azure-AsyncOperation header for operation status
   * @param options The options parameters.
   */
  async deleteAsyncNoRetrySucceeded(
    options?: coreHttp.OperationOptions
  ): Promise<LROPoller<LROsDeleteAsyncNoRetrySucceededResponse>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsDeleteAsyncNoRetrySucceededResponse
      >;
    const initialOperationResult = await sendOperation(
      args,
      deleteAsyncNoRetrySucceededOperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: deleteAsyncNoRetrySucceededOperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Poll the endpoint
   * indicated in the Azure-AsyncOperation header for operation status
   * @param options The options parameters.
   */
  async deleteAsyncRetryFailed(
    options?: coreHttp.OperationOptions
  ): Promise<LROPoller<LROsDeleteAsyncRetryFailedResponse>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsDeleteAsyncRetryFailedResponse
      >;
    const initialOperationResult = await sendOperation(
      args,
      deleteAsyncRetryFailedOperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: deleteAsyncRetryFailedOperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running delete request, service returns a 202 to the initial request. Poll the endpoint
   * indicated in the Azure-AsyncOperation header for operation status
   * @param options The options parameters.
   */
  async deleteAsyncRetrycanceled(
    options?: coreHttp.OperationOptions
  ): Promise<LROPoller<LROsDeleteAsyncRetrycanceledResponse>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsDeleteAsyncRetrycanceledResponse
      >;
    const initialOperationResult = await sendOperation(
      args,
      deleteAsyncRetrycanceledOperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: deleteAsyncRetrycanceledOperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with 'Location' header.
   * Poll returns a 200 with a response body after success.
   * @param options The options parameters.
   */
  async post200WithPayload(
    options?: coreHttp.OperationOptions
  ): Promise<LROPoller<LROsPost200WithPayloadResponse>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsPost200WithPayloadResponse
      >;
    const initialOperationResult = await sendOperation(
      args,
      post200WithPayloadOperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: post200WithPayloadOperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with 'Location' and
   * 'Retry-After' headers, Polls return a 200 with a response body after success
   * @param options The options parameters.
   */
  async post202Retry200(
    options?: LROsPost202Retry200OptionalParams
  ): Promise<LROPoller<LROsPost202Retry200Response>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsPost202Retry200Response
      >;
    const initialOperationResult = await sendOperation(
      args,
      post202Retry200OperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: post202Retry200OperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with 'Location' header, 204
   * with noresponse body after success
   * @param options The options parameters.
   */
  async post202NoRetry204(
    options?: LROsPost202NoRetry204OptionalParams
  ): Promise<LROPoller<LROsPost202NoRetry204Response>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsPost202NoRetry204Response
      >;
    const initialOperationResult = await sendOperation(
      args,
      post202NoRetry204OperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: post202NoRetry204OperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running post request, service returns a 202 to the initial request with both Location and
   * Azure-Async header. Poll Azure-Async and it's success. Should poll Location to get the final object
   * @param options The options parameters.
   */
  async postDoubleHeadersFinalLocationGet(
    options?: coreHttp.OperationOptions
  ): Promise<LROPoller<LROsPostDoubleHeadersFinalLocationGetResponse>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options,
      "location"
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsPostDoubleHeadersFinalLocationGetResponse
      >;
    const initialOperationResult = await sendOperation(
      args,
      postDoubleHeadersFinalLocationGetOperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: postDoubleHeadersFinalLocationGetOperationSpec,
      initialOperationResult,
      sendOperation,
      finalStateVia: "location"
    });
  }

  /**
   * Long running post request, service returns a 202 to the initial request with both Location and
   * Azure-Async header. Poll Azure-Async and it's success. Should NOT poll Location to get the final
   * object
   * @param options The options parameters.
   */
  async postDoubleHeadersFinalAzureHeaderGet(
    options?: coreHttp.OperationOptions
  ): Promise<LROPoller<LROsPostDoubleHeadersFinalAzureHeaderGetResponse>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options,
      "azure-async-operation"
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsPostDoubleHeadersFinalAzureHeaderGetResponse
      >;
    const initialOperationResult = await sendOperation(
      args,
      postDoubleHeadersFinalAzureHeaderGetOperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: postDoubleHeadersFinalAzureHeaderGetOperationSpec,
      initialOperationResult,
      sendOperation,
      finalStateVia: "azure-async-operation"
    });
  }

  /**
   * Long running post request, service returns a 202 to the initial request with both Location and
   * Azure-Async header. Poll Azure-Async and it's success. Should NOT poll Location to get the final
   * object if you support initial Autorest behavior.
   * @param options The options parameters.
   */
  async postDoubleHeadersFinalAzureHeaderGetDefault(
    options?: coreHttp.OperationOptions
  ): Promise<
    LROPoller<LROsPostDoubleHeadersFinalAzureHeaderGetDefaultResponse>
  > {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsPostDoubleHeadersFinalAzureHeaderGetDefaultResponse
      >;
    const initialOperationResult = await sendOperation(
      args,
      postDoubleHeadersFinalAzureHeaderGetDefaultOperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: postDoubleHeadersFinalAzureHeaderGetDefaultOperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation
   * header for operation status
   * @param options The options parameters.
   */
  async postAsyncRetrySucceeded(
    options?: LROsPostAsyncRetrySucceededOptionalParams
  ): Promise<LROPoller<LROsPostAsyncRetrySucceededResponse>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsPostAsyncRetrySucceededResponse
      >;
    const initialOperationResult = await sendOperation(
      args,
      postAsyncRetrySucceededOperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: postAsyncRetrySucceededOperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation
   * header for operation status
   * @param options The options parameters.
   */
  async postAsyncNoRetrySucceeded(
    options?: LROsPostAsyncNoRetrySucceededOptionalParams
  ): Promise<LROPoller<LROsPostAsyncNoRetrySucceededResponse>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsPostAsyncNoRetrySucceededResponse
      >;
    const initialOperationResult = await sendOperation(
      args,
      postAsyncNoRetrySucceededOperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: postAsyncNoRetrySucceededOperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation
   * header for operation status
   * @param options The options parameters.
   */
  async postAsyncRetryFailed(
    options?: LROsPostAsyncRetryFailedOptionalParams
  ): Promise<LROPoller<LROsPostAsyncRetryFailedResponse>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsPostAsyncRetryFailedResponse
      >;
    const initialOperationResult = await sendOperation(
      args,
      postAsyncRetryFailedOperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: postAsyncRetryFailedOperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  /**
   * Long running post request, service returns a 202 to the initial request, with an entity that
   * contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation
   * header for operation status
   * @param options The options parameters.
   */
  async postAsyncRetrycanceled(
    options?: LROsPostAsyncRetrycanceledOptionalParams
  ): Promise<LROPoller<LROsPostAsyncRetrycanceledResponse>> {
    const operationOptions: coreHttp.RequestOptionsBase = this.getOperationOptions(
      options
    );

    const args: coreHttp.OperationArguments = { options: operationOptions };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) =>
      this.client.sendOperationRequest(args, spec) as Promise<
        LROsPostAsyncRetrycanceledResponse
      >;
    const initialOperationResult = await sendOperation(
      args,
      postAsyncRetrycanceledOperationSpec
    );

    return new LROPoller({
      initialOperationArguments: args,
      initialOperationSpec: postAsyncRetrycanceledOperationSpec,
      initialOperationResult,
      sendOperation
    });
  }

  private getOperationOptions<TOptions extends coreHttp.OperationOptions>(
    options: TOptions | undefined,
    finalStateVia?: string
  ): coreHttp.RequestOptionsBase {
    const operationOptions: coreHttp.OperationOptions = options || {};
    operationOptions.requestOptions = {
      ...operationOptions.requestOptions,
      shouldDeserialize: shouldDeserializeLRO(finalStateVia)
    };
    return coreHttp.operationOptionsToRequestOptionsBase(operationOptions);
  }
}
// Operation Specifications

const serializer = new coreHttp.Serializer(Mappers, /* isXml */ false);

const put200SucceededOperationSpec: coreHttp.OperationSpec = {
  path: "/lro/put/200/succeeded",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType],
  mediaType: "json",
  serializer
};
const put201SucceededOperationSpec: coreHttp.OperationSpec = {
  path: "/lro/put/201/succeeded",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType],
  mediaType: "json",
  serializer
};
const post202ListOperationSpec: coreHttp.OperationSpec = {
  path: "/lro/list",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: { type: { name: "Composite", className: "Product" } }
        }
      }
    },
    201: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: { type: { name: "Composite", className: "Product" } }
        }
      }
    },
    202: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: { type: { name: "Composite", className: "Product" } }
        }
      }
    },
    204: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: { type: { name: "Composite", className: "Product" } }
        }
      }
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.$host],
  serializer
};
const put200SucceededNoStateOperationSpec: coreHttp.OperationSpec = {
  path: "/lro/put/200/succeeded/nostate",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType],
  mediaType: "json",
  serializer
};
const put202Retry200OperationSpec: coreHttp.OperationSpec = {
  path: "/lro/put/202/retry/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType],
  mediaType: "json",
  serializer
};
const put201CreatingSucceeded200OperationSpec: coreHttp.OperationSpec = {
  path: "/lro/put/201/creating/succeeded/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType],
  mediaType: "json",
  serializer
};
const put200UpdatingSucceeded204OperationSpec: coreHttp.OperationSpec = {
  path: "/lro/put/200/updating/succeeded/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType],
  mediaType: "json",
  serializer
};
const put201CreatingFailed200OperationSpec: coreHttp.OperationSpec = {
  path: "/lro/put/201/created/failed/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType],
  mediaType: "json",
  serializer
};
const put200Acceptedcanceled200OperationSpec: coreHttp.OperationSpec = {
  path: "/lro/put/200/accepted/canceled/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType],
  mediaType: "json",
  serializer
};
const putNoHeaderInRetryOperationSpec: coreHttp.OperationSpec = {
  path: "/lro/put/noheader/202/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutNoHeaderInRetryHeaders
    },
    201: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutNoHeaderInRetryHeaders
    },
    202: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutNoHeaderInRetryHeaders
    },
    204: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutNoHeaderInRetryHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType],
  mediaType: "json",
  serializer
};
const putAsyncRetrySucceededOperationSpec: coreHttp.OperationSpec = {
  path: "/lro/putasync/retry/succeeded",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncRetrySucceededHeaders
    },
    201: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncRetrySucceededHeaders
    },
    202: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncRetrySucceededHeaders
    },
    204: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncRetrySucceededHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType],
  mediaType: "json",
  serializer
};
const putAsyncNoRetrySucceededOperationSpec: coreHttp.OperationSpec = {
  path: "/lro/putasync/noretry/succeeded",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncNoRetrySucceededHeaders
    },
    201: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncNoRetrySucceededHeaders
    },
    202: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncNoRetrySucceededHeaders
    },
    204: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncNoRetrySucceededHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType],
  mediaType: "json",
  serializer
};
const putAsyncRetryFailedOperationSpec: coreHttp.OperationSpec = {
  path: "/lro/putasync/retry/failed",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncRetryFailedHeaders
    },
    201: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncRetryFailedHeaders
    },
    202: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncRetryFailedHeaders
    },
    204: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncRetryFailedHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType],
  mediaType: "json",
  serializer
};
const putAsyncNoRetrycanceledOperationSpec: coreHttp.OperationSpec = {
  path: "/lro/putasync/noretry/canceled",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncNoRetrycanceledHeaders
    },
    201: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncNoRetrycanceledHeaders
    },
    202: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncNoRetrycanceledHeaders
    },
    204: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncNoRetrycanceledHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType],
  mediaType: "json",
  serializer
};
const putAsyncNoHeaderInRetryOperationSpec: coreHttp.OperationSpec = {
  path: "/lro/putasync/noheader/201/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncNoHeaderInRetryHeaders
    },
    201: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncNoHeaderInRetryHeaders
    },
    202: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncNoHeaderInRetryHeaders
    },
    204: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPutAsyncNoHeaderInRetryHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType],
  mediaType: "json",
  serializer
};
const putNonResourceOperationSpec: coreHttp.OperationSpec = {
  path: "/lro/putnonresource/202/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Sku
    },
    201: {
      bodyMapper: Mappers.Sku
    },
    202: {
      bodyMapper: Mappers.Sku
    },
    204: {
      bodyMapper: Mappers.Sku
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.sku,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType],
  mediaType: "json",
  serializer
};
const putAsyncNonResourceOperationSpec: coreHttp.OperationSpec = {
  path: "/lro/putnonresourceasync/202/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.Sku
    },
    201: {
      bodyMapper: Mappers.Sku
    },
    202: {
      bodyMapper: Mappers.Sku
    },
    204: {
      bodyMapper: Mappers.Sku
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.sku,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType],
  mediaType: "json",
  serializer
};
const putSubResourceOperationSpec: coreHttp.OperationSpec = {
  path: "/lro/putsubresource/202/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.SubProduct
    },
    201: {
      bodyMapper: Mappers.SubProduct
    },
    202: {
      bodyMapper: Mappers.SubProduct
    },
    204: {
      bodyMapper: Mappers.SubProduct
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product1,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType],
  mediaType: "json",
  serializer
};
const putAsyncSubResourceOperationSpec: coreHttp.OperationSpec = {
  path: "/lro/putsubresourceasync/202/200",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.SubProduct
    },
    201: {
      bodyMapper: Mappers.SubProduct
    },
    202: {
      bodyMapper: Mappers.SubProduct
    },
    204: {
      bodyMapper: Mappers.SubProduct
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product1,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType],
  mediaType: "json",
  serializer
};
const deleteProvisioning202Accepted200SucceededOperationSpec: coreHttp.OperationSpec = {
  path: "/lro/delete/provisioning/202/accepted/200/succeeded",
  httpMethod: "DELETE",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.$host],
  serializer
};
const deleteProvisioning202DeletingFailed200OperationSpec: coreHttp.OperationSpec = {
  path: "/lro/delete/provisioning/202/deleting/200/failed",
  httpMethod: "DELETE",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.$host],
  serializer
};
const deleteProvisioning202Deletingcanceled200OperationSpec: coreHttp.OperationSpec = {
  path: "/lro/delete/provisioning/202/deleting/200/canceled",
  httpMethod: "DELETE",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.$host],
  serializer
};
const delete204SucceededOperationSpec: coreHttp.OperationSpec = {
  path: "/lro/delete/204/succeeded",
  httpMethod: "DELETE",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.$host],
  serializer
};
const delete202Retry200OperationSpec: coreHttp.OperationSpec = {
  path: "/lro/delete/202/retry/200",
  httpMethod: "DELETE",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.$host],
  serializer
};
const delete202NoRetry204OperationSpec: coreHttp.OperationSpec = {
  path: "/lro/delete/202/noretry/204",
  httpMethod: "DELETE",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.$host],
  serializer
};
const deleteNoHeaderInRetryOperationSpec: coreHttp.OperationSpec = {
  path: "/lro/delete/noheader",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.LROsDeleteNoHeaderInRetryHeaders
    },
    201: {
      headersMapper: Mappers.LROsDeleteNoHeaderInRetryHeaders
    },
    202: {
      headersMapper: Mappers.LROsDeleteNoHeaderInRetryHeaders
    },
    204: {
      headersMapper: Mappers.LROsDeleteNoHeaderInRetryHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.$host],
  serializer
};
const deleteAsyncNoHeaderInRetryOperationSpec: coreHttp.OperationSpec = {
  path: "/lro/deleteasync/noheader/202/204",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.LROsDeleteAsyncNoHeaderInRetryHeaders
    },
    201: {
      headersMapper: Mappers.LROsDeleteAsyncNoHeaderInRetryHeaders
    },
    202: {
      headersMapper: Mappers.LROsDeleteAsyncNoHeaderInRetryHeaders
    },
    204: {
      headersMapper: Mappers.LROsDeleteAsyncNoHeaderInRetryHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.$host],
  serializer
};
const deleteAsyncRetrySucceededOperationSpec: coreHttp.OperationSpec = {
  path: "/lro/deleteasync/retry/succeeded",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.LROsDeleteAsyncRetrySucceededHeaders
    },
    201: {
      headersMapper: Mappers.LROsDeleteAsyncRetrySucceededHeaders
    },
    202: {
      headersMapper: Mappers.LROsDeleteAsyncRetrySucceededHeaders
    },
    204: {
      headersMapper: Mappers.LROsDeleteAsyncRetrySucceededHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.$host],
  serializer
};
const deleteAsyncNoRetrySucceededOperationSpec: coreHttp.OperationSpec = {
  path: "/lro/deleteasync/noretry/succeeded",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.LROsDeleteAsyncNoRetrySucceededHeaders
    },
    201: {
      headersMapper: Mappers.LROsDeleteAsyncNoRetrySucceededHeaders
    },
    202: {
      headersMapper: Mappers.LROsDeleteAsyncNoRetrySucceededHeaders
    },
    204: {
      headersMapper: Mappers.LROsDeleteAsyncNoRetrySucceededHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.$host],
  serializer
};
const deleteAsyncRetryFailedOperationSpec: coreHttp.OperationSpec = {
  path: "/lro/deleteasync/retry/failed",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.LROsDeleteAsyncRetryFailedHeaders
    },
    201: {
      headersMapper: Mappers.LROsDeleteAsyncRetryFailedHeaders
    },
    202: {
      headersMapper: Mappers.LROsDeleteAsyncRetryFailedHeaders
    },
    204: {
      headersMapper: Mappers.LROsDeleteAsyncRetryFailedHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.$host],
  serializer
};
const deleteAsyncRetrycanceledOperationSpec: coreHttp.OperationSpec = {
  path: "/lro/deleteasync/retry/canceled",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.LROsDeleteAsyncRetrycanceledHeaders
    },
    201: {
      headersMapper: Mappers.LROsDeleteAsyncRetrycanceledHeaders
    },
    202: {
      headersMapper: Mappers.LROsDeleteAsyncRetrycanceledHeaders
    },
    204: {
      headersMapper: Mappers.LROsDeleteAsyncRetrycanceledHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.$host],
  serializer
};
const post200WithPayloadOperationSpec: coreHttp.OperationSpec = {
  path: "/lro/post/payload/200",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.Sku
    },
    201: {
      bodyMapper: Mappers.Sku
    },
    202: {
      bodyMapper: Mappers.Sku
    },
    204: {
      bodyMapper: Mappers.Sku
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.$host],
  serializer
};
const post202Retry200OperationSpec: coreHttp.OperationSpec = {
  path: "/lro/post/202/retry/200",
  httpMethod: "POST",
  responses: {
    200: {
      headersMapper: Mappers.LROsPost202Retry200Headers
    },
    201: {
      headersMapper: Mappers.LROsPost202Retry200Headers
    },
    202: {
      headersMapper: Mappers.LROsPost202Retry200Headers
    },
    204: {
      headersMapper: Mappers.LROsPost202Retry200Headers
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType],
  mediaType: "json",
  serializer
};
const post202NoRetry204OperationSpec: coreHttp.OperationSpec = {
  path: "/lro/post/202/noretry/204",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPost202NoRetry204Headers
    },
    201: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPost202NoRetry204Headers
    },
    202: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPost202NoRetry204Headers
    },
    204: {
      bodyMapper: Mappers.Product,
      headersMapper: Mappers.LROsPost202NoRetry204Headers
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType],
  mediaType: "json",
  serializer
};
const postDoubleHeadersFinalLocationGetOperationSpec: coreHttp.OperationSpec = {
  path: "/lro/LROPostDoubleHeadersFinalLocationGet",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.$host],
  serializer
};
const postDoubleHeadersFinalAzureHeaderGetOperationSpec: coreHttp.OperationSpec = {
  path: "/lro/LROPostDoubleHeadersFinalAzureHeaderGet",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.$host],
  serializer
};
const postDoubleHeadersFinalAzureHeaderGetDefaultOperationSpec: coreHttp.OperationSpec = {
  path: "/lro/LROPostDoubleHeadersFinalAzureHeaderGetDefault",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  urlParameters: [Parameters.$host],
  serializer
};
const postAsyncRetrySucceededOperationSpec: coreHttp.OperationSpec = {
  path: "/lro/postasync/retry/succeeded",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType],
  mediaType: "json",
  serializer
};
const postAsyncNoRetrySucceededOperationSpec: coreHttp.OperationSpec = {
  path: "/lro/postasync/noretry/succeeded",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.Product
    },
    201: {
      bodyMapper: Mappers.Product
    },
    202: {
      bodyMapper: Mappers.Product
    },
    204: {
      bodyMapper: Mappers.Product
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType],
  mediaType: "json",
  serializer
};
const postAsyncRetryFailedOperationSpec: coreHttp.OperationSpec = {
  path: "/lro/postasync/retry/failed",
  httpMethod: "POST",
  responses: {
    200: {
      headersMapper: Mappers.LROsPostAsyncRetryFailedHeaders
    },
    201: {
      headersMapper: Mappers.LROsPostAsyncRetryFailedHeaders
    },
    202: {
      headersMapper: Mappers.LROsPostAsyncRetryFailedHeaders
    },
    204: {
      headersMapper: Mappers.LROsPostAsyncRetryFailedHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType],
  mediaType: "json",
  serializer
};
const postAsyncRetrycanceledOperationSpec: coreHttp.OperationSpec = {
  path: "/lro/postasync/retry/canceled",
  httpMethod: "POST",
  responses: {
    200: {
      headersMapper: Mappers.LROsPostAsyncRetrycanceledHeaders
    },
    201: {
      headersMapper: Mappers.LROsPostAsyncRetrycanceledHeaders
    },
    202: {
      headersMapper: Mappers.LROsPostAsyncRetrycanceledHeaders
    },
    204: {
      headersMapper: Mappers.LROsPostAsyncRetrycanceledHeaders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.product,
  urlParameters: [Parameters.$host],
  headerParameters: [Parameters.contentType],
  mediaType: "json",
  serializer
};
