/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

import * as msRest from "ms-rest-js";
import * as Models from "../models";
import * as Mappers from "../models/headerMappers";
import { AutoRestSwaggerBATHeaderServiceContext } from "../autoRestSwaggerBATHeaderServiceContext";

const WebResource = msRest.WebResource;

/** Class representing a Header. */
export class Header {
  private readonly client: AutoRestSwaggerBATHeaderServiceContext;
  private readonly serializer = new msRest.Serializer(Mappers);
  /**
   * Create a Header.
   * @param {AutoRestSwaggerBATHeaderServiceContext} client Reference to the service client.
   */
  constructor(client: AutoRestSwaggerBATHeaderServiceContext) {
    this.client = client;
  }

  /**
   * Send a post request with header value "User-Agent": "overwrite"
   *
   * @param {string} userAgent Send a post request with header value "User-Agent": "overwrite"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async paramExistingKeyWithHttpOperationResponse(userAgent: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<void>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          userAgent
        },
        options);
      operationRes = await this.client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.client.baseUri,
          path: "header/param/existingkey",
          headerParameters: [
            {
              parameterPath: "userAgent",
              mapper: {
                required: true,
                serializedName: "User-Agent",
                type: {
                  name: "String"
                }
              }
            }
          ],
          responses: {
            200: {},
            default: {
              bodyMapper: Mappers.ErrorModel
            }
          },
          serializer: this.serializer
        });
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }

  /**
   * Get a response with header value "User-Agent": "overwrite"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async responseExistingKeyWithHttpOperationResponse(options?: msRest.RequestOptionsBase): Promise<Models.HeaderResponseExistingKeyResponse> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments({}, options);
      operationRes = await this.client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.client.baseUri,
          path: "header/response/existingkey",
          responses: {
            200: {
              headersMapper: Mappers.HeaderResponseExistingKeyHeaders
            },
            default: {
              bodyMapper: Mappers.ErrorModel
            }
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }

  /**
   * Send a post request with header value "Content-Type": "text/html"
   *
   * @param {string} contentType Send a post request with header value "Content-Type": "text/html"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async paramProtectedKeyWithHttpOperationResponse(contentType: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<void>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          contentType
        },
        options);
      operationRes = await this.client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.client.baseUri,
          path: "header/param/protectedkey",
          headerParameters: [
            {
              parameterPath: "contentType",
              mapper: {
                required: true,
                serializedName: "Content-Type",
                type: {
                  name: "String"
                }
              }
            }
          ],
          responses: {
            200: {},
            default: {
              bodyMapper: Mappers.ErrorModel
            }
          },
          serializer: this.serializer
        });
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }

  /**
   * Get a response with header value "Content-Type": "text/html"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async responseProtectedKeyWithHttpOperationResponse(options?: msRest.RequestOptionsBase): Promise<Models.HeaderResponseProtectedKeyResponse> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments({}, options);
      operationRes = await this.client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.client.baseUri,
          path: "header/response/protectedkey",
          responses: {
            200: {
              headersMapper: Mappers.HeaderResponseProtectedKeyHeaders
            },
            default: {
              bodyMapper: Mappers.ErrorModel
            }
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }

  /**
   * Send a post request with header values "scenario": "positive", "value": 1 or "scenario":
   * "negative", "value": -2
   *
   * @param {string} scenario Send a post request with header values "scenario": "positive" or
   * "negative"
   *
   * @param {number} value Send a post request with header values 1 or -2
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async paramIntegerWithHttpOperationResponse(scenario: string, value: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<void>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          scenario,
          value
        },
        options);
      operationRes = await this.client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.client.baseUri,
          path: "header/param/prim/integer",
          headerParameters: [
            {
              parameterPath: "scenario",
              mapper: {
                required: true,
                serializedName: "scenario",
                type: {
                  name: "String"
                }
              }
            },
            {
              parameterPath: "value",
              mapper: {
                required: true,
                serializedName: "value",
                type: {
                  name: "Number"
                }
              }
            }
          ],
          responses: {
            200: {},
            default: {
              bodyMapper: Mappers.ErrorModel
            }
          },
          serializer: this.serializer
        });
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }

  /**
   * Get a response with header value "value": 1 or -2
   *
   * @param {string} scenario Send a post request with header values "scenario": "positive" or
   * "negative"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async responseIntegerWithHttpOperationResponse(scenario: string, options?: msRest.RequestOptionsBase): Promise<Models.HeaderResponseIntegerResponse> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          scenario
        },
        options);
      operationRes = await this.client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.client.baseUri,
          path: "header/response/prim/integer",
          headerParameters: [
            {
              parameterPath: "scenario",
              mapper: {
                required: true,
                serializedName: "scenario",
                type: {
                  name: "String"
                }
              }
            }
          ],
          responses: {
            200: {
              headersMapper: Mappers.HeaderResponseIntegerHeaders
            },
            default: {
              bodyMapper: Mappers.ErrorModel
            }
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }

  /**
   * Send a post request with header values "scenario": "positive", "value": 105 or "scenario":
   * "negative", "value": -2
   *
   * @param {string} scenario Send a post request with header values "scenario": "positive" or
   * "negative"
   *
   * @param {number} value Send a post request with header values 105 or -2
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async paramLongWithHttpOperationResponse(scenario: string, value: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<void>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          scenario,
          value
        },
        options);
      operationRes = await this.client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.client.baseUri,
          path: "header/param/prim/long",
          headerParameters: [
            {
              parameterPath: "scenario",
              mapper: {
                required: true,
                serializedName: "scenario",
                type: {
                  name: "String"
                }
              }
            },
            {
              parameterPath: "value",
              mapper: {
                required: true,
                serializedName: "value",
                type: {
                  name: "Number"
                }
              }
            }
          ],
          responses: {
            200: {},
            default: {
              bodyMapper: Mappers.ErrorModel
            }
          },
          serializer: this.serializer
        });
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }

  /**
   * Get a response with header value "value": 105 or -2
   *
   * @param {string} scenario Send a post request with header values "scenario": "positive" or
   * "negative"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async responseLongWithHttpOperationResponse(scenario: string, options?: msRest.RequestOptionsBase): Promise<Models.HeaderResponseLongResponse> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          scenario
        },
        options);
      operationRes = await this.client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.client.baseUri,
          path: "header/response/prim/long",
          headerParameters: [
            {
              parameterPath: "scenario",
              mapper: {
                required: true,
                serializedName: "scenario",
                type: {
                  name: "String"
                }
              }
            }
          ],
          responses: {
            200: {
              headersMapper: Mappers.HeaderResponseLongHeaders
            },
            default: {
              bodyMapper: Mappers.ErrorModel
            }
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }

  /**
   * Send a post request with header values "scenario": "positive", "value": 0.07 or "scenario":
   * "negative", "value": -3.0
   *
   * @param {string} scenario Send a post request with header values "scenario": "positive" or
   * "negative"
   *
   * @param {number} value Send a post request with header values 0.07 or -3.0
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async paramFloatWithHttpOperationResponse(scenario: string, value: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<void>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          scenario,
          value
        },
        options);
      operationRes = await this.client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.client.baseUri,
          path: "header/param/prim/float",
          headerParameters: [
            {
              parameterPath: "scenario",
              mapper: {
                required: true,
                serializedName: "scenario",
                type: {
                  name: "String"
                }
              }
            },
            {
              parameterPath: "value",
              mapper: {
                required: true,
                serializedName: "value",
                type: {
                  name: "Number"
                }
              }
            }
          ],
          responses: {
            200: {},
            default: {
              bodyMapper: Mappers.ErrorModel
            }
          },
          serializer: this.serializer
        });
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }

  /**
   * Get a response with header value "value": 0.07 or -3.0
   *
   * @param {string} scenario Send a post request with header values "scenario": "positive" or
   * "negative"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async responseFloatWithHttpOperationResponse(scenario: string, options?: msRest.RequestOptionsBase): Promise<Models.HeaderResponseFloatResponse> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          scenario
        },
        options);
      operationRes = await this.client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.client.baseUri,
          path: "header/response/prim/float",
          headerParameters: [
            {
              parameterPath: "scenario",
              mapper: {
                required: true,
                serializedName: "scenario",
                type: {
                  name: "String"
                }
              }
            }
          ],
          responses: {
            200: {
              headersMapper: Mappers.HeaderResponseFloatHeaders
            },
            default: {
              bodyMapper: Mappers.ErrorModel
            }
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }

  /**
   * Send a post request with header values "scenario": "positive", "value": 7e120 or "scenario":
   * "negative", "value": -3.0
   *
   * @param {string} scenario Send a post request with header values "scenario": "positive" or
   * "negative"
   *
   * @param {number} value Send a post request with header values 7e120 or -3.0
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async paramDoubleWithHttpOperationResponse(scenario: string, value: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<void>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          scenario,
          value
        },
        options);
      operationRes = await this.client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.client.baseUri,
          path: "header/param/prim/double",
          headerParameters: [
            {
              parameterPath: "scenario",
              mapper: {
                required: true,
                serializedName: "scenario",
                type: {
                  name: "String"
                }
              }
            },
            {
              parameterPath: "value",
              mapper: {
                required: true,
                serializedName: "value",
                type: {
                  name: "Number"
                }
              }
            }
          ],
          responses: {
            200: {},
            default: {
              bodyMapper: Mappers.ErrorModel
            }
          },
          serializer: this.serializer
        });
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }

  /**
   * Get a response with header value "value": 7e120 or -3.0
   *
   * @param {string} scenario Send a post request with header values "scenario": "positive" or
   * "negative"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async responseDoubleWithHttpOperationResponse(scenario: string, options?: msRest.RequestOptionsBase): Promise<Models.HeaderResponseDoubleResponse> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          scenario
        },
        options);
      operationRes = await this.client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.client.baseUri,
          path: "header/response/prim/double",
          headerParameters: [
            {
              parameterPath: "scenario",
              mapper: {
                required: true,
                serializedName: "scenario",
                type: {
                  name: "String"
                }
              }
            }
          ],
          responses: {
            200: {
              headersMapper: Mappers.HeaderResponseDoubleHeaders
            },
            default: {
              bodyMapper: Mappers.ErrorModel
            }
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }

  /**
   * Send a post request with header values "scenario": "true", "value": true or "scenario": "false",
   * "value": false
   *
   * @param {string} scenario Send a post request with header values "scenario": "true" or "false"
   *
   * @param {boolean} value Send a post request with header values true or false
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async paramBoolWithHttpOperationResponse(scenario: string, value: boolean, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<void>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          scenario,
          value
        },
        options);
      operationRes = await this.client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.client.baseUri,
          path: "header/param/prim/bool",
          headerParameters: [
            {
              parameterPath: "scenario",
              mapper: {
                required: true,
                serializedName: "scenario",
                type: {
                  name: "String"
                }
              }
            },
            {
              parameterPath: "value",
              mapper: {
                required: true,
                serializedName: "value",
                type: {
                  name: "Boolean"
                }
              }
            }
          ],
          responses: {
            200: {},
            default: {
              bodyMapper: Mappers.ErrorModel
            }
          },
          serializer: this.serializer
        });
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }

  /**
   * Get a response with header value "value": true or false
   *
   * @param {string} scenario Send a post request with header values "scenario": "true" or "false"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async responseBoolWithHttpOperationResponse(scenario: string, options?: msRest.RequestOptionsBase): Promise<Models.HeaderResponseBoolResponse> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          scenario
        },
        options);
      operationRes = await this.client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.client.baseUri,
          path: "header/response/prim/bool",
          headerParameters: [
            {
              parameterPath: "scenario",
              mapper: {
                required: true,
                serializedName: "scenario",
                type: {
                  name: "String"
                }
              }
            }
          ],
          responses: {
            200: {
              headersMapper: Mappers.HeaderResponseBoolHeaders
            },
            default: {
              bodyMapper: Mappers.ErrorModel
            }
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }

  /**
   * Send a post request with header values "scenario": "valid", "value": "The quick brown fox jumps
   * over the lazy dog" or "scenario": "null", "value": null or "scenario": "empty", "value": ""
   *
   * @param {string} scenario Send a post request with header values "scenario": "valid" or "null" or
   * "empty"
   *
   * @param {HeaderParamStringOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async paramStringWithHttpOperationResponse(scenario: string, options?: Models.HeaderParamStringOptionalParams): Promise<msRest.HttpOperationResponse<void>> {
    let value = (options && options.value !== undefined) ? options.value : undefined;

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          scenario,
          value
        },
        options);
      operationRes = await this.client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.client.baseUri,
          path: "header/param/prim/string",
          headerParameters: [
            {
              parameterPath: "scenario",
              mapper: {
                required: true,
                serializedName: "scenario",
                type: {
                  name: "String"
                }
              }
            },
            {
              parameterPath: "value",
              mapper: {
                serializedName: "value",
                type: {
                  name: "String"
                }
              }
            }
          ],
          responses: {
            200: {},
            default: {
              bodyMapper: Mappers.ErrorModel
            }
          },
          serializer: this.serializer
        });
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }

  /**
   * Get a response with header values "The quick brown fox jumps over the lazy dog" or null or ""
   *
   * @param {string} scenario Send a post request with header values "scenario": "valid" or "null" or
   * "empty"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async responseStringWithHttpOperationResponse(scenario: string, options?: msRest.RequestOptionsBase): Promise<Models.HeaderResponseStringResponse> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          scenario
        },
        options);
      operationRes = await this.client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.client.baseUri,
          path: "header/response/prim/string",
          headerParameters: [
            {
              parameterPath: "scenario",
              mapper: {
                required: true,
                serializedName: "scenario",
                type: {
                  name: "String"
                }
              }
            }
          ],
          responses: {
            200: {
              headersMapper: Mappers.HeaderResponseStringHeaders
            },
            default: {
              bodyMapper: Mappers.ErrorModel
            }
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }

  /**
   * Send a post request with header values "scenario": "valid", "value": "2010-01-01" or "scenario":
   * "min", "value": "0001-01-01"
   *
   * @param {string} scenario Send a post request with header values "scenario": "valid" or "min"
   *
   * @param {Date | string} value Send a post request with header values "2010-01-01" or "0001-01-01"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async paramDateWithHttpOperationResponse(scenario: string, value: Date | string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<void>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          scenario,
          value
        },
        options);
      operationRes = await this.client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.client.baseUri,
          path: "header/param/prim/date",
          headerParameters: [
            {
              parameterPath: "scenario",
              mapper: {
                required: true,
                serializedName: "scenario",
                type: {
                  name: "String"
                }
              }
            },
            {
              parameterPath: "value",
              mapper: {
                required: true,
                serializedName: "value",
                type: {
                  name: "Date"
                }
              }
            }
          ],
          responses: {
            200: {},
            default: {
              bodyMapper: Mappers.ErrorModel
            }
          },
          serializer: this.serializer
        });
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }

  /**
   * Get a response with header values "2010-01-01" or "0001-01-01"
   *
   * @param {string} scenario Send a post request with header values "scenario": "valid" or "min"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async responseDateWithHttpOperationResponse(scenario: string, options?: msRest.RequestOptionsBase): Promise<Models.HeaderResponseDateResponse> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          scenario
        },
        options);
      operationRes = await this.client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.client.baseUri,
          path: "header/response/prim/date",
          headerParameters: [
            {
              parameterPath: "scenario",
              mapper: {
                required: true,
                serializedName: "scenario",
                type: {
                  name: "String"
                }
              }
            }
          ],
          responses: {
            200: {
              headersMapper: Mappers.HeaderResponseDateHeaders
            },
            default: {
              bodyMapper: Mappers.ErrorModel
            }
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }

  /**
   * Send a post request with header values "scenario": "valid", "value": "2010-01-01T12:34:56Z" or
   * "scenario": "min", "value": "0001-01-01T00:00:00Z"
   *
   * @param {string} scenario Send a post request with header values "scenario": "valid" or "min"
   *
   * @param {Date | string} value Send a post request with header values "2010-01-01T12:34:56Z" or
   * "0001-01-01T00:00:00Z"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async paramDatetimeWithHttpOperationResponse(scenario: string, value: Date | string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<void>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          scenario,
          value
        },
        options);
      operationRes = await this.client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.client.baseUri,
          path: "header/param/prim/datetime",
          headerParameters: [
            {
              parameterPath: "scenario",
              mapper: {
                required: true,
                serializedName: "scenario",
                type: {
                  name: "String"
                }
              }
            },
            {
              parameterPath: "value",
              mapper: {
                required: true,
                serializedName: "value",
                type: {
                  name: "DateTime"
                }
              }
            }
          ],
          responses: {
            200: {},
            default: {
              bodyMapper: Mappers.ErrorModel
            }
          },
          serializer: this.serializer
        });
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }

  /**
   * Get a response with header values "2010-01-01T12:34:56Z" or "0001-01-01T00:00:00Z"
   *
   * @param {string} scenario Send a post request with header values "scenario": "valid" or "min"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async responseDatetimeWithHttpOperationResponse(scenario: string, options?: msRest.RequestOptionsBase): Promise<Models.HeaderResponseDatetimeResponse> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          scenario
        },
        options);
      operationRes = await this.client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.client.baseUri,
          path: "header/response/prim/datetime",
          headerParameters: [
            {
              parameterPath: "scenario",
              mapper: {
                required: true,
                serializedName: "scenario",
                type: {
                  name: "String"
                }
              }
            }
          ],
          responses: {
            200: {
              headersMapper: Mappers.HeaderResponseDatetimeHeaders
            },
            default: {
              bodyMapper: Mappers.ErrorModel
            }
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }

  /**
   * Send a post request with header values "scenario": "valid", "value": "Wed, 01 Jan 2010 12:34:56
   * GMT" or "scenario": "min", "value": "Mon, 01 Jan 0001 00:00:00 GMT"
   *
   * @param {string} scenario Send a post request with header values "scenario": "valid" or "min"
   *
   * @param {HeaderParamDatetimeRfc1123OptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async paramDatetimeRfc1123WithHttpOperationResponse(scenario: string, options?: Models.HeaderParamDatetimeRfc1123OptionalParams): Promise<msRest.HttpOperationResponse<void>> {
    let value = (options && options.value !== undefined) ? options.value : undefined;

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          scenario,
          value
        },
        options);
      operationRes = await this.client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.client.baseUri,
          path: "header/param/prim/datetimerfc1123",
          headerParameters: [
            {
              parameterPath: "scenario",
              mapper: {
                required: true,
                serializedName: "scenario",
                type: {
                  name: "String"
                }
              }
            },
            {
              parameterPath: "value",
              mapper: {
                serializedName: "value",
                type: {
                  name: "DateTimeRfc1123"
                }
              }
            }
          ],
          responses: {
            200: {},
            default: {
              bodyMapper: Mappers.ErrorModel
            }
          },
          serializer: this.serializer
        });
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }

  /**
   * Get a response with header values "Wed, 01 Jan 2010 12:34:56 GMT" or "Mon, 01 Jan 0001 00:00:00
   * GMT"
   *
   * @param {string} scenario Send a post request with header values "scenario": "valid" or "min"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async responseDatetimeRfc1123WithHttpOperationResponse(scenario: string, options?: msRest.RequestOptionsBase): Promise<Models.HeaderResponseDatetimeRfc1123Response> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          scenario
        },
        options);
      operationRes = await this.client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.client.baseUri,
          path: "header/response/prim/datetimerfc1123",
          headerParameters: [
            {
              parameterPath: "scenario",
              mapper: {
                required: true,
                serializedName: "scenario",
                type: {
                  name: "String"
                }
              }
            }
          ],
          responses: {
            200: {
              headersMapper: Mappers.HeaderResponseDatetimeRfc1123Headers
            },
            default: {
              bodyMapper: Mappers.ErrorModel
            }
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }

  /**
   * Send a post request with header values "scenario": "valid", "value": "P123DT22H14M12.011S"
   *
   * @param {string} scenario Send a post request with header values "scenario": "valid"
   *
   * @param {string} value Send a post request with header values "P123DT22H14M12.011S"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async paramDurationWithHttpOperationResponse(scenario: string, value: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<void>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          scenario,
          value
        },
        options);
      operationRes = await this.client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.client.baseUri,
          path: "header/param/prim/duration",
          headerParameters: [
            {
              parameterPath: "scenario",
              mapper: {
                required: true,
                serializedName: "scenario",
                type: {
                  name: "String"
                }
              }
            },
            {
              parameterPath: "value",
              mapper: {
                required: true,
                serializedName: "value",
                type: {
                  name: "TimeSpan"
                }
              }
            }
          ],
          responses: {
            200: {},
            default: {
              bodyMapper: Mappers.ErrorModel
            }
          },
          serializer: this.serializer
        });
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }

  /**
   * Get a response with header values "P123DT22H14M12.011S"
   *
   * @param {string} scenario Send a post request with header values "scenario": "valid"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async responseDurationWithHttpOperationResponse(scenario: string, options?: msRest.RequestOptionsBase): Promise<Models.HeaderResponseDurationResponse> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          scenario
        },
        options);
      operationRes = await this.client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.client.baseUri,
          path: "header/response/prim/duration",
          headerParameters: [
            {
              parameterPath: "scenario",
              mapper: {
                required: true,
                serializedName: "scenario",
                type: {
                  name: "String"
                }
              }
            }
          ],
          responses: {
            200: {
              headersMapper: Mappers.HeaderResponseDurationHeaders
            },
            default: {
              bodyMapper: Mappers.ErrorModel
            }
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }

  /**
   * Send a post request with header values "scenario": "valid", "value": "啊齄丂狛狜隣郎隣兀﨩"
   *
   * @param {string} scenario Send a post request with header values "scenario": "valid"
   *
   * @param {Uint8Array} value Send a post request with header values "啊齄丂狛狜隣郎隣兀﨩"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async paramByteWithHttpOperationResponse(scenario: string, value: Uint8Array, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<void>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          scenario,
          value
        },
        options);
      operationRes = await this.client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.client.baseUri,
          path: "header/param/prim/byte",
          headerParameters: [
            {
              parameterPath: "scenario",
              mapper: {
                required: true,
                serializedName: "scenario",
                type: {
                  name: "String"
                }
              }
            },
            {
              parameterPath: "value",
              mapper: {
                required: true,
                serializedName: "value",
                type: {
                  name: "ByteArray"
                }
              }
            }
          ],
          responses: {
            200: {},
            default: {
              bodyMapper: Mappers.ErrorModel
            }
          },
          serializer: this.serializer
        });
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }

  /**
   * Get a response with header values "啊齄丂狛狜隣郎隣兀﨩"
   *
   * @param {string} scenario Send a post request with header values "scenario": "valid"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async responseByteWithHttpOperationResponse(scenario: string, options?: msRest.RequestOptionsBase): Promise<Models.HeaderResponseByteResponse> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          scenario
        },
        options);
      operationRes = await this.client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.client.baseUri,
          path: "header/response/prim/byte",
          headerParameters: [
            {
              parameterPath: "scenario",
              mapper: {
                required: true,
                serializedName: "scenario",
                type: {
                  name: "String"
                }
              }
            }
          ],
          responses: {
            200: {
              headersMapper: Mappers.HeaderResponseByteHeaders
            },
            default: {
              bodyMapper: Mappers.ErrorModel
            }
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }

  /**
   * Send a post request with header values "scenario": "valid", "value": "GREY" or "scenario":
   * "null", "value": null
   *
   * @param {string} scenario Send a post request with header values "scenario": "valid" or "null" or
   * "empty"
   *
   * @param {HeaderParamEnumOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async paramEnumWithHttpOperationResponse(scenario: string, options?: Models.HeaderParamEnumOptionalParams): Promise<msRest.HttpOperationResponse<void>> {
    let value = (options && options.value !== undefined) ? options.value : undefined;

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          scenario,
          value
        },
        options);
      operationRes = await this.client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.client.baseUri,
          path: "header/param/prim/enum",
          headerParameters: [
            {
              parameterPath: "scenario",
              mapper: {
                required: true,
                serializedName: "scenario",
                type: {
                  name: "String"
                }
              }
            },
            {
              parameterPath: "value",
              mapper: {
                serializedName: "value",
                type: {
                  name: "Enum",
                  allowedValues: [
                    "White",
                    "black",
                    "GREY"
                  ]
                }
              }
            }
          ],
          responses: {
            200: {},
            default: {
              bodyMapper: Mappers.ErrorModel
            }
          },
          serializer: this.serializer
        });
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }

  /**
   * Get a response with header values "GREY" or null
   *
   * @param {string} scenario Send a post request with header values "scenario": "valid" or "null" or
   * "empty"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async responseEnumWithHttpOperationResponse(scenario: string, options?: msRest.RequestOptionsBase): Promise<Models.HeaderResponseEnumResponse> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          scenario
        },
        options);
      operationRes = await this.client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.client.baseUri,
          path: "header/response/prim/enum",
          headerParameters: [
            {
              parameterPath: "scenario",
              mapper: {
                required: true,
                serializedName: "scenario",
                type: {
                  name: "String"
                }
              }
            }
          ],
          responses: {
            200: {
              headersMapper: Mappers.HeaderResponseEnumHeaders
            },
            default: {
              bodyMapper: Mappers.ErrorModel
            }
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }

  /**
   * Send x-ms-client-request-id = 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0 in the header of the request
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async customRequestIdWithHttpOperationResponse(options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<void>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments({}, options);
      operationRes = await this.client.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.client.baseUri,
          path: "header/custom/x-ms-client-request-id/9C4D50EE-2D56-4CD3-8152-34347DC9F2B0",
          responses: {
            200: {},
            default: {
              bodyMapper: Mappers.ErrorModel
            }
          },
          serializer: this.serializer
        });
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }

  /**
   * Send a post request with header value "User-Agent": "overwrite"
   *
   * @param {string} userAgent Send a post request with header value "User-Agent": "overwrite"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  paramExistingKey(userAgent: string): Promise<void>;
  paramExistingKey(userAgent: string, options: msRest.RequestOptionsBase): Promise<void>;
  paramExistingKey(userAgent: string, callback: msRest.ServiceCallback<void>): void;
  paramExistingKey(userAgent: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  paramExistingKey(userAgent: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.paramExistingKeyWithHttpOperationResponse(userAgent, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.paramExistingKeyWithHttpOperationResponse(userAgent, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * Get a response with header value "User-Agent": "overwrite"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  responseExistingKey(): Promise<void>;
  responseExistingKey(options: msRest.RequestOptionsBase): Promise<void>;
  responseExistingKey(callback: msRest.ServiceCallback<void>): void;
  responseExistingKey(options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  responseExistingKey(options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.responseExistingKeyWithHttpOperationResponse(options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.responseExistingKeyWithHttpOperationResponse(options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * Send a post request with header value "Content-Type": "text/html"
   *
   * @param {string} contentType Send a post request with header value "Content-Type": "text/html"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  paramProtectedKey(contentType: string): Promise<void>;
  paramProtectedKey(contentType: string, options: msRest.RequestOptionsBase): Promise<void>;
  paramProtectedKey(contentType: string, callback: msRest.ServiceCallback<void>): void;
  paramProtectedKey(contentType: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  paramProtectedKey(contentType: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.paramProtectedKeyWithHttpOperationResponse(contentType, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.paramProtectedKeyWithHttpOperationResponse(contentType, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * Get a response with header value "Content-Type": "text/html"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  responseProtectedKey(): Promise<void>;
  responseProtectedKey(options: msRest.RequestOptionsBase): Promise<void>;
  responseProtectedKey(callback: msRest.ServiceCallback<void>): void;
  responseProtectedKey(options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  responseProtectedKey(options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.responseProtectedKeyWithHttpOperationResponse(options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.responseProtectedKeyWithHttpOperationResponse(options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * Send a post request with header values "scenario": "positive", "value": 1 or "scenario":
   * "negative", "value": -2
   *
   * @param {string} scenario Send a post request with header values "scenario": "positive" or
   * "negative"
   *
   * @param {number} value Send a post request with header values 1 or -2
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  paramInteger(scenario: string, value: number): Promise<void>;
  paramInteger(scenario: string, value: number, options: msRest.RequestOptionsBase): Promise<void>;
  paramInteger(scenario: string, value: number, callback: msRest.ServiceCallback<void>): void;
  paramInteger(scenario: string, value: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  paramInteger(scenario: string, value: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.paramIntegerWithHttpOperationResponse(scenario, value, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.paramIntegerWithHttpOperationResponse(scenario, value, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * Get a response with header value "value": 1 or -2
   *
   * @param {string} scenario Send a post request with header values "scenario": "positive" or
   * "negative"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  responseInteger(scenario: string): Promise<void>;
  responseInteger(scenario: string, options: msRest.RequestOptionsBase): Promise<void>;
  responseInteger(scenario: string, callback: msRest.ServiceCallback<void>): void;
  responseInteger(scenario: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  responseInteger(scenario: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.responseIntegerWithHttpOperationResponse(scenario, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.responseIntegerWithHttpOperationResponse(scenario, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * Send a post request with header values "scenario": "positive", "value": 105 or "scenario":
   * "negative", "value": -2
   *
   * @param {string} scenario Send a post request with header values "scenario": "positive" or
   * "negative"
   *
   * @param {number} value Send a post request with header values 105 or -2
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  paramLong(scenario: string, value: number): Promise<void>;
  paramLong(scenario: string, value: number, options: msRest.RequestOptionsBase): Promise<void>;
  paramLong(scenario: string, value: number, callback: msRest.ServiceCallback<void>): void;
  paramLong(scenario: string, value: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  paramLong(scenario: string, value: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.paramLongWithHttpOperationResponse(scenario, value, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.paramLongWithHttpOperationResponse(scenario, value, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * Get a response with header value "value": 105 or -2
   *
   * @param {string} scenario Send a post request with header values "scenario": "positive" or
   * "negative"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  responseLong(scenario: string): Promise<void>;
  responseLong(scenario: string, options: msRest.RequestOptionsBase): Promise<void>;
  responseLong(scenario: string, callback: msRest.ServiceCallback<void>): void;
  responseLong(scenario: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  responseLong(scenario: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.responseLongWithHttpOperationResponse(scenario, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.responseLongWithHttpOperationResponse(scenario, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * Send a post request with header values "scenario": "positive", "value": 0.07 or "scenario":
   * "negative", "value": -3.0
   *
   * @param {string} scenario Send a post request with header values "scenario": "positive" or
   * "negative"
   *
   * @param {number} value Send a post request with header values 0.07 or -3.0
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  paramFloat(scenario: string, value: number): Promise<void>;
  paramFloat(scenario: string, value: number, options: msRest.RequestOptionsBase): Promise<void>;
  paramFloat(scenario: string, value: number, callback: msRest.ServiceCallback<void>): void;
  paramFloat(scenario: string, value: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  paramFloat(scenario: string, value: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.paramFloatWithHttpOperationResponse(scenario, value, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.paramFloatWithHttpOperationResponse(scenario, value, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * Get a response with header value "value": 0.07 or -3.0
   *
   * @param {string} scenario Send a post request with header values "scenario": "positive" or
   * "negative"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  responseFloat(scenario: string): Promise<void>;
  responseFloat(scenario: string, options: msRest.RequestOptionsBase): Promise<void>;
  responseFloat(scenario: string, callback: msRest.ServiceCallback<void>): void;
  responseFloat(scenario: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  responseFloat(scenario: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.responseFloatWithHttpOperationResponse(scenario, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.responseFloatWithHttpOperationResponse(scenario, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * Send a post request with header values "scenario": "positive", "value": 7e120 or "scenario":
   * "negative", "value": -3.0
   *
   * @param {string} scenario Send a post request with header values "scenario": "positive" or
   * "negative"
   *
   * @param {number} value Send a post request with header values 7e120 or -3.0
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  paramDouble(scenario: string, value: number): Promise<void>;
  paramDouble(scenario: string, value: number, options: msRest.RequestOptionsBase): Promise<void>;
  paramDouble(scenario: string, value: number, callback: msRest.ServiceCallback<void>): void;
  paramDouble(scenario: string, value: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  paramDouble(scenario: string, value: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.paramDoubleWithHttpOperationResponse(scenario, value, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.paramDoubleWithHttpOperationResponse(scenario, value, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * Get a response with header value "value": 7e120 or -3.0
   *
   * @param {string} scenario Send a post request with header values "scenario": "positive" or
   * "negative"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  responseDouble(scenario: string): Promise<void>;
  responseDouble(scenario: string, options: msRest.RequestOptionsBase): Promise<void>;
  responseDouble(scenario: string, callback: msRest.ServiceCallback<void>): void;
  responseDouble(scenario: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  responseDouble(scenario: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.responseDoubleWithHttpOperationResponse(scenario, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.responseDoubleWithHttpOperationResponse(scenario, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * Send a post request with header values "scenario": "true", "value": true or "scenario": "false",
   * "value": false
   *
   * @param {string} scenario Send a post request with header values "scenario": "true" or "false"
   *
   * @param {boolean} value Send a post request with header values true or false
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  paramBool(scenario: string, value: boolean): Promise<void>;
  paramBool(scenario: string, value: boolean, options: msRest.RequestOptionsBase): Promise<void>;
  paramBool(scenario: string, value: boolean, callback: msRest.ServiceCallback<void>): void;
  paramBool(scenario: string, value: boolean, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  paramBool(scenario: string, value: boolean, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.paramBoolWithHttpOperationResponse(scenario, value, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.paramBoolWithHttpOperationResponse(scenario, value, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * Get a response with header value "value": true or false
   *
   * @param {string} scenario Send a post request with header values "scenario": "true" or "false"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  responseBool(scenario: string): Promise<void>;
  responseBool(scenario: string, options: msRest.RequestOptionsBase): Promise<void>;
  responseBool(scenario: string, callback: msRest.ServiceCallback<void>): void;
  responseBool(scenario: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  responseBool(scenario: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.responseBoolWithHttpOperationResponse(scenario, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.responseBoolWithHttpOperationResponse(scenario, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * Send a post request with header values "scenario": "valid", "value": "The quick brown fox jumps
   * over the lazy dog" or "scenario": "null", "value": null or "scenario": "empty", "value": ""
   *
   * @param {string} scenario Send a post request with header values "scenario": "valid" or "null" or
   * "empty"
   *
   * @param {HeaderParamStringOptionalParams} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  paramString(scenario: string): Promise<void>;
  paramString(scenario: string, options: Models.HeaderParamStringOptionalParams): Promise<void>;
  paramString(scenario: string, callback: msRest.ServiceCallback<void>): void;
  paramString(scenario: string, options: Models.HeaderParamStringOptionalParams, callback: msRest.ServiceCallback<void>): void;
  paramString(scenario: string, options?: Models.HeaderParamStringOptionalParams, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.paramStringWithHttpOperationResponse(scenario, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.paramStringWithHttpOperationResponse(scenario, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * Get a response with header values "The quick brown fox jumps over the lazy dog" or null or ""
   *
   * @param {string} scenario Send a post request with header values "scenario": "valid" or "null" or
   * "empty"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  responseString(scenario: string): Promise<void>;
  responseString(scenario: string, options: msRest.RequestOptionsBase): Promise<void>;
  responseString(scenario: string, callback: msRest.ServiceCallback<void>): void;
  responseString(scenario: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  responseString(scenario: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.responseStringWithHttpOperationResponse(scenario, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.responseStringWithHttpOperationResponse(scenario, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * Send a post request with header values "scenario": "valid", "value": "2010-01-01" or "scenario":
   * "min", "value": "0001-01-01"
   *
   * @param {string} scenario Send a post request with header values "scenario": "valid" or "min"
   *
   * @param {Date | string} value Send a post request with header values "2010-01-01" or "0001-01-01"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  paramDate(scenario: string, value: Date | string): Promise<void>;
  paramDate(scenario: string, value: Date | string, options: msRest.RequestOptionsBase): Promise<void>;
  paramDate(scenario: string, value: Date | string, callback: msRest.ServiceCallback<void>): void;
  paramDate(scenario: string, value: Date | string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  paramDate(scenario: string, value: Date | string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.paramDateWithHttpOperationResponse(scenario, value, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.paramDateWithHttpOperationResponse(scenario, value, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * Get a response with header values "2010-01-01" or "0001-01-01"
   *
   * @param {string} scenario Send a post request with header values "scenario": "valid" or "min"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  responseDate(scenario: string): Promise<void>;
  responseDate(scenario: string, options: msRest.RequestOptionsBase): Promise<void>;
  responseDate(scenario: string, callback: msRest.ServiceCallback<void>): void;
  responseDate(scenario: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  responseDate(scenario: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.responseDateWithHttpOperationResponse(scenario, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.responseDateWithHttpOperationResponse(scenario, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * Send a post request with header values "scenario": "valid", "value": "2010-01-01T12:34:56Z" or
   * "scenario": "min", "value": "0001-01-01T00:00:00Z"
   *
   * @param {string} scenario Send a post request with header values "scenario": "valid" or "min"
   *
   * @param {Date | string} value Send a post request with header values "2010-01-01T12:34:56Z" or
   * "0001-01-01T00:00:00Z"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  paramDatetime(scenario: string, value: Date | string): Promise<void>;
  paramDatetime(scenario: string, value: Date | string, options: msRest.RequestOptionsBase): Promise<void>;
  paramDatetime(scenario: string, value: Date | string, callback: msRest.ServiceCallback<void>): void;
  paramDatetime(scenario: string, value: Date | string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  paramDatetime(scenario: string, value: Date | string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.paramDatetimeWithHttpOperationResponse(scenario, value, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.paramDatetimeWithHttpOperationResponse(scenario, value, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * Get a response with header values "2010-01-01T12:34:56Z" or "0001-01-01T00:00:00Z"
   *
   * @param {string} scenario Send a post request with header values "scenario": "valid" or "min"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  responseDatetime(scenario: string): Promise<void>;
  responseDatetime(scenario: string, options: msRest.RequestOptionsBase): Promise<void>;
  responseDatetime(scenario: string, callback: msRest.ServiceCallback<void>): void;
  responseDatetime(scenario: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  responseDatetime(scenario: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.responseDatetimeWithHttpOperationResponse(scenario, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.responseDatetimeWithHttpOperationResponse(scenario, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * Send a post request with header values "scenario": "valid", "value": "Wed, 01 Jan 2010 12:34:56
   * GMT" or "scenario": "min", "value": "Mon, 01 Jan 0001 00:00:00 GMT"
   *
   * @param {string} scenario Send a post request with header values "scenario": "valid" or "min"
   *
   * @param {HeaderParamDatetimeRfc1123OptionalParams} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  paramDatetimeRfc1123(scenario: string): Promise<void>;
  paramDatetimeRfc1123(scenario: string, options: Models.HeaderParamDatetimeRfc1123OptionalParams): Promise<void>;
  paramDatetimeRfc1123(scenario: string, callback: msRest.ServiceCallback<void>): void;
  paramDatetimeRfc1123(scenario: string, options: Models.HeaderParamDatetimeRfc1123OptionalParams, callback: msRest.ServiceCallback<void>): void;
  paramDatetimeRfc1123(scenario: string, options?: Models.HeaderParamDatetimeRfc1123OptionalParams, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.paramDatetimeRfc1123WithHttpOperationResponse(scenario, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.paramDatetimeRfc1123WithHttpOperationResponse(scenario, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * Get a response with header values "Wed, 01 Jan 2010 12:34:56 GMT" or "Mon, 01 Jan 0001 00:00:00
   * GMT"
   *
   * @param {string} scenario Send a post request with header values "scenario": "valid" or "min"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  responseDatetimeRfc1123(scenario: string): Promise<void>;
  responseDatetimeRfc1123(scenario: string, options: msRest.RequestOptionsBase): Promise<void>;
  responseDatetimeRfc1123(scenario: string, callback: msRest.ServiceCallback<void>): void;
  responseDatetimeRfc1123(scenario: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  responseDatetimeRfc1123(scenario: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.responseDatetimeRfc1123WithHttpOperationResponse(scenario, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.responseDatetimeRfc1123WithHttpOperationResponse(scenario, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * Send a post request with header values "scenario": "valid", "value": "P123DT22H14M12.011S"
   *
   * @param {string} scenario Send a post request with header values "scenario": "valid"
   *
   * @param {string} value Send a post request with header values "P123DT22H14M12.011S"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  paramDuration(scenario: string, value: string): Promise<void>;
  paramDuration(scenario: string, value: string, options: msRest.RequestOptionsBase): Promise<void>;
  paramDuration(scenario: string, value: string, callback: msRest.ServiceCallback<void>): void;
  paramDuration(scenario: string, value: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  paramDuration(scenario: string, value: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.paramDurationWithHttpOperationResponse(scenario, value, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.paramDurationWithHttpOperationResponse(scenario, value, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * Get a response with header values "P123DT22H14M12.011S"
   *
   * @param {string} scenario Send a post request with header values "scenario": "valid"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  responseDuration(scenario: string): Promise<void>;
  responseDuration(scenario: string, options: msRest.RequestOptionsBase): Promise<void>;
  responseDuration(scenario: string, callback: msRest.ServiceCallback<void>): void;
  responseDuration(scenario: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  responseDuration(scenario: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.responseDurationWithHttpOperationResponse(scenario, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.responseDurationWithHttpOperationResponse(scenario, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * Send a post request with header values "scenario": "valid", "value": "啊齄丂狛狜隣郎隣兀﨩"
   *
   * @param {string} scenario Send a post request with header values "scenario": "valid"
   *
   * @param {Uint8Array} value Send a post request with header values "啊齄丂狛狜隣郎隣兀﨩"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  paramByte(scenario: string, value: Uint8Array): Promise<void>;
  paramByte(scenario: string, value: Uint8Array, options: msRest.RequestOptionsBase): Promise<void>;
  paramByte(scenario: string, value: Uint8Array, callback: msRest.ServiceCallback<void>): void;
  paramByte(scenario: string, value: Uint8Array, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  paramByte(scenario: string, value: Uint8Array, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.paramByteWithHttpOperationResponse(scenario, value, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.paramByteWithHttpOperationResponse(scenario, value, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * Get a response with header values "啊齄丂狛狜隣郎隣兀﨩"
   *
   * @param {string} scenario Send a post request with header values "scenario": "valid"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  responseByte(scenario: string): Promise<void>;
  responseByte(scenario: string, options: msRest.RequestOptionsBase): Promise<void>;
  responseByte(scenario: string, callback: msRest.ServiceCallback<void>): void;
  responseByte(scenario: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  responseByte(scenario: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.responseByteWithHttpOperationResponse(scenario, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.responseByteWithHttpOperationResponse(scenario, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * Send a post request with header values "scenario": "valid", "value": "GREY" or "scenario":
   * "null", "value": null
   *
   * @param {string} scenario Send a post request with header values "scenario": "valid" or "null" or
   * "empty"
   *
   * @param {HeaderParamEnumOptionalParams} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  paramEnum(scenario: string): Promise<void>;
  paramEnum(scenario: string, options: Models.HeaderParamEnumOptionalParams): Promise<void>;
  paramEnum(scenario: string, callback: msRest.ServiceCallback<void>): void;
  paramEnum(scenario: string, options: Models.HeaderParamEnumOptionalParams, callback: msRest.ServiceCallback<void>): void;
  paramEnum(scenario: string, options?: Models.HeaderParamEnumOptionalParams, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.paramEnumWithHttpOperationResponse(scenario, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.paramEnumWithHttpOperationResponse(scenario, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * Get a response with header values "GREY" or null
   *
   * @param {string} scenario Send a post request with header values "scenario": "valid" or "null" or
   * "empty"
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  responseEnum(scenario: string): Promise<void>;
  responseEnum(scenario: string, options: msRest.RequestOptionsBase): Promise<void>;
  responseEnum(scenario: string, callback: msRest.ServiceCallback<void>): void;
  responseEnum(scenario: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  responseEnum(scenario: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.responseEnumWithHttpOperationResponse(scenario, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.responseEnumWithHttpOperationResponse(scenario, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * Send x-ms-client-request-id = 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0 in the header of the request
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  customRequestId(): Promise<void>;
  customRequestId(options: msRest.RequestOptionsBase): Promise<void>;
  customRequestId(callback: msRest.ServiceCallback<void>): void;
  customRequestId(options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  customRequestId(options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.customRequestIdWithHttpOperationResponse(options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.customRequestIdWithHttpOperationResponse(options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

}
