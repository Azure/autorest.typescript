/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as coreHttp from "@azure/core-http";

export type AdlsRemoteExceptionUnion =
  | AdlsRemoteException
  | AdlsIllegalArgumentException
  | AdlsUnsupportedOperationException
  | AdlsSecurityException
  | AdlsIOException
  | AdlsFileNotFoundException
  | AdlsFileAlreadyExistsException
  | AdlsBadOffsetException
  | AdlsRuntimeException
  | AdlsAccessControlException
  | AdlsThrottledException;

/**
 * Data Lake Store filesystem error containing a specific WebHDFS exception.
 */
export interface AdlsError {
  /**
   * the object representing the actual WebHDFS exception being returned.
   */
  readonly remoteException?: AdlsRemoteExceptionUnion;
}

/**
 * Data Lake Store filesystem exception based on the WebHDFS definition for RemoteExceptions. This is a WebHDFS 'catch all' exception
 */
export interface AdlsRemoteException {
  /**
   * Polymorphic discriminator, which specifies the different types this object can be
   */
  exception:
    | "IllegalArgumentException"
    | "UnsupportedOperationException"
    | "SecurityException"
    | "IOException"
    | "FileNotFoundException"
    | "FileAlreadyExistsException"
    | "BadOffsetException"
    | "RuntimeException"
    | "AccessControlException"
    | "ThrottledException";
  /**
   * the full class package name for the exception thrown, such as 'java.lang.IllegalArgumentException'.
   */
  readonly javaClassName?: string;
  /**
   * the message associated with the exception that was thrown, such as 'Invalid value for webhdfs parameter "permission":...'.
   */
  readonly message?: string;
}

/**
 * The result of the request or operation.
 */
export interface FileOperationResult {
  /**
   * the result of the operation or request.
   */
  readonly operationResult?: boolean;
}

/**
 * Data Lake Store filesystem file status list information response.
 */
export interface FileStatusesResult {
  /**
   * the object representing the list of file statuses.
   */
  readonly fileStatuses?: FileStatuses;
}

/**
 * Data Lake Store file status list information.
 */
export interface FileStatuses {
  /**
   * the object containing the list of properties of the files.
   */
  readonly fileStatus?: FileStatusProperties[];
}

/**
 * Data Lake Store file or directory information.
 */
export interface FileStatusProperties {
  /**
   * the last access time as ticks since the epoch.
   */
  readonly accessTime?: number;
  /**
   * the block size for the file.
   */
  readonly blockSize?: number;
  /**
   * Gets the expiration time, if any, as ticks since the epoch. If the value is 0 or DateTime.MaxValue there is no expiration.
   */
  readonly expirationTime?: number;
  /**
   * the group owner.
   */
  readonly group?: string;
  /**
   * the number of bytes in a file.
   */
  readonly length?: number;
  /**
   * the modification time as ticks since the epoch.
   */
  readonly modificationTime?: number;
  /**
   * the user who is the owner.
   */
  readonly owner?: string;
  /**
   * the path suffix.
   */
  readonly pathSuffix?: string;
  /**
   * the permission represented as an string.
   */
  readonly permission?: string;
  /**
   * the type of the path object.
   */
  readonly type?: FileType;
  /**
   * flag to indicate if extended acls are enabled
   */
  readonly aclBit?: boolean;
}

/**
 * Data Lake Store filesystem content summary information response.
 */
export interface ContentSummaryResult {
  /**
   * the content summary for the specified path
   */
  readonly contentSummary?: ContentSummary;
}

/**
 * Data Lake Store content summary information
 */
export interface ContentSummary {
  /**
   * the number of directories.
   */
  readonly directoryCount?: number;
  /**
   * the number of files.
   */
  readonly fileCount?: number;
  /**
   * the number of bytes used by the content.
   */
  readonly length?: number;
  /**
   * the disk space consumed by the content.
   */
  readonly spaceConsumed?: number;
}

/**
 * Data Lake Store filesystem file status information response.
 */
export interface FileStatusResult {
  /**
   * the file status object associated with the specified path.
   */
  readonly fileStatus?: FileStatusProperties;
}

/**
 * Data Lake Store file or directory Access Control List information.
 */
export interface AclStatusResult {
  /**
   * the AclStatus object for a given file or directory.
   */
  aclStatus?: AclStatus;
}

/**
 * Data Lake Store file or directory Access Control List information.
 */
export interface AclStatus {
  /**
   * the list of ACLSpec entries on a file or directory.
   */
  entries?: string[];
  /**
   * the group owner, an AAD Object ID.
   */
  group?: string;
  /**
   * the user owner, an AAD Object ID.
   */
  owner?: string;
  /**
   * The octal representation of the unnamed user, mask and other permissions.
   */
  permission?: string;
  /**
   * the indicator of whether the sticky bit is on or off.
   */
  readonly stickyBit?: boolean;
}

/**
 * A WebHDFS exception thrown indicating that one more arguments is incorrect. Thrown when a 400 error response code is returned (bad request).
 */
export type AdlsIllegalArgumentException = AdlsRemoteException & {};

/**
 * A WebHDFS exception thrown indicating that the requested operation is not supported. Thrown when a 400 error response code is returned (bad request).
 */
export type AdlsUnsupportedOperationException = AdlsRemoteException & {};

/**
 * A WebHDFS exception thrown indicating that access is denied. Thrown when a 401 error response code is returned (Unauthorized).
 */
export type AdlsSecurityException = AdlsRemoteException & {};

/**
 * A WebHDFS exception thrown indicating there was an IO (read or write) error. Thrown when a 403 error response code is returned (forbidden).
 */
export type AdlsIOException = AdlsRemoteException & {};

/**
 * A WebHDFS exception thrown indicating the file or folder could not be found. Thrown when a 404 error response code is returned (not found).
 */
export type AdlsFileNotFoundException = AdlsRemoteException & {};

/**
 * A WebHDFS exception thrown indicating the file or folder already exists. Thrown when a 403 error response code is returned (forbidden).
 */
export type AdlsFileAlreadyExistsException = AdlsRemoteException & {};

/**
 * A WebHDFS exception thrown indicating the append or read is from a bad offset. Thrown when a 400 error response code is returned for append and open operations (Bad request).
 */
export type AdlsBadOffsetException = AdlsRemoteException & {};

/**
 * A WebHDFS exception thrown when an unexpected error occurs during an operation. Thrown when a 500 error response code is returned (Internal server error).
 */
export type AdlsRuntimeException = AdlsRemoteException & {};

/**
 * A WebHDFS exception thrown indicating that access is denied due to insufficient permissions. Thrown when a 403 error response code is returned (forbidden).
 */
export type AdlsAccessControlException = AdlsRemoteException & {};

/**
 * A WebHDFS exception thrown indicating that the request is being throttled. Reducing the number of requests or request size helps to mitigate this error.
 */
export type AdlsThrottledException = AdlsRemoteException & {};
/**
 * Defines values for ExpiryOptionType.
 */
export type ExpiryOptionType =
  | "NeverExpire"
  | "RelativeToNow"
  | "RelativeToCreationDate"
  | "Absolute";
/**
 * Defines values for SyncFlag.
 */
export type SyncFlag = "DATA" | "METADATA" | "CLOSE";
/**
 * Defines values for FileType.
 */
export type FileType = "FILE" | "DIRECTORY";

/**
 * Optional parameters.
 */
export interface FileSystemSetFileExpiryOptionalParams
  extends coreHttp.OperationOptions {
  /**
   * The time that the file will expire, corresponding to the ExpiryOption that was set.
   */
  expireTime?: number;
}

/**
 * Optional parameters.
 */
export interface FileSystemConcurrentAppendOptionalParams
  extends coreHttp.OperationOptions {
  /**
   * Optionally indicates what to do after completion of the concurrent append. DATA indicates that more data will be sent immediately by the client, the file handle should remain open/locked, and file metadata (including file length, last modified time) should NOT get updated. METADATA indicates that more data will be sent immediately by the client, the file handle should remain open/locked, and file metadata should get updated. CLOSE indicates that the client is done sending data, the file handle should be closed/unlocked, and file metadata should get updated.
   */
  syncFlag?: SyncFlag;
}

/**
 * Optional parameters.
 */
export interface FileSystemMkdirsOptionalParams
  extends coreHttp.OperationOptions {
  /**
   * Optional octal permission with which the directory should be created.
   */
  permission?: number;
}

/**
 * Contains response data for the mkdirs operation.
 */
export type FileSystemMkdirsResponse = FileOperationResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: FileOperationResult;
  };
};

/**
 * Optional parameters.
 */
export interface FileSystemMsConcatOptionalParams
  extends coreHttp.OperationOptions {
  /**
   * Indicates that as an optimization instead of deleting each individual source stream, delete the source stream folder if all streams are in the same folder instead. This results in a substantial performance improvement when the only streams in the folder are part of the concatenation operation. WARNING: This includes the deletion of any other files that are not source files. Only set this to true when source files are the only files in the source directory.
   */
  deleteSourceDirectory?: boolean;
}

/**
 * Optional parameters.
 */
export interface FileSystemListFileStatusOptionalParams
  extends coreHttp.OperationOptions {
  /**
   * Gets or sets the number of items to return. Optional.
   */
  listSize?: number;
  /**
   * Gets or sets the item or lexicographical index after which to begin returning results. For example, a file list of 'a','b','d' and listAfter='b' will return 'd', and a listAfter='c' will also return 'd'. Optional.
   */
  listAfter?: string;
  /**
   * Gets or sets the item or lexicographical index before which to begin returning results. For example, a file list of 'a','b','d' and listBefore='d' will return 'a','b', and a listBefore='c' will also return 'a','b'. Optional.
   */
  listBefore?: string;
  /**
   * An optional switch to return friendly names in place of owner and group. tooId=false returns friendly names instead of the AAD Object ID. Default value is true, returning AAD object IDs.
   */
  tooId?: boolean;
}

/**
 * Contains response data for the listFileStatus operation.
 */
export type FileSystemListFileStatusResponse = FileStatusesResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: FileStatusesResult;
  };
};

/**
 * Contains response data for the getContentSummary operation.
 */
export type FileSystemGetContentSummaryResponse = ContentSummaryResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: ContentSummaryResult;
  };
};

/**
 * Optional parameters.
 */
export interface FileSystemGetFileStatusOptionalParams
  extends coreHttp.OperationOptions {
  /**
   * An optional switch to return friendly names in place of owner and group. tooId=false returns friendly names instead of the AAD Object ID. Default value is true, returning AAD object IDs.
   */
  tooId?: boolean;
}

/**
 * Contains response data for the getFileStatus operation.
 */
export type FileSystemGetFileStatusResponse = FileStatusResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: FileStatusResult;
  };
};

/**
 * Optional parameters.
 */
export interface FileSystemOpenOptionalParams
  extends coreHttp.OperationOptions {
  /**
   * The number of bytes that the server will attempt to retrieve. It will retrieve <= length bytes.
   */
  length?: number;
  /**
   * The byte offset to start reading data from.
   */
  offset?: number;
  /**
   * Optional unique GUID per file indicating all the reads with the same fileSessionId are from the same client and same session. This will give a performance benefit.
   */
  fileSessionId?: string;
}

/**
 * Optional parameters.
 */
export interface FileSystemAppendOptionalParams
  extends coreHttp.OperationOptions {
  /**
   * Optionally indicates what to do after completion of the concurrent append. DATA indicates that more data will be sent immediately by the client, the file handle should remain open/locked, and file metadata (including file length, last modified time) should NOT get updated. METADATA indicates that more data will be sent immediately by the client, the file handle should remain open/locked, and file metadata should get updated. CLOSE indicates that the client is done sending data, the file handle should be closed/unlocked, and file metadata should get updated.
   */
  syncFlag?: SyncFlag;
  /**
   * The optional offset in the stream to begin the append operation. Default is to append at the end of the stream.
   */
  offset?: number;
  /**
   * Optional unique GUID per file to ensure single writer semantics, meaning that only clients that append to the file with the same leaseId will be allowed to do so.
   */
  leaseId?: string;
  /**
   * Optional unique GUID per file indicating all the appends with the same fileSessionId are from the same client and same session. This will give a performance benefit when syncFlag is DATA or METADATA.
   */
  fileSessionId?: string;
}

/**
 * Optional parameters.
 */
export interface FileSystemCreateOptionalParams
  extends coreHttp.OperationOptions {
  /**
   * Optional unique GUID per file to ensure single writer semantics, meaning that only clients that append to the file with the same leaseId will be allowed to do so.
   */
  leaseId?: string;
  /**
   * The indication of if the file should be overwritten.
   */
  overwrite?: boolean;
  /**
   * Optionally indicates what to do after completion of the create. DATA indicates that more data will be sent immediately by the client, the file handle should remain open/locked, and file metadata (including file length, last modified time) should NOT get updated. METADATA indicates that more data will be sent immediately by the client, the file handle should remain open/locked, and file metadata should get updated. CLOSE indicates that the client is done sending data, the file handle should be closed/unlocked, and file metadata should get updated.
   */
  syncFlag?: SyncFlag;
  /**
   * The octal representation of the unnamed user, mask and other permissions that should be set for the file when created. If not specified, it inherits these from the container.
   */
  permission?: number;
}

/**
 * Optional parameters.
 */
export interface FileSystemGetAclStatusOptionalParams
  extends coreHttp.OperationOptions {
  /**
   * An optional switch to return friendly names in place of object ID for ACL entries. tooId=false returns friendly names instead of the AAD Object ID. Default value is true, returning AAD object IDs.
   */
  tooId?: boolean;
}

/**
 * Contains response data for the getAclStatus operation.
 */
export type FileSystemGetAclStatusResponse = AclStatusResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: AclStatusResult;
  };
};

/**
 * Optional parameters.
 */
export interface FileSystemDeleteOptionalParams
  extends coreHttp.OperationOptions {
  /**
   * The optional switch indicating if the delete should be recursive
   */
  recursive?: boolean;
}

/**
 * Contains response data for the delete operation.
 */
export type FileSystemDeleteResponse = FileOperationResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: FileOperationResult;
  };
};

/**
 * Contains response data for the rename operation.
 */
export type FileSystemRenameResponse = FileOperationResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: FileOperationResult;
  };
};

/**
 * Optional parameters.
 */
export interface FileSystemSetOwnerOptionalParams
  extends coreHttp.OperationOptions {
  /**
   * The AAD Object ID of the user owner of the file or directory. If empty, the property will remain unchanged.
   */
  owner?: string;
  /**
   * The AAD Object ID of the group owner of the file or directory. If empty, the property will remain unchanged.
   */
  group?: string;
}

/**
 * Optional parameters.
 */
export interface FileSystemSetPermissionOptionalParams
  extends coreHttp.OperationOptions {
  /**
   * A string representation of the permission (i.e 'rwx'). If empty, this property remains unchanged.
   */
  permission?: string;
}

/**
 * Optional parameters.
 */
export interface DataLakeStoreFileSystemManagementClientOptionalParams
  extends coreHttp.ServiceClientOptions {
  /**
   * Gets the URI used as the base for all cloud service requests.
   */
  adlsFileSystemDnsSuffix?: string;
  /**
   * Api Version
   */
  apiVersion?: string;
  /**
   * Overrides client endpoint.
   */
  endpoint?: string;
}
