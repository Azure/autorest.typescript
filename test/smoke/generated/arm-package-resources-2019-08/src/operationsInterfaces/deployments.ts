/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { PagedAsyncIterableIterator } from "@azure/core-paging";
import { PollerLike, PollOperationState } from "@azure/core-lro";
import {
  DeploymentExtended,
  DeploymentsCreateOrUpdateAtScopeResponse,
  DeploymentsGetAtScopeResponse,
  DeploymentsValidateAtScopeResponse,
  DeploymentsExportTemplateAtScopeResponse,
  DeploymentsCreateOrUpdateAtTenantScopeResponse,
  DeploymentsGetAtTenantScopeResponse,
  DeploymentsValidateAtTenantScopeResponse,
  DeploymentsExportTemplateAtTenantScopeResponse,
  DeploymentsCreateOrUpdateAtManagementGroupScopeResponse,
  DeploymentsGetAtManagementGroupScopeResponse,
  DeploymentsValidateAtManagementGroupScopeResponse,
  DeploymentsExportTemplateAtManagementGroupScopeResponse,
  DeploymentsCreateOrUpdateAtSubscriptionScopeResponse,
  DeploymentsGetAtSubscriptionScopeResponse,
  DeploymentsValidateAtSubscriptionScopeResponse,
  DeploymentsWhatIfAtSubscriptionScopeResponse,
  DeploymentsExportTemplateAtSubscriptionScopeResponse,
  DeploymentsCreateOrUpdateResponse,
  DeploymentsGetResponse,
  DeploymentsValidateResponse,
  DeploymentsWhatIfResponse,
  DeploymentsExportTemplateResponse,
  DeploymentsCalculateTemplateHashResponse
} from "../models";

/// <reference lib="esnext.asynciterable" />
/** Interface representing a Deployments. */
export interface Deployments {
  /**
   * Get all the deployments at the given scope.
   *
   */
  listAtScope(): PagedAsyncIterableIterator<DeploymentExtended>;
  /**
   * Get all the deployments at the tenant scope.
   *
   */
  listAtTenantScope(): PagedAsyncIterableIterator<DeploymentExtended>;
  /**
   * Get all the deployments for a management group.
   *
   */
  listAtManagementGroupScope(): PagedAsyncIterableIterator<DeploymentExtended>;
  /**
   * Get all the deployments for a subscription.
   *
   */
  listAtSubscriptionScope(): PagedAsyncIterableIterator<DeploymentExtended>;
  /**
   * Get all the deployments for a resource group.
   *
   */
  listByResourceGroup(): PagedAsyncIterableIterator<DeploymentExtended>;
  /**
   * A template deployment that is currently running cannot be deleted. Deleting a template deployment
   * removes the associated deployment operations. This is an asynchronous operation that returns a
   * status of 202 until the template deployment is successfully deleted. The Location response header
   * contains the URI that is used to obtain the status of the process. While the process is running, a
   * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
   * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
   * URI in the Location header returns an error-level status code.
   *
   */
  beginDeleteAtScope(): Promise<PollerLike<PollOperationState<void>, void>>;
  /**
   * A template deployment that is currently running cannot be deleted. Deleting a template deployment
   * removes the associated deployment operations. This is an asynchronous operation that returns a
   * status of 202 until the template deployment is successfully deleted. The Location response header
   * contains the URI that is used to obtain the status of the process. While the process is running, a
   * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
   * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
   * URI in the Location header returns an error-level status code.
   *
   */
  beginDeleteAtScopeAndWait(): Promise<void>;
  /**
   * Checks whether the deployment exists.
   *
   */
  checkExistenceAtScope(): Promise<void>;
  /**
   * You can provide the template and parameters directly in the request or link to JSON files.
   *
   */
  beginCreateOrUpdateAtScope(): Promise<
    PollerLike<
      PollOperationState<DeploymentsCreateOrUpdateAtScopeResponse>,
      DeploymentsCreateOrUpdateAtScopeResponse
    >
  >;
  /**
   * You can provide the template and parameters directly in the request or link to JSON files.
   *
   */
  beginCreateOrUpdateAtScopeAndWait(): Promise<
    DeploymentsCreateOrUpdateAtScopeResponse
  >;
  /**
   * Gets a deployment.
   *
   */
  getAtScope(): Promise<DeploymentsGetAtScopeResponse>;
  /**
   * You can cancel a deployment only if the provisioningState is Accepted or Running. After the
   * deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment
   * stops the currently running template deployment and leaves the resources partially deployed.
   *
   */
  cancelAtScope(): Promise<void>;
  /**
   * Validates whether the specified template is syntactically correct and will be accepted by Azure
   * Resource Manager..
   *
   */
  validateAtScope(): Promise<DeploymentsValidateAtScopeResponse>;
  /**
   * Exports the template used for specified deployment.
   *
   */
  exportTemplateAtScope(): Promise<DeploymentsExportTemplateAtScopeResponse>;
  /**
   * A template deployment that is currently running cannot be deleted. Deleting a template deployment
   * removes the associated deployment operations. This is an asynchronous operation that returns a
   * status of 202 until the template deployment is successfully deleted. The Location response header
   * contains the URI that is used to obtain the status of the process. While the process is running, a
   * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
   * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
   * URI in the Location header returns an error-level status code.
   *
   */
  beginDeleteAtTenantScope(): Promise<
    PollerLike<PollOperationState<void>, void>
  >;
  /**
   * A template deployment that is currently running cannot be deleted. Deleting a template deployment
   * removes the associated deployment operations. This is an asynchronous operation that returns a
   * status of 202 until the template deployment is successfully deleted. The Location response header
   * contains the URI that is used to obtain the status of the process. While the process is running, a
   * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
   * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
   * URI in the Location header returns an error-level status code.
   *
   */
  beginDeleteAtTenantScopeAndWait(): Promise<void>;
  /**
   * Checks whether the deployment exists.
   *
   */
  checkExistenceAtTenantScope(): Promise<void>;
  /**
   * You can provide the template and parameters directly in the request or link to JSON files.
   *
   */
  beginCreateOrUpdateAtTenantScope(): Promise<
    PollerLike<
      PollOperationState<DeploymentsCreateOrUpdateAtTenantScopeResponse>,
      DeploymentsCreateOrUpdateAtTenantScopeResponse
    >
  >;
  /**
   * You can provide the template and parameters directly in the request or link to JSON files.
   *
   */
  beginCreateOrUpdateAtTenantScopeAndWait(): Promise<
    DeploymentsCreateOrUpdateAtTenantScopeResponse
  >;
  /**
   * Gets a deployment.
   *
   */
  getAtTenantScope(): Promise<DeploymentsGetAtTenantScopeResponse>;
  /**
   * You can cancel a deployment only if the provisioningState is Accepted or Running. After the
   * deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment
   * stops the currently running template deployment and leaves the resources partially deployed.
   *
   */
  cancelAtTenantScope(): Promise<void>;
  /**
   * Validates whether the specified template is syntactically correct and will be accepted by Azure
   * Resource Manager..
   *
   */
  validateAtTenantScope(): Promise<DeploymentsValidateAtTenantScopeResponse>;
  /**
   * Exports the template used for specified deployment.
   *
   */
  exportTemplateAtTenantScope(): Promise<
    DeploymentsExportTemplateAtTenantScopeResponse
  >;
  /**
   * A template deployment that is currently running cannot be deleted. Deleting a template deployment
   * removes the associated deployment operations. This is an asynchronous operation that returns a
   * status of 202 until the template deployment is successfully deleted. The Location response header
   * contains the URI that is used to obtain the status of the process. While the process is running, a
   * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
   * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
   * URI in the Location header returns an error-level status code.
   *
   */
  beginDeleteAtManagementGroupScope(): Promise<
    PollerLike<PollOperationState<void>, void>
  >;
  /**
   * A template deployment that is currently running cannot be deleted. Deleting a template deployment
   * removes the associated deployment operations. This is an asynchronous operation that returns a
   * status of 202 until the template deployment is successfully deleted. The Location response header
   * contains the URI that is used to obtain the status of the process. While the process is running, a
   * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
   * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
   * URI in the Location header returns an error-level status code.
   *
   */
  beginDeleteAtManagementGroupScopeAndWait(): Promise<void>;
  /**
   * Checks whether the deployment exists.
   *
   */
  checkExistenceAtManagementGroupScope(): Promise<void>;
  /**
   * You can provide the template and parameters directly in the request or link to JSON files.
   *
   */
  beginCreateOrUpdateAtManagementGroupScope(): Promise<
    PollerLike<
      PollOperationState<
        DeploymentsCreateOrUpdateAtManagementGroupScopeResponse
      >,
      DeploymentsCreateOrUpdateAtManagementGroupScopeResponse
    >
  >;
  /**
   * You can provide the template and parameters directly in the request or link to JSON files.
   *
   */
  beginCreateOrUpdateAtManagementGroupScopeAndWait(): Promise<
    DeploymentsCreateOrUpdateAtManagementGroupScopeResponse
  >;
  /**
   * Gets a deployment.
   *
   */
  getAtManagementGroupScope(): Promise<
    DeploymentsGetAtManagementGroupScopeResponse
  >;
  /**
   * You can cancel a deployment only if the provisioningState is Accepted or Running. After the
   * deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment
   * stops the currently running template deployment and leaves the resources partially deployed.
   *
   */
  cancelAtManagementGroupScope(): Promise<void>;
  /**
   * Validates whether the specified template is syntactically correct and will be accepted by Azure
   * Resource Manager..
   *
   */
  validateAtManagementGroupScope(): Promise<
    DeploymentsValidateAtManagementGroupScopeResponse
  >;
  /**
   * Exports the template used for specified deployment.
   *
   */
  exportTemplateAtManagementGroupScope(): Promise<
    DeploymentsExportTemplateAtManagementGroupScopeResponse
  >;
  /**
   * A template deployment that is currently running cannot be deleted. Deleting a template deployment
   * removes the associated deployment operations. This is an asynchronous operation that returns a
   * status of 202 until the template deployment is successfully deleted. The Location response header
   * contains the URI that is used to obtain the status of the process. While the process is running, a
   * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
   * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
   * URI in the Location header returns an error-level status code.
   *
   */
  beginDeleteAtSubscriptionScope(): Promise<
    PollerLike<PollOperationState<void>, void>
  >;
  /**
   * A template deployment that is currently running cannot be deleted. Deleting a template deployment
   * removes the associated deployment operations. This is an asynchronous operation that returns a
   * status of 202 until the template deployment is successfully deleted. The Location response header
   * contains the URI that is used to obtain the status of the process. While the process is running, a
   * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
   * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
   * URI in the Location header returns an error-level status code.
   *
   */
  beginDeleteAtSubscriptionScopeAndWait(): Promise<void>;
  /**
   * Checks whether the deployment exists.
   *
   */
  checkExistenceAtSubscriptionScope(): Promise<void>;
  /**
   * You can provide the template and parameters directly in the request or link to JSON files.
   *
   */
  beginCreateOrUpdateAtSubscriptionScope(): Promise<
    PollerLike<
      PollOperationState<DeploymentsCreateOrUpdateAtSubscriptionScopeResponse>,
      DeploymentsCreateOrUpdateAtSubscriptionScopeResponse
    >
  >;
  /**
   * You can provide the template and parameters directly in the request or link to JSON files.
   *
   */
  beginCreateOrUpdateAtSubscriptionScopeAndWait(): Promise<
    DeploymentsCreateOrUpdateAtSubscriptionScopeResponse
  >;
  /**
   * Gets a deployment.
   *
   */
  getAtSubscriptionScope(): Promise<DeploymentsGetAtSubscriptionScopeResponse>;
  /**
   * You can cancel a deployment only if the provisioningState is Accepted or Running. After the
   * deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment
   * stops the currently running template deployment and leaves the resources partially deployed.
   *
   */
  cancelAtSubscriptionScope(): Promise<void>;
  /**
   * Validates whether the specified template is syntactically correct and will be accepted by Azure
   * Resource Manager..
   *
   */
  validateAtSubscriptionScope(): Promise<
    DeploymentsValidateAtSubscriptionScopeResponse
  >;
  /**
   * Returns changes that will be made by the deployment if executed at the scope of the subscription.
   *
   */
  beginWhatIfAtSubscriptionScope(): Promise<
    PollerLike<
      PollOperationState<DeploymentsWhatIfAtSubscriptionScopeResponse>,
      DeploymentsWhatIfAtSubscriptionScopeResponse
    >
  >;
  /**
   * Returns changes that will be made by the deployment if executed at the scope of the subscription.
   *
   */
  beginWhatIfAtSubscriptionScopeAndWait(): Promise<
    DeploymentsWhatIfAtSubscriptionScopeResponse
  >;
  /**
   * Exports the template used for specified deployment.
   *
   */
  exportTemplateAtSubscriptionScope(): Promise<
    DeploymentsExportTemplateAtSubscriptionScopeResponse
  >;
  /**
   * A template deployment that is currently running cannot be deleted. Deleting a template deployment
   * removes the associated deployment operations. Deleting a template deployment does not affect the
   * state of the resource group. This is an asynchronous operation that returns a status of 202 until
   * the template deployment is successfully deleted. The Location response header contains the URI that
   * is used to obtain the status of the process. While the process is running, a call to the URI in the
   * Location header returns a status of 202. When the process finishes, the URI in the Location header
   * returns a status of 204 on success. If the asynchronous request failed, the URI in the Location
   * header returns an error-level status code.
   *
   */
  beginDelete(): Promise<PollerLike<PollOperationState<void>, void>>;
  /**
   * A template deployment that is currently running cannot be deleted. Deleting a template deployment
   * removes the associated deployment operations. Deleting a template deployment does not affect the
   * state of the resource group. This is an asynchronous operation that returns a status of 202 until
   * the template deployment is successfully deleted. The Location response header contains the URI that
   * is used to obtain the status of the process. While the process is running, a call to the URI in the
   * Location header returns a status of 202. When the process finishes, the URI in the Location header
   * returns a status of 204 on success. If the asynchronous request failed, the URI in the Location
   * header returns an error-level status code.
   *
   */
  beginDeleteAndWait(): Promise<void>;
  /**
   * Checks whether the deployment exists.
   *
   */
  checkExistence(): Promise<void>;
  /**
   * You can provide the template and parameters directly in the request or link to JSON files.
   *
   */
  beginCreateOrUpdate(): Promise<
    PollerLike<
      PollOperationState<DeploymentsCreateOrUpdateResponse>,
      DeploymentsCreateOrUpdateResponse
    >
  >;
  /**
   * You can provide the template and parameters directly in the request or link to JSON files.
   *
   */
  beginCreateOrUpdateAndWait(): Promise<DeploymentsCreateOrUpdateResponse>;
  /**
   * Gets a deployment.
   *
   */
  get(): Promise<DeploymentsGetResponse>;
  /**
   * You can cancel a deployment only if the provisioningState is Accepted or Running. After the
   * deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment
   * stops the currently running template deployment and leaves the resource group partially deployed.
   *
   */
  cancel(): Promise<void>;
  /**
   * Validates whether the specified template is syntactically correct and will be accepted by Azure
   * Resource Manager..
   *
   */
  validate(): Promise<DeploymentsValidateResponse>;
  /**
   * Returns changes that will be made by the deployment if executed at the scope of the resource group.
   *
   */
  beginWhatIf(): Promise<
    PollerLike<
      PollOperationState<DeploymentsWhatIfResponse>,
      DeploymentsWhatIfResponse
    >
  >;
  /**
   * Returns changes that will be made by the deployment if executed at the scope of the resource group.
   *
   */
  beginWhatIfAndWait(): Promise<DeploymentsWhatIfResponse>;
  /**
   * Exports the template used for specified deployment.
   *
   */
  exportTemplate(): Promise<DeploymentsExportTemplateResponse>;
  /**
   * Calculate the hash of the given template.
   *
   */
  calculateTemplateHash(): Promise<DeploymentsCalculateTemplateHashResponse>;
}
