/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
import { __asyncDelegator, __asyncGenerator, __asyncValues, __await, __awaiter } from "tslib";
import "@azure/core-paging";
import * as coreClient from "@azure/core-client";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
import { LroEngine } from "@azure/core-lro";
import { LroImpl } from "../lroImpl";
/// <reference lib="esnext.asynciterable" />
/** Class representing a Deployments. */
export class DeploymentsImpl {
    /**
     * Initialize a new instance of the class Deployments class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get all the deployments at the given scope.
     * @param scope The scope of a deployment.
     * @param options The options parameters.
     */
    listAtScope(scope, options) {
        const iter = this.listAtScopePagingAll(scope, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAtScopePagingPage(scope, options);
            }
        };
    }
    listAtScopePagingPage(scope, options) {
        return __asyncGenerator(this, arguments, function* listAtScopePagingPage_1() {
            let result = yield __await(this._listAtScope(scope, options));
            yield yield __await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield __await(this._listAtScopeNext(scope, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield __await(result.value || []);
            }
        });
    }
    listAtScopePagingAll(scope, options) {
        return __asyncGenerator(this, arguments, function* listAtScopePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = __asyncValues(this.listAtScopePagingPage(scope, options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get all the deployments at the tenant scope.
     * @param options The options parameters.
     */
    listAtTenantScope(options) {
        const iter = this.listAtTenantScopePagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAtTenantScopePagingPage(options);
            }
        };
    }
    listAtTenantScopePagingPage(options) {
        return __asyncGenerator(this, arguments, function* listAtTenantScopePagingPage_1() {
            let result = yield __await(this._listAtTenantScope(options));
            yield yield __await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield __await(this._listAtTenantScopeNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield __await(result.value || []);
            }
        });
    }
    listAtTenantScopePagingAll(options) {
        return __asyncGenerator(this, arguments, function* listAtTenantScopePagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = __asyncValues(this.listAtTenantScopePagingPage(options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Get all the deployments for a management group.
     * @param groupId The management group ID.
     * @param options The options parameters.
     */
    listAtManagementGroupScope(groupId, options) {
        const iter = this.listAtManagementGroupScopePagingAll(groupId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAtManagementGroupScopePagingPage(groupId, options);
            }
        };
    }
    listAtManagementGroupScopePagingPage(groupId, options) {
        return __asyncGenerator(this, arguments, function* listAtManagementGroupScopePagingPage_1() {
            let result = yield __await(this._listAtManagementGroupScope(groupId, options));
            yield yield __await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield __await(this._listAtManagementGroupScopeNext(groupId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield __await(result.value || []);
            }
        });
    }
    listAtManagementGroupScopePagingAll(groupId, options) {
        return __asyncGenerator(this, arguments, function* listAtManagementGroupScopePagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = __asyncValues(this.listAtManagementGroupScopePagingPage(groupId, options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Get all the deployments for a subscription.
     * @param options The options parameters.
     */
    listAtSubscriptionScope(options) {
        const iter = this.listAtSubscriptionScopePagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAtSubscriptionScopePagingPage(options);
            }
        };
    }
    listAtSubscriptionScopePagingPage(options) {
        return __asyncGenerator(this, arguments, function* listAtSubscriptionScopePagingPage_1() {
            let result = yield __await(this._listAtSubscriptionScope(options));
            yield yield __await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield __await(this._listAtSubscriptionScopeNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield __await(result.value || []);
            }
        });
    }
    listAtSubscriptionScopePagingAll(options) {
        return __asyncGenerator(this, arguments, function* listAtSubscriptionScopePagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = __asyncValues(this.listAtSubscriptionScopePagingPage(options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Get all the deployments for a resource group.
     * @param resourceGroupName The name of the resource group with the deployments to get. The name is
     *                          case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return __asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield __await(this._listByResourceGroup(resourceGroupName, options));
            yield yield __await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield __await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield __await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return __asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_5, _a;
            try {
                for (var _b = __asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment
     * removes the associated deployment operations. This is an asynchronous operation that returns a
     * status of 202 until the template deployment is successfully deleted. The Location response header
     * contains the URI that is used to obtain the status of the process. While the process is running, a
     * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
     * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
     * URI in the Location header returns an error-level status code.
     * @param scope The scope of a deployment.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    beginDeleteAtScope(scope, deploymentName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { scope, deploymentName, options }, deleteAtScopeOperationSpec);
            return new LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment
     * removes the associated deployment operations. This is an asynchronous operation that returns a
     * status of 202 until the template deployment is successfully deleted. The Location response header
     * contains the URI that is used to obtain the status of the process. While the process is running, a
     * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
     * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
     * URI in the Location header returns an error-level status code.
     * @param scope The scope of a deployment.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    beginDeleteAtScopeAndWait(scope, deploymentName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteAtScope(scope, deploymentName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Checks whether the deployment exists.
     * @param scope The scope of a deployment.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    checkExistenceAtScope(scope, deploymentName, options) {
        return this.client.sendOperationRequest({ scope, deploymentName, options }, checkExistenceAtScopeOperationSpec);
    }
    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * @param scope The scope of a deployment.
     * @param deploymentName The name of the deployment.
     * @param parameters Additional parameters supplied to the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAtScope(scope, deploymentName, parameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { scope, deploymentName, parameters, options }, createOrUpdateAtScopeOperationSpec);
            return new LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * @param scope The scope of a deployment.
     * @param deploymentName The name of the deployment.
     * @param parameters Additional parameters supplied to the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAtScopeAndWait(scope, deploymentName, parameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdateAtScope(scope, deploymentName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a deployment.
     * @param scope The scope of a deployment.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    getAtScope(scope, deploymentName, options) {
        return this.client.sendOperationRequest({ scope, deploymentName, options }, getAtScopeOperationSpec);
    }
    /**
     * You can cancel a deployment only if the provisioningState is Accepted or Running. After the
     * deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment
     * stops the currently running template deployment and leaves the resources partially deployed.
     * @param scope The scope of a deployment.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    cancelAtScope(scope, deploymentName, options) {
        return this.client.sendOperationRequest({ scope, deploymentName, options }, cancelAtScopeOperationSpec);
    }
    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure
     * Resource Manager..
     * @param scope The scope of a deployment.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    validateAtScope(scope, deploymentName, parameters, options) {
        return this.client.sendOperationRequest({ scope, deploymentName, parameters, options }, validateAtScopeOperationSpec);
    }
    /**
     * Exports the template used for specified deployment.
     * @param scope The scope of a deployment.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    exportTemplateAtScope(scope, deploymentName, options) {
        return this.client.sendOperationRequest({ scope, deploymentName, options }, exportTemplateAtScopeOperationSpec);
    }
    /**
     * Get all the deployments at the given scope.
     * @param scope The scope of a deployment.
     * @param options The options parameters.
     */
    _listAtScope(scope, options) {
        return this.client.sendOperationRequest({ scope, options }, listAtScopeOperationSpec);
    }
    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment
     * removes the associated deployment operations. This is an asynchronous operation that returns a
     * status of 202 until the template deployment is successfully deleted. The Location response header
     * contains the URI that is used to obtain the status of the process. While the process is running, a
     * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
     * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
     * URI in the Location header returns an error-level status code.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    beginDeleteAtTenantScope(deploymentName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { deploymentName, options }, deleteAtTenantScopeOperationSpec);
            return new LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment
     * removes the associated deployment operations. This is an asynchronous operation that returns a
     * status of 202 until the template deployment is successfully deleted. The Location response header
     * contains the URI that is used to obtain the status of the process. While the process is running, a
     * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
     * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
     * URI in the Location header returns an error-level status code.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    beginDeleteAtTenantScopeAndWait(deploymentName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteAtTenantScope(deploymentName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Checks whether the deployment exists.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    checkExistenceAtTenantScope(deploymentName, options) {
        return this.client.sendOperationRequest({ deploymentName, options }, checkExistenceAtTenantScopeOperationSpec);
    }
    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * @param deploymentName The name of the deployment.
     * @param parameters Additional parameters supplied to the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAtTenantScope(deploymentName, parameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { deploymentName, parameters, options }, createOrUpdateAtTenantScopeOperationSpec);
            return new LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * @param deploymentName The name of the deployment.
     * @param parameters Additional parameters supplied to the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAtTenantScopeAndWait(deploymentName, parameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdateAtTenantScope(deploymentName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a deployment.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    getAtTenantScope(deploymentName, options) {
        return this.client.sendOperationRequest({ deploymentName, options }, getAtTenantScopeOperationSpec);
    }
    /**
     * You can cancel a deployment only if the provisioningState is Accepted or Running. After the
     * deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment
     * stops the currently running template deployment and leaves the resources partially deployed.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    cancelAtTenantScope(deploymentName, options) {
        return this.client.sendOperationRequest({ deploymentName, options }, cancelAtTenantScopeOperationSpec);
    }
    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure
     * Resource Manager..
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    validateAtTenantScope(deploymentName, parameters, options) {
        return this.client.sendOperationRequest({ deploymentName, parameters, options }, validateAtTenantScopeOperationSpec);
    }
    /**
     * Exports the template used for specified deployment.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    exportTemplateAtTenantScope(deploymentName, options) {
        return this.client.sendOperationRequest({ deploymentName, options }, exportTemplateAtTenantScopeOperationSpec);
    }
    /**
     * Get all the deployments at the tenant scope.
     * @param options The options parameters.
     */
    _listAtTenantScope(options) {
        return this.client.sendOperationRequest({ options }, listAtTenantScopeOperationSpec);
    }
    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment
     * removes the associated deployment operations. This is an asynchronous operation that returns a
     * status of 202 until the template deployment is successfully deleted. The Location response header
     * contains the URI that is used to obtain the status of the process. While the process is running, a
     * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
     * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
     * URI in the Location header returns an error-level status code.
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    beginDeleteAtManagementGroupScope(groupId, deploymentName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { groupId, deploymentName, options }, deleteAtManagementGroupScopeOperationSpec);
            return new LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment
     * removes the associated deployment operations. This is an asynchronous operation that returns a
     * status of 202 until the template deployment is successfully deleted. The Location response header
     * contains the URI that is used to obtain the status of the process. While the process is running, a
     * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
     * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
     * URI in the Location header returns an error-level status code.
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    beginDeleteAtManagementGroupScopeAndWait(groupId, deploymentName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteAtManagementGroupScope(groupId, deploymentName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Checks whether the deployment exists.
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    checkExistenceAtManagementGroupScope(groupId, deploymentName, options) {
        return this.client.sendOperationRequest({ groupId, deploymentName, options }, checkExistenceAtManagementGroupScopeOperationSpec);
    }
    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param parameters Additional parameters supplied to the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAtManagementGroupScope(groupId, deploymentName, parameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { groupId, deploymentName, parameters, options }, createOrUpdateAtManagementGroupScopeOperationSpec);
            return new LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param parameters Additional parameters supplied to the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAtManagementGroupScopeAndWait(groupId, deploymentName, parameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdateAtManagementGroupScope(groupId, deploymentName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a deployment.
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    getAtManagementGroupScope(groupId, deploymentName, options) {
        return this.client.sendOperationRequest({ groupId, deploymentName, options }, getAtManagementGroupScopeOperationSpec);
    }
    /**
     * You can cancel a deployment only if the provisioningState is Accepted or Running. After the
     * deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment
     * stops the currently running template deployment and leaves the resources partially deployed.
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    cancelAtManagementGroupScope(groupId, deploymentName, options) {
        return this.client.sendOperationRequest({ groupId, deploymentName, options }, cancelAtManagementGroupScopeOperationSpec);
    }
    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure
     * Resource Manager..
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    validateAtManagementGroupScope(groupId, deploymentName, parameters, options) {
        return this.client.sendOperationRequest({ groupId, deploymentName, parameters, options }, validateAtManagementGroupScopeOperationSpec);
    }
    /**
     * Exports the template used for specified deployment.
     * @param groupId The management group ID.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    exportTemplateAtManagementGroupScope(groupId, deploymentName, options) {
        return this.client.sendOperationRequest({ groupId, deploymentName, options }, exportTemplateAtManagementGroupScopeOperationSpec);
    }
    /**
     * Get all the deployments for a management group.
     * @param groupId The management group ID.
     * @param options The options parameters.
     */
    _listAtManagementGroupScope(groupId, options) {
        return this.client.sendOperationRequest({ groupId, options }, listAtManagementGroupScopeOperationSpec);
    }
    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment
     * removes the associated deployment operations. This is an asynchronous operation that returns a
     * status of 202 until the template deployment is successfully deleted. The Location response header
     * contains the URI that is used to obtain the status of the process. While the process is running, a
     * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
     * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
     * URI in the Location header returns an error-level status code.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    beginDeleteAtSubscriptionScope(deploymentName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { deploymentName, options }, deleteAtSubscriptionScopeOperationSpec);
            return new LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment
     * removes the associated deployment operations. This is an asynchronous operation that returns a
     * status of 202 until the template deployment is successfully deleted. The Location response header
     * contains the URI that is used to obtain the status of the process. While the process is running, a
     * call to the URI in the Location header returns a status of 202. When the process finishes, the URI
     * in the Location header returns a status of 204 on success. If the asynchronous request failed, the
     * URI in the Location header returns an error-level status code.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    beginDeleteAtSubscriptionScopeAndWait(deploymentName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteAtSubscriptionScope(deploymentName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Checks whether the deployment exists.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    checkExistenceAtSubscriptionScope(deploymentName, options) {
        return this.client.sendOperationRequest({ deploymentName, options }, checkExistenceAtSubscriptionScopeOperationSpec);
    }
    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * @param deploymentName The name of the deployment.
     * @param parameters Additional parameters supplied to the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAtSubscriptionScope(deploymentName, parameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { deploymentName, parameters, options }, createOrUpdateAtSubscriptionScopeOperationSpec);
            return new LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * @param deploymentName The name of the deployment.
     * @param parameters Additional parameters supplied to the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAtSubscriptionScopeAndWait(deploymentName, parameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdateAtSubscriptionScope(deploymentName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a deployment.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    getAtSubscriptionScope(deploymentName, options) {
        return this.client.sendOperationRequest({ deploymentName, options }, getAtSubscriptionScopeOperationSpec);
    }
    /**
     * You can cancel a deployment only if the provisioningState is Accepted or Running. After the
     * deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment
     * stops the currently running template deployment and leaves the resources partially deployed.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    cancelAtSubscriptionScope(deploymentName, options) {
        return this.client.sendOperationRequest({ deploymentName, options }, cancelAtSubscriptionScopeOperationSpec);
    }
    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure
     * Resource Manager..
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    validateAtSubscriptionScope(deploymentName, parameters, options) {
        return this.client.sendOperationRequest({ deploymentName, parameters, options }, validateAtSubscriptionScopeOperationSpec);
    }
    /**
     * Returns changes that will be made by the deployment if executed at the scope of the subscription.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to What If.
     * @param options The options parameters.
     */
    beginWhatIfAtSubscriptionScope(deploymentName, parameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { deploymentName, parameters, options }, whatIfAtSubscriptionScopeOperationSpec);
            return new LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Returns changes that will be made by the deployment if executed at the scope of the subscription.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to What If.
     * @param options The options parameters.
     */
    beginWhatIfAtSubscriptionScopeAndWait(deploymentName, parameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginWhatIfAtSubscriptionScope(deploymentName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Exports the template used for specified deployment.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    exportTemplateAtSubscriptionScope(deploymentName, options) {
        return this.client.sendOperationRequest({ deploymentName, options }, exportTemplateAtSubscriptionScopeOperationSpec);
    }
    /**
     * Get all the deployments for a subscription.
     * @param options The options parameters.
     */
    _listAtSubscriptionScope(options) {
        return this.client.sendOperationRequest({ options }, listAtSubscriptionScopeOperationSpec);
    }
    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment
     * removes the associated deployment operations. Deleting a template deployment does not affect the
     * state of the resource group. This is an asynchronous operation that returns a status of 202 until
     * the template deployment is successfully deleted. The Location response header contains the URI that
     * is used to obtain the status of the process. While the process is running, a call to the URI in the
     * Location header returns a status of 202. When the process finishes, the URI in the Location header
     * returns a status of 204 on success. If the asynchronous request failed, the URI in the Location
     * header returns an error-level status code.
     * @param resourceGroupName The name of the resource group with the deployment to delete. The name is
     *                          case insensitive.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, deploymentName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, deploymentName, options }, deleteOperationSpec);
            return new LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * A template deployment that is currently running cannot be deleted. Deleting a template deployment
     * removes the associated deployment operations. Deleting a template deployment does not affect the
     * state of the resource group. This is an asynchronous operation that returns a status of 202 until
     * the template deployment is successfully deleted. The Location response header contains the URI that
     * is used to obtain the status of the process. While the process is running, a call to the URI in the
     * Location header returns a status of 202. When the process finishes, the URI in the Location header
     * returns a status of 204 on success. If the asynchronous request failed, the URI in the Location
     * header returns an error-level status code.
     * @param resourceGroupName The name of the resource group with the deployment to delete. The name is
     *                          case insensitive.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, deploymentName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, deploymentName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Checks whether the deployment exists.
     * @param resourceGroupName The name of the resource group with the deployment to check. The name is
     *                          case insensitive.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    checkExistence(resourceGroupName, deploymentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, deploymentName, options }, checkExistenceOperationSpec);
    }
    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * @param resourceGroupName The name of the resource group to deploy the resources to. The name is case
     *                          insensitive. The resource group must already exist.
     * @param deploymentName The name of the deployment.
     * @param parameters Additional parameters supplied to the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, deploymentName, parameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, deploymentName, parameters, options }, createOrUpdateOperationSpec);
            return new LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * You can provide the template and parameters directly in the request or link to JSON files.
     * @param resourceGroupName The name of the resource group to deploy the resources to. The name is case
     *                          insensitive. The resource group must already exist.
     * @param deploymentName The name of the deployment.
     * @param parameters Additional parameters supplied to the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, deploymentName, parameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, deploymentName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a deployment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    get(resourceGroupName, deploymentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, deploymentName, options }, getOperationSpec);
    }
    /**
     * You can cancel a deployment only if the provisioningState is Accepted or Running. After the
     * deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment
     * stops the currently running template deployment and leaves the resource group partially deployed.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    cancel(resourceGroupName, deploymentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, deploymentName, options }, cancelOperationSpec);
    }
    /**
     * Validates whether the specified template is syntactically correct and will be accepted by Azure
     * Resource Manager..
     * @param resourceGroupName The name of the resource group the template will be deployed to. The name
     *                          is case insensitive.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    validate(resourceGroupName, deploymentName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, deploymentName, parameters, options }, validateOperationSpec);
    }
    /**
     * Returns changes that will be made by the deployment if executed at the scope of the resource group.
     * @param resourceGroupName The name of the resource group the template will be deployed to. The name
     *                          is case insensitive.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    beginWhatIf(resourceGroupName, deploymentName, parameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, deploymentName, parameters, options }, whatIfOperationSpec);
            return new LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
        });
    }
    /**
     * Returns changes that will be made by the deployment if executed at the scope of the resource group.
     * @param resourceGroupName The name of the resource group the template will be deployed to. The name
     *                          is case insensitive.
     * @param deploymentName The name of the deployment.
     * @param parameters Parameters to validate.
     * @param options The options parameters.
     */
    beginWhatIfAndWait(resourceGroupName, deploymentName, parameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginWhatIf(resourceGroupName, deploymentName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Exports the template used for specified deployment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param deploymentName The name of the deployment.
     * @param options The options parameters.
     */
    exportTemplate(resourceGroupName, deploymentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, deploymentName, options }, exportTemplateOperationSpec);
    }
    /**
     * Get all the deployments for a resource group.
     * @param resourceGroupName The name of the resource group with the deployments to get. The name is
     *                          case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Calculate the hash of the given template.
     * @param template The template provided to calculate hash.
     * @param options The options parameters.
     */
    calculateTemplateHash(template, options) {
        return this.client.sendOperationRequest({ template, options }, calculateTemplateHashOperationSpec);
    }
    /**
     * ListAtScopeNext
     * @param scope The scope of a deployment.
     * @param nextLink The nextLink from the previous successful call to the ListAtScope method.
     * @param options The options parameters.
     */
    _listAtScopeNext(scope, nextLink, options) {
        return this.client.sendOperationRequest({ scope, nextLink, options }, listAtScopeNextOperationSpec);
    }
    /**
     * ListAtTenantScopeNext
     * @param nextLink The nextLink from the previous successful call to the ListAtTenantScope method.
     * @param options The options parameters.
     */
    _listAtTenantScopeNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAtTenantScopeNextOperationSpec);
    }
    /**
     * ListAtManagementGroupScopeNext
     * @param groupId The management group ID.
     * @param nextLink The nextLink from the previous successful call to the ListAtManagementGroupScope
     *                 method.
     * @param options The options parameters.
     */
    _listAtManagementGroupScopeNext(groupId, nextLink, options) {
        return this.client.sendOperationRequest({ groupId, nextLink, options }, listAtManagementGroupScopeNextOperationSpec);
    }
    /**
     * ListAtSubscriptionScopeNext
     * @param nextLink The nextLink from the previous successful call to the ListAtSubscriptionScope
     *                 method.
     * @param options The options parameters.
     */
    _listAtSubscriptionScopeNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAtSubscriptionScopeNextOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group with the deployments to get. The name is
     *                          case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteAtScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.scope,
        Parameters.deploymentName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const checkExistenceAtScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "HEAD",
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.scope,
        Parameters.deploymentName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const createOrUpdateAtScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentExtended
        },
        201: {
            bodyMapper: Mappers.DeploymentExtended
        },
        202: {
            bodyMapper: Mappers.DeploymentExtended
        },
        204: {
            bodyMapper: Mappers.DeploymentExtended
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    requestBody: Parameters.parameters,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.scope,
        Parameters.deploymentName
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const getAtScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentExtended
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.scope,
        Parameters.deploymentName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const cancelAtScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.scope,
        Parameters.deploymentName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const validateAtScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/validate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentValidateResult
        },
        400: {
            bodyMapper: Mappers.DeploymentValidateResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    requestBody: Parameters.parameters,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.scope,
        Parameters.deploymentName
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const exportTemplateAtScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentExportResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.scope,
        Parameters.deploymentName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listAtScopeOperationSpec = {
    path: "/{scope}/providers/Microsoft.Resources/deployments/",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentListResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion, Parameters.filter, Parameters.top],
    urlParameters: [Parameters.$host, Parameters.scope],
    headerParameters: [Parameters.accept],
    serializer
};
const deleteAtTenantScopeOperationSpec = {
    path: "/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.$host, Parameters.deploymentName],
    headerParameters: [Parameters.accept],
    serializer
};
const checkExistenceAtTenantScopeOperationSpec = {
    path: "/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "HEAD",
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.$host, Parameters.deploymentName],
    headerParameters: [Parameters.accept],
    serializer
};
const createOrUpdateAtTenantScopeOperationSpec = {
    path: "/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentExtended
        },
        201: {
            bodyMapper: Mappers.DeploymentExtended
        },
        202: {
            bodyMapper: Mappers.DeploymentExtended
        },
        204: {
            bodyMapper: Mappers.DeploymentExtended
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    requestBody: Parameters.parameters1,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.$host, Parameters.deploymentName],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const getAtTenantScopeOperationSpec = {
    path: "/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentExtended
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.$host, Parameters.deploymentName],
    headerParameters: [Parameters.accept],
    serializer
};
const cancelAtTenantScopeOperationSpec = {
    path: "/providers/Microsoft.Resources/deployments/{deploymentName}/cancel",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.$host, Parameters.deploymentName],
    headerParameters: [Parameters.accept],
    serializer
};
const validateAtTenantScopeOperationSpec = {
    path: "/providers/Microsoft.Resources/deployments/{deploymentName}/validate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentValidateResult
        },
        400: {
            bodyMapper: Mappers.DeploymentValidateResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    requestBody: Parameters.parameters1,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.$host, Parameters.deploymentName],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const exportTemplateAtTenantScopeOperationSpec = {
    path: "/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentExportResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.$host, Parameters.deploymentName],
    headerParameters: [Parameters.accept],
    serializer
};
const listAtTenantScopeOperationSpec = {
    path: "/providers/Microsoft.Resources/deployments/",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentListResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion, Parameters.filter, Parameters.top],
    urlParameters: [Parameters.$host],
    headerParameters: [Parameters.accept],
    serializer
};
const deleteAtManagementGroupScopeOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.groupId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const checkExistenceAtManagementGroupScopeOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "HEAD",
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.groupId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const createOrUpdateAtManagementGroupScopeOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentExtended
        },
        201: {
            bodyMapper: Mappers.DeploymentExtended
        },
        202: {
            bodyMapper: Mappers.DeploymentExtended
        },
        204: {
            bodyMapper: Mappers.DeploymentExtended
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    requestBody: Parameters.parameters1,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.groupId
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const getAtManagementGroupScopeOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentExtended
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.groupId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const cancelAtManagementGroupScopeOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.groupId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const validateAtManagementGroupScopeOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/validate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentValidateResult
        },
        400: {
            bodyMapper: Mappers.DeploymentValidateResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    requestBody: Parameters.parameters1,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.groupId
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const exportTemplateAtManagementGroupScopeOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentExportResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.groupId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listAtManagementGroupScopeOperationSpec = {
    path: "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentListResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion, Parameters.filter, Parameters.top],
    urlParameters: [Parameters.$host, Parameters.groupId],
    headerParameters: [Parameters.accept],
    serializer
};
const deleteAtSubscriptionScopeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const checkExistenceAtSubscriptionScopeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "HEAD",
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const createOrUpdateAtSubscriptionScopeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentExtended
        },
        201: {
            bodyMapper: Mappers.DeploymentExtended
        },
        202: {
            bodyMapper: Mappers.DeploymentExtended
        },
        204: {
            bodyMapper: Mappers.DeploymentExtended
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    requestBody: Parameters.parameters,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const getAtSubscriptionScopeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentExtended
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const cancelAtSubscriptionScopeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const validateAtSubscriptionScopeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/validate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentValidateResult
        },
        400: {
            bodyMapper: Mappers.DeploymentValidateResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    requestBody: Parameters.parameters,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const whatIfAtSubscriptionScopeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.WhatIfOperationResult
        },
        201: {
            bodyMapper: Mappers.WhatIfOperationResult
        },
        202: {
            bodyMapper: Mappers.WhatIfOperationResult
        },
        204: {
            bodyMapper: Mappers.WhatIfOperationResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    requestBody: Parameters.parameters2,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const exportTemplateAtSubscriptionScopeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentExportResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listAtSubscriptionScopeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentListResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion, Parameters.filter, Parameters.top],
    urlParameters: [Parameters.$host, Parameters.subscriptionId],
    headerParameters: [Parameters.accept],
    serializer
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId,
        Parameters.resourceGroupName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const checkExistenceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "HEAD",
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId,
        Parameters.resourceGroupName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentExtended
        },
        201: {
            bodyMapper: Mappers.DeploymentExtended
        },
        202: {
            bodyMapper: Mappers.DeploymentExtended
        },
        204: {
            bodyMapper: Mappers.DeploymentExtended
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    requestBody: Parameters.parameters,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId,
        Parameters.resourceGroupName
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentExtended
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId,
        Parameters.resourceGroupName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const cancelOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId,
        Parameters.resourceGroupName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const validateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/validate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentValidateResult
        },
        400: {
            bodyMapper: Mappers.DeploymentValidateResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    requestBody: Parameters.parameters,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId,
        Parameters.resourceGroupName
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const whatIfOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.WhatIfOperationResult
        },
        201: {
            bodyMapper: Mappers.WhatIfOperationResult
        },
        202: {
            bodyMapper: Mappers.WhatIfOperationResult
        },
        204: {
            bodyMapper: Mappers.WhatIfOperationResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    requestBody: Parameters.parameters2,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId,
        Parameters.resourceGroupName
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const exportTemplateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentExportResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.deploymentName,
        Parameters.subscriptionId,
        Parameters.resourceGroupName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentListResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion, Parameters.filter, Parameters.top],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const calculateTemplateHashOperationSpec = {
    path: "/providers/Microsoft.Resources/calculateTemplateHash",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.TemplateHashResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    requestBody: Parameters.template,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.$host],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const listAtScopeNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentListResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion, Parameters.filter, Parameters.top],
    urlParameters: [Parameters.$host, Parameters.nextLink, Parameters.scope],
    headerParameters: [Parameters.accept],
    serializer
};
const listAtTenantScopeNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentListResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion, Parameters.filter, Parameters.top],
    urlParameters: [Parameters.$host, Parameters.nextLink],
    headerParameters: [Parameters.accept],
    serializer
};
const listAtManagementGroupScopeNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentListResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion, Parameters.filter, Parameters.top],
    urlParameters: [Parameters.$host, Parameters.nextLink, Parameters.groupId],
    headerParameters: [Parameters.accept],
    serializer
};
const listAtSubscriptionScopeNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentListResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion, Parameters.filter, Parameters.top],
    urlParameters: [
        Parameters.$host,
        Parameters.nextLink,
        Parameters.subscriptionId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DeploymentListResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion, Parameters.filter, Parameters.top],
    urlParameters: [
        Parameters.$host,
        Parameters.nextLink,
        Parameters.subscriptionId,
        Parameters.resourceGroupName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
//# sourceMappingURL=deployments.js.map