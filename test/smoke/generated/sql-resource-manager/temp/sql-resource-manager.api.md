## API Report File for "sql-resource-manager"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as coreHttp from '@azure/core-http';
import { HttpMethods } from '@azure/core-http';
import { HttpOperationResponse } from '@azure/core-http';
import { OperationArguments } from '@azure/core-http';
import { OperationSpec } from '@azure/core-http';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { PollerLike } from '@azure/core-lro';
import { PollOperationState } from '@azure/core-lro';
import { RestResponse } from '@azure/core-http';

// @public
export interface AdministratorListResult {
    readonly nextLink?: string;
    readonly value?: ServerAzureADAdministrator[];
}

// @public
export type AdministratorName = string;

// @public
export type AdministratorType = string;

// @public
export type AuthenticationType = "SQL" | "ADPassword";

// @public
export type AutomaticTuningDisabledReason = "Default" | "Disabled" | "AutoConfigured" | "InheritedFromServer" | "QueryStoreOff" | "QueryStoreReadOnly" | "NotSupported";

// @public
export type AutomaticTuningMode = "Inherit" | "Custom" | "Auto" | "Unspecified";

// @public
export type AutomaticTuningOptionModeActual = "Off" | "On";

// @public
export type AutomaticTuningOptionModeDesired = "Off" | "On" | "Default";

// @public
export interface AutomaticTuningOptions {
    readonly actualState?: AutomaticTuningOptionModeActual;
    desiredState?: AutomaticTuningOptionModeDesired;
    readonly reasonCode?: number;
    readonly reasonDesc?: AutomaticTuningDisabledReason;
}

// @public
export type AutomaticTuningServerMode = "Custom" | "Auto" | "Unspecified";

// @public
export interface AutomaticTuningServerOptions {
    readonly actualState?: AutomaticTuningOptionModeActual;
    desiredState?: AutomaticTuningOptionModeDesired;
    readonly reasonCode?: number;
    readonly reasonDesc?: AutomaticTuningServerReason;
}

// @public
export type AutomaticTuningServerReason = "Default" | "Disabled" | "AutoConfigured";

// @public
export interface AutoPauseDelayTimeRange {
    readonly default?: number;
    readonly doNotPauseValue?: number;
    readonly maxValue?: number;
    readonly minValue?: number;
    readonly stepSize?: number;
    readonly unit?: PauseDelayTimeUnit;
}

// @public
export interface BackupLongTermRetentionPolicies {
    createOrUpdate(resourceGroupName: string, serverName: string, databaseName: string, policyName: LongTermRetentionPolicyName, parameters: BackupLongTermRetentionPolicy, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<BackupLongTermRetentionPoliciesCreateOrUpdateResponse>, BackupLongTermRetentionPoliciesCreateOrUpdateResponse>>;
    get(resourceGroupName: string, serverName: string, databaseName: string, policyName: LongTermRetentionPolicyName, options?: coreHttp.OperationOptions): Promise<BackupLongTermRetentionPoliciesGetResponse>;
    listByDatabase(resourceGroupName: string, serverName: string, databaseName: string, options?: coreHttp.OperationOptions): Promise<BackupLongTermRetentionPoliciesListByDatabaseResponse>;
}

// @public
export type BackupLongTermRetentionPoliciesCreateOrUpdateResponse = BackupLongTermRetentionPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: BackupLongTermRetentionPolicy;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type BackupLongTermRetentionPoliciesGetResponse = BackupLongTermRetentionPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: BackupLongTermRetentionPolicy;
    };
};

// @public
export type BackupLongTermRetentionPoliciesListByDatabaseResponse = BackupLongTermRetentionPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: BackupLongTermRetentionPolicy;
    };
};

// @public
export type BackupLongTermRetentionPolicy = ProxyResource & {
    weeklyRetention?: string;
    monthlyRetention?: string;
    yearlyRetention?: string;
    weekOfYear?: number;
};

// @public
export interface BackupShortTermRetentionPolicies {
    createOrUpdate(resourceGroupName: string, serverName: string, databaseName: string, policyName: ShortTermRetentionPolicyName, parameters: BackupShortTermRetentionPolicy, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<BackupShortTermRetentionPoliciesCreateOrUpdateResponse>, BackupShortTermRetentionPoliciesCreateOrUpdateResponse>>;
    get(resourceGroupName: string, serverName: string, databaseName: string, policyName: ShortTermRetentionPolicyName, options?: coreHttp.OperationOptions): Promise<BackupShortTermRetentionPoliciesGetResponse>;
    listByDatabase(resourceGroupName: string, serverName: string, databaseName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<BackupShortTermRetentionPolicy>;
    update(resourceGroupName: string, serverName: string, databaseName: string, policyName: ShortTermRetentionPolicyName, parameters: BackupShortTermRetentionPolicy, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<BackupShortTermRetentionPoliciesUpdateResponse>, BackupShortTermRetentionPoliciesUpdateResponse>>;
}

// @public
export type BackupShortTermRetentionPoliciesCreateOrUpdateResponse = BackupShortTermRetentionPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: BackupShortTermRetentionPolicy;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type BackupShortTermRetentionPoliciesGetResponse = BackupShortTermRetentionPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: BackupShortTermRetentionPolicy;
    };
};

// @public
export type BackupShortTermRetentionPoliciesListByDatabaseNextResponse = BackupShortTermRetentionPolicyListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: BackupShortTermRetentionPolicyListResult;
    };
};

// @public
export type BackupShortTermRetentionPoliciesListByDatabaseResponse = BackupShortTermRetentionPolicyListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: BackupShortTermRetentionPolicyListResult;
    };
};

// @public
export type BackupShortTermRetentionPoliciesUpdateResponse = BackupShortTermRetentionPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: BackupShortTermRetentionPolicy;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type BackupShortTermRetentionPolicy = ProxyResource & {
    retentionDays?: number;
};

// @public
export interface BackupShortTermRetentionPolicyListResult {
    readonly nextLink?: string;
    readonly value?: BackupShortTermRetentionPolicy[];
}

// @public
export type BlobAuditingPolicyState = "Enabled" | "Disabled";

// @public
export interface Capabilities {
    listByLocation(locationName: string, options?: CapabilitiesListByLocationOptionalParams): Promise<CapabilitiesListByLocationResponse>;
}

// @public
export interface CapabilitiesListByLocationOptionalParams extends coreHttp.OperationOptions {
    include?: CapabilityGroup;
}

// @public
export type CapabilitiesListByLocationResponse = LocationCapabilities & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: LocationCapabilities;
    };
};

// @public
export type CapabilityGroup = string;

// @public
export type CapabilityStatus = "Visible" | "Available" | "Default" | "Disabled";

// @public
export type CatalogCollationType = string;

// @public
export type CheckNameAvailabilityReason = "Invalid" | "AlreadyExists";

// @public
export interface CheckNameAvailabilityRequest {
    // (undocumented)
    name: string;
    // (undocumented)
    type: "Microsoft.Sql/servers";
}

// @public
export interface CheckNameAvailabilityResponse {
    readonly available?: boolean;
    readonly message?: string;
    readonly name?: string;
    readonly reason?: CheckNameAvailabilityReason;
}

// @public
export interface CompleteDatabaseRestoreDefinition {
    lastBackupName: string;
}

// @public
export type ConnectionPolicyName = string;

// @public
export interface CreateDatabaseRestorePointDefinition {
    restorePointLabel: string;
}

// @public
export type CreateMode = string;

// @public
export type Database = TrackedResource & {
    sku?: Sku;
    readonly kind?: string;
    readonly managedBy?: string;
    createMode?: CreateMode;
    collation?: string;
    maxSizeBytes?: number;
    sampleName?: SampleName;
    elasticPoolId?: string;
    sourceDatabaseId?: string;
    readonly status?: DatabaseStatus;
    readonly databaseId?: string;
    readonly creationDate?: Date;
    readonly currentServiceObjectiveName?: string;
    readonly requestedServiceObjectiveName?: string;
    readonly defaultSecondaryLocation?: string;
    readonly failoverGroupId?: string;
    restorePointInTime?: Date;
    sourceDatabaseDeletionDate?: Date;
    recoveryServicesRecoveryPointId?: string;
    longTermRetentionBackupResourceId?: string;
    recoverableDatabaseId?: string;
    restorableDroppedDatabaseId?: string;
    catalogCollation?: CatalogCollationType;
    zoneRedundant?: boolean;
    licenseType?: DatabaseLicenseType;
    readonly maxLogSizeBytes?: number;
    readonly earliestRestoreDate?: Date;
    readScale?: DatabaseReadScale;
    readReplicaCount?: number;
    readonly currentSku?: Sku;
    autoPauseDelay?: number;
    minCapacity?: number;
    readonly pausedDate?: Date;
    readonly resumedDate?: Date;
};

// @public
export interface DatabaseAutomaticTuning {
    get(resourceGroupName: string, serverName: string, databaseName: string, options?: coreHttp.OperationOptions): Promise<DatabaseAutomaticTuningGetResponse>;
    update(resourceGroupName: string, serverName: string, databaseName: string, parameters: DatabaseAutomaticTuningDef, options?: coreHttp.OperationOptions): Promise<DatabaseAutomaticTuningUpdateResponse>;
}

// @public
export type DatabaseAutomaticTuningDef = ProxyResource & {
    desiredState?: AutomaticTuningMode;
    readonly actualState?: AutomaticTuningMode;
    options?: {
        [propertyName: string]: AutomaticTuningOptions;
    };
};

// @public
export type DatabaseAutomaticTuningGetResponse = DatabaseAutomaticTuningDef & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DatabaseAutomaticTuningDef;
    };
};

// @public
export type DatabaseAutomaticTuningUpdateResponse = DatabaseAutomaticTuningDef & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DatabaseAutomaticTuningDef;
    };
};

// @public
export interface DatabaseBlobAuditingPolicies {
    createOrUpdate(resourceGroupName: string, serverName: string, databaseName: string, parameters: DatabaseBlobAuditingPolicy, options?: coreHttp.OperationOptions): Promise<DatabaseBlobAuditingPoliciesCreateOrUpdateResponse>;
    get(resourceGroupName: string, serverName: string, databaseName: string, options?: coreHttp.OperationOptions): Promise<DatabaseBlobAuditingPoliciesGetResponse>;
    listByDatabase(resourceGroupName: string, serverName: string, databaseName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<DatabaseBlobAuditingPolicy>;
}

// @public
export type DatabaseBlobAuditingPoliciesCreateOrUpdateResponse = DatabaseBlobAuditingPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DatabaseBlobAuditingPolicy;
    };
};

// @public
export type DatabaseBlobAuditingPoliciesGetResponse = DatabaseBlobAuditingPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DatabaseBlobAuditingPolicy;
    };
};

// @public
export type DatabaseBlobAuditingPoliciesListByDatabaseNextResponse = DatabaseBlobAuditingPolicyListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DatabaseBlobAuditingPolicyListResult;
    };
};

// @public
export type DatabaseBlobAuditingPoliciesListByDatabaseResponse = DatabaseBlobAuditingPolicyListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DatabaseBlobAuditingPolicyListResult;
    };
};

// @public
export type DatabaseBlobAuditingPolicy = ProxyResource & {
    readonly kind?: string;
    state?: BlobAuditingPolicyState;
    storageEndpoint?: string;
    storageAccountAccessKey?: string;
    retentionDays?: number;
    auditActionsAndGroups?: string[];
    storageAccountSubscriptionId?: string;
    isStorageSecondaryKeyInUse?: boolean;
    isAzureMonitorTargetEnabled?: boolean;
    queueDelayMs?: number;
};

// @public
export interface DatabaseBlobAuditingPolicyListResult {
    readonly nextLink?: string;
    readonly value?: DatabaseBlobAuditingPolicy[];
}

// @public
export type DatabaseEdition = string;

// @public
export type DatabaseLicenseType = string;

// @public
export interface DatabaseListResult {
    readonly nextLink?: string;
    readonly value?: Database[];
}

// @public
export type DatabaseOperation = ProxyResource & {
    readonly databaseName?: string;
    readonly operation?: string;
    readonly operationFriendlyName?: string;
    readonly percentComplete?: number;
    readonly serverName?: string;
    readonly startTime?: Date;
    readonly state?: ManagementOperationState;
    readonly errorCode?: number;
    readonly errorDescription?: string;
    readonly errorSeverity?: number;
    readonly isUserError?: boolean;
    readonly estimatedCompletionTime?: Date;
    readonly description?: string;
    readonly isCancellable?: boolean;
};

// @public
export interface DatabaseOperationListResult {
    readonly nextLink?: string;
    readonly value?: DatabaseOperation[];
}

// @public
export interface DatabaseOperations {
    cancel(resourceGroupName: string, serverName: string, databaseName: string, operationId: string, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    listByDatabase(resourceGroupName: string, serverName: string, databaseName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<DatabaseOperation>;
}

// @public
export type DatabaseOperationsListByDatabaseNextResponse = DatabaseOperationListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DatabaseOperationListResult;
    };
};

// @public
export type DatabaseOperationsListByDatabaseResponse = DatabaseOperationListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DatabaseOperationListResult;
    };
};

// @public
export type DatabaseReadScale = string;

// @public
export interface Databases {
    createImportOperation(resourceGroupName: string, serverName: string, databaseName: string, extensionName: ExtensionName, parameters: ImportExtensionRequest, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<DatabasesCreateImportOperationResponse>, DatabasesCreateImportOperationResponse>>;
    createOrUpdate(resourceGroupName: string, serverName: string, databaseName: string, parameters: Database, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<DatabasesCreateOrUpdateResponse>, DatabasesCreateOrUpdateResponse>>;
    delete(resourceGroupName: string, serverName: string, databaseName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    export(resourceGroupName: string, serverName: string, databaseName: string, parameters: ExportRequest, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<DatabasesExportResponse>, DatabasesExportResponse>>;
    failover(resourceGroupName: string, serverName: string, databaseName: string, options?: DatabasesFailoverOptionalParams): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    get(resourceGroupName: string, serverName: string, databaseName: string, options?: coreHttp.OperationOptions): Promise<DatabasesGetResponse>;
    import(resourceGroupName: string, serverName: string, parameters: ImportRequest, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<DatabasesImportResponse>, DatabasesImportResponse>>;
    listByElasticPool(resourceGroupName: string, serverName: string, elasticPoolName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<Database>;
    listByServer(resourceGroupName: string, serverName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<Database>;
    listMetricDefinitions(resourceGroupName: string, serverName: string, databaseName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<MetricDefinition>;
    listMetrics(resourceGroupName: string, serverName: string, databaseName: string, filter: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<Metric>;
    pause(resourceGroupName: string, serverName: string, databaseName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<DatabasesPauseResponse>, DatabasesPauseResponse>>;
    rename(resourceGroupName: string, serverName: string, databaseName: string, parameters: ResourceMoveDefinition, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    resume(resourceGroupName: string, serverName: string, databaseName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<DatabasesResumeResponse>, DatabasesResumeResponse>>;
    update(resourceGroupName: string, serverName: string, databaseName: string, parameters: DatabaseUpdate, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<DatabasesUpdateResponse>, DatabasesUpdateResponse>>;
    upgradeDataWarehouse(resourceGroupName: string, serverName: string, databaseName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
}

// @public
export type DatabasesCreateImportOperationResponse = ImportExportResponse & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ImportExportResponse;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type DatabasesCreateOrUpdateResponse = Database & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: Database;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type DatabaseSecurityAlertPolicy = ProxyResource & {
    location?: string;
    readonly kind?: string;
    state?: SecurityAlertPolicyState;
    disabledAlerts?: string;
    emailAddresses?: string;
    emailAccountAdmins?: SecurityAlertPolicyEmailAccountAdmins;
    storageEndpoint?: string;
    storageAccountAccessKey?: string;
    retentionDays?: number;
    useServerDefault?: SecurityAlertPolicyUseServerDefault;
};

// @public
export type DatabasesExportResponse = ImportExportResponse & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ImportExportResponse;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export interface DatabasesFailoverOptionalParams extends coreHttp.OperationOptions {
    replicaType?: ReplicaType;
}

// @public
export type DatabasesGetResponse = Database & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: Database;
    };
};

// @public
export type DatabasesImportResponse = ImportExportResponse & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ImportExportResponse;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type DatabasesListByElasticPoolNextResponse = DatabaseListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DatabaseListResult;
    };
};

// @public
export type DatabasesListByElasticPoolResponse = DatabaseListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DatabaseListResult;
    };
};

// @public
export type DatabasesListByServerNextResponse = DatabaseListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DatabaseListResult;
    };
};

// @public
export type DatabasesListByServerResponse = DatabaseListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DatabaseListResult;
    };
};

// @public
export type DatabasesListMetricDefinitionsResponse = MetricDefinitionListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: MetricDefinitionListResult;
    };
};

// @public
export type DatabasesListMetricsResponse = MetricListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: MetricListResult;
    };
};

// @public
export type DatabasesPauseResponse = Database & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: Database;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type DatabasesResumeResponse = Database & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: Database;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type DatabaseState = string;

// @public
export type DatabaseStatus = string;

// @public
export type DatabasesUpdateResponse = Database & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: Database;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export interface DatabaseThreatDetectionPolicies {
    createOrUpdate(resourceGroupName: string, serverName: string, databaseName: string, securityAlertPolicyName: SecurityAlertPolicyName, parameters: DatabaseSecurityAlertPolicy, options?: coreHttp.OperationOptions): Promise<DatabaseThreatDetectionPoliciesCreateOrUpdateResponse>;
    get(resourceGroupName: string, serverName: string, databaseName: string, securityAlertPolicyName: SecurityAlertPolicyName, options?: coreHttp.OperationOptions): Promise<DatabaseThreatDetectionPoliciesGetResponse>;
}

// @public
export type DatabaseThreatDetectionPoliciesCreateOrUpdateResponse = DatabaseSecurityAlertPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DatabaseSecurityAlertPolicy;
    };
};

// @public
export type DatabaseThreatDetectionPoliciesGetResponse = DatabaseSecurityAlertPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DatabaseSecurityAlertPolicy;
    };
};

// @public
export interface DatabaseUpdate {
    autoPauseDelay?: number;
    catalogCollation?: CatalogCollationType;
    collation?: string;
    createMode?: CreateMode;
    readonly creationDate?: Date;
    readonly currentServiceObjectiveName?: string;
    readonly currentSku?: Sku;
    readonly databaseId?: string;
    readonly defaultSecondaryLocation?: string;
    readonly earliestRestoreDate?: Date;
    elasticPoolId?: string;
    readonly failoverGroupId?: string;
    licenseType?: DatabaseLicenseType;
    longTermRetentionBackupResourceId?: string;
    readonly maxLogSizeBytes?: number;
    maxSizeBytes?: number;
    minCapacity?: number;
    readonly pausedDate?: Date;
    readReplicaCount?: number;
    readScale?: DatabaseReadScale;
    recoverableDatabaseId?: string;
    recoveryServicesRecoveryPointId?: string;
    readonly requestedServiceObjectiveName?: string;
    restorableDroppedDatabaseId?: string;
    restorePointInTime?: Date;
    readonly resumedDate?: Date;
    sampleName?: SampleName;
    sku?: Sku;
    sourceDatabaseDeletionDate?: Date;
    sourceDatabaseId?: string;
    readonly status?: DatabaseStatus;
    tags?: {
        [propertyName: string]: string;
    };
    zoneRedundant?: boolean;
}

// @public
export interface DatabaseUsage {
    readonly currentValue?: number;
    readonly displayName?: string;
    readonly limit?: number;
    readonly name?: string;
    readonly nextResetTime?: Date;
    readonly resourceName?: string;
    readonly unit?: string;
}

// @public
export interface DatabaseUsageListResult {
    value: DatabaseUsage[];
}

// @public
export interface DatabaseUsages {
    listByDatabase(resourceGroupName: string, serverName: string, databaseName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<DatabaseUsage>;
}

// @public
export type DatabaseUsagesListByDatabaseResponse = DatabaseUsageListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DatabaseUsageListResult;
    };
};

// @public
export type DatabaseVulnerabilityAssessment = ProxyResource & {
    storageContainerPath?: string;
    storageContainerSasKey?: string;
    storageAccountAccessKey?: string;
    recurringScans?: VulnerabilityAssessmentRecurringScansProperties;
};

// @public
export interface DatabaseVulnerabilityAssessmentListResult {
    readonly nextLink?: string;
    readonly value?: DatabaseVulnerabilityAssessment[];
}

// @public
export type DatabaseVulnerabilityAssessmentRuleBaseline = ProxyResource & {
    baselineResults?: DatabaseVulnerabilityAssessmentRuleBaselineItem[];
};

// @public
export interface DatabaseVulnerabilityAssessmentRuleBaselineItem {
    result: string[];
}

// @public
export interface DatabaseVulnerabilityAssessmentRuleBaselines {
    createOrUpdate(resourceGroupName: string, serverName: string, databaseName: string, vulnerabilityAssessmentName: VulnerabilityAssessmentName, ruleId: string, baselineName: VulnerabilityAssessmentPolicyBaselineName, parameters: DatabaseVulnerabilityAssessmentRuleBaseline, options?: coreHttp.OperationOptions): Promise<DatabaseVulnerabilityAssessmentRuleBaselinesCreateOrUpdateResponse>;
    delete(resourceGroupName: string, serverName: string, databaseName: string, vulnerabilityAssessmentName: VulnerabilityAssessmentName, ruleId: string, baselineName: VulnerabilityAssessmentPolicyBaselineName, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    get(resourceGroupName: string, serverName: string, databaseName: string, vulnerabilityAssessmentName: VulnerabilityAssessmentName, ruleId: string, baselineName: VulnerabilityAssessmentPolicyBaselineName, options?: coreHttp.OperationOptions): Promise<DatabaseVulnerabilityAssessmentRuleBaselinesGetResponse>;
}

// @public
export type DatabaseVulnerabilityAssessmentRuleBaselinesCreateOrUpdateResponse = DatabaseVulnerabilityAssessmentRuleBaseline & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DatabaseVulnerabilityAssessmentRuleBaseline;
    };
};

// @public
export type DatabaseVulnerabilityAssessmentRuleBaselinesGetResponse = DatabaseVulnerabilityAssessmentRuleBaseline & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DatabaseVulnerabilityAssessmentRuleBaseline;
    };
};

// @public
export interface DatabaseVulnerabilityAssessments {
    createOrUpdate(resourceGroupName: string, serverName: string, databaseName: string, vulnerabilityAssessmentName: VulnerabilityAssessmentName, parameters: DatabaseVulnerabilityAssessment, options?: coreHttp.OperationOptions): Promise<DatabaseVulnerabilityAssessmentsCreateOrUpdateResponse>;
    delete(resourceGroupName: string, serverName: string, databaseName: string, vulnerabilityAssessmentName: VulnerabilityAssessmentName, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    get(resourceGroupName: string, serverName: string, databaseName: string, vulnerabilityAssessmentName: VulnerabilityAssessmentName, options?: coreHttp.OperationOptions): Promise<DatabaseVulnerabilityAssessmentsGetResponse>;
    listByDatabase(resourceGroupName: string, serverName: string, databaseName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<DatabaseVulnerabilityAssessment>;
}

// @public
export interface DatabaseVulnerabilityAssessmentScans {
    export(resourceGroupName: string, serverName: string, databaseName: string, vulnerabilityAssessmentName: VulnerabilityAssessmentName, scanId: string, options?: coreHttp.OperationOptions): Promise<DatabaseVulnerabilityAssessmentScansExportResponse>;
    get(resourceGroupName: string, serverName: string, databaseName: string, vulnerabilityAssessmentName: VulnerabilityAssessmentName, scanId: string, options?: coreHttp.OperationOptions): Promise<DatabaseVulnerabilityAssessmentScansGetResponse>;
    initiateScan(resourceGroupName: string, serverName: string, databaseName: string, vulnerabilityAssessmentName: VulnerabilityAssessmentName, scanId: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    listByDatabase(resourceGroupName: string, serverName: string, databaseName: string, vulnerabilityAssessmentName: VulnerabilityAssessmentName, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<VulnerabilityAssessmentScanRecord>;
}

// @public
export type DatabaseVulnerabilityAssessmentScansExport = ProxyResource & {
    readonly exportedReportLocation?: string;
};

// @public
export type DatabaseVulnerabilityAssessmentScansExportResponse = DatabaseVulnerabilityAssessmentScansExport & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DatabaseVulnerabilityAssessmentScansExport;
    };
};

// @public
export type DatabaseVulnerabilityAssessmentScansGetResponse = VulnerabilityAssessmentScanRecord & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: VulnerabilityAssessmentScanRecord;
    };
};

// @public
export type DatabaseVulnerabilityAssessmentScansListByDatabaseNextResponse = VulnerabilityAssessmentScanRecordListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: VulnerabilityAssessmentScanRecordListResult;
    };
};

// @public
export type DatabaseVulnerabilityAssessmentScansListByDatabaseResponse = VulnerabilityAssessmentScanRecordListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: VulnerabilityAssessmentScanRecordListResult;
    };
};

// @public
export type DatabaseVulnerabilityAssessmentsCreateOrUpdateResponse = DatabaseVulnerabilityAssessment & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DatabaseVulnerabilityAssessment;
    };
};

// @public
export type DatabaseVulnerabilityAssessmentsGetResponse = DatabaseVulnerabilityAssessment & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DatabaseVulnerabilityAssessment;
    };
};

// @public
export type DatabaseVulnerabilityAssessmentsListByDatabaseNextResponse = DatabaseVulnerabilityAssessmentListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DatabaseVulnerabilityAssessmentListResult;
    };
};

// @public
export type DatabaseVulnerabilityAssessmentsListByDatabaseResponse = DatabaseVulnerabilityAssessmentListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DatabaseVulnerabilityAssessmentListResult;
    };
};

// @public
export type DataMaskingFunction = "Default" | "CCN" | "Email" | "Number" | "SSN" | "Text";

// @public
export interface DataMaskingPolicies {
    createOrUpdate(resourceGroupName: string, serverName: string, databaseName: string, parameters: DataMaskingPolicy, options?: coreHttp.OperationOptions): Promise<DataMaskingPoliciesCreateOrUpdateResponse>;
    get(resourceGroupName: string, serverName: string, databaseName: string, options?: coreHttp.OperationOptions): Promise<DataMaskingPoliciesGetResponse>;
}

// @public
export type DataMaskingPoliciesCreateOrUpdateResponse = DataMaskingPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DataMaskingPolicy;
    };
};

// @public
export type DataMaskingPoliciesGetResponse = DataMaskingPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DataMaskingPolicy;
    };
};

// @public
export type DataMaskingPolicy = ProxyResource & {
    readonly location?: string;
    readonly kind?: string;
    dataMaskingState?: DataMaskingState;
    exemptPrincipals?: string;
    readonly applicationPrincipals?: string;
    readonly maskingLevel?: string;
};

// @public
export type DataMaskingRule = ProxyResource & {
    readonly location?: string;
    readonly kind?: string;
    readonly idPropertiesId?: string;
    aliasName?: string;
    ruleState?: DataMaskingRuleState;
    schemaName?: string;
    tableName?: string;
    columnName?: string;
    maskingFunction?: DataMaskingFunction;
    numberFrom?: string;
    numberTo?: string;
    prefixSize?: string;
    suffixSize?: string;
    replacementString?: string;
};

// @public
export interface DataMaskingRuleListResult {
    value?: DataMaskingRule[];
}

// @public
export interface DataMaskingRules {
    createOrUpdate(resourceGroupName: string, serverName: string, databaseName: string, dataMaskingRuleName: string, parameters: DataMaskingRule, options?: coreHttp.OperationOptions): Promise<DataMaskingRulesCreateOrUpdateResponse>;
    listByDatabase(resourceGroupName: string, serverName: string, databaseName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<DataMaskingRule>;
}

// @public
export type DataMaskingRulesCreateOrUpdateResponse = DataMaskingRule & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DataMaskingRule;
    };
};

// @public
export type DataMaskingRulesListByDatabaseResponse = DataMaskingRuleListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DataMaskingRuleListResult;
    };
};

// @public
export type DataMaskingRuleState = "Disabled" | "Enabled";

// @public
export type DataMaskingState = "Disabled" | "Enabled";

// @public
export interface EditionCapability {
    readonly name?: string;
    readonly readScale?: ReadScaleCapability;
    reason?: string;
    readonly status?: CapabilityStatus;
    readonly supportedServiceLevelObjectives?: ServiceObjectiveCapability[];
    readonly supportedStorageCapabilities?: StorageCapability[];
    readonly zoneRedundant?: boolean;
}

// @public
export type ElasticPool = TrackedResource & {
    sku?: Sku;
    readonly kind?: string;
    readonly state?: ElasticPoolState;
    readonly creationDate?: Date;
    maxSizeBytes?: number;
    perDatabaseSettings?: ElasticPoolPerDatabaseSettings;
    zoneRedundant?: boolean;
    licenseType?: ElasticPoolLicenseType;
};

// @public
export interface ElasticPoolActivities {
    listByElasticPool(resourceGroupName: string, serverName: string, elasticPoolName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<ElasticPoolActivity>;
}

// @public
export type ElasticPoolActivitiesListByElasticPoolResponse = ElasticPoolActivityListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ElasticPoolActivityListResult;
    };
};

// @public
export type ElasticPoolActivity = ProxyResource & {
    location?: string;
    readonly endTime?: Date;
    readonly errorCode?: number;
    readonly errorMessage?: string;
    readonly errorSeverity?: number;
    readonly operation?: string;
    readonly operationId?: string;
    readonly percentComplete?: number;
    readonly requestedDatabaseDtuMax?: number;
    readonly requestedDatabaseDtuMin?: number;
    readonly requestedDtu?: number;
    readonly requestedElasticPoolName?: string;
    readonly requestedStorageLimitInGB?: number;
    readonly elasticPoolName?: string;
    readonly serverName?: string;
    readonly startTime?: Date;
    readonly state?: string;
    readonly requestedStorageLimitInMB?: number;
    readonly requestedDatabaseDtuGuarantee?: number;
    readonly requestedDatabaseDtuCap?: number;
    readonly requestedDtuGuarantee?: number;
};

// @public
export interface ElasticPoolActivityListResult {
    value: ElasticPoolActivity[];
}

// @public
export interface ElasticPoolDatabaseActivities {
    listByElasticPool(resourceGroupName: string, serverName: string, elasticPoolName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<ElasticPoolDatabaseActivity>;
}

// @public
export type ElasticPoolDatabaseActivitiesListByElasticPoolResponse = ElasticPoolDatabaseActivityListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ElasticPoolDatabaseActivityListResult;
    };
};

// @public
export type ElasticPoolDatabaseActivity = ProxyResource & {
    location?: string;
    readonly databaseName?: string;
    readonly endTime?: Date;
    readonly errorCode?: number;
    readonly errorMessage?: string;
    readonly errorSeverity?: number;
    readonly operation?: string;
    readonly operationId?: string;
    readonly percentComplete?: number;
    readonly requestedElasticPoolName?: string;
    readonly currentElasticPoolName?: string;
    readonly currentServiceObjective?: string;
    readonly requestedServiceObjective?: string;
    readonly serverName?: string;
    readonly startTime?: Date;
    readonly state?: string;
};

// @public
export interface ElasticPoolDatabaseActivityListResult {
    value: ElasticPoolDatabaseActivity[];
}

// @public
export type ElasticPoolEdition = string;

// @public
export interface ElasticPoolEditionCapability {
    readonly name?: string;
    reason?: string;
    readonly status?: CapabilityStatus;
    readonly supportedElasticPoolPerformanceLevels?: ElasticPoolPerformanceLevelCapability[];
    readonly zoneRedundant?: boolean;
}

// @public
export type ElasticPoolLicenseType = string;

// @public
export interface ElasticPoolListResult {
    readonly nextLink?: string;
    readonly value?: ElasticPool[];
}

// @public
export type ElasticPoolOperation = ProxyResource & {
    readonly elasticPoolName?: string;
    readonly operation?: string;
    readonly operationFriendlyName?: string;
    readonly percentComplete?: number;
    readonly serverName?: string;
    readonly startTime?: Date;
    readonly state?: string;
    readonly errorCode?: number;
    readonly errorDescription?: string;
    readonly errorSeverity?: number;
    readonly isUserError?: boolean;
    readonly estimatedCompletionTime?: Date;
    readonly description?: string;
    readonly isCancellable?: boolean;
};

// @public
export interface ElasticPoolOperationListResult {
    readonly nextLink?: string;
    readonly value?: ElasticPoolOperation[];
}

// @public
export interface ElasticPoolOperations {
    cancel(resourceGroupName: string, serverName: string, elasticPoolName: string, operationId: string, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    listByElasticPool(resourceGroupName: string, serverName: string, elasticPoolName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<ElasticPoolOperation>;
}

// @public
export type ElasticPoolOperationsListByElasticPoolNextResponse = ElasticPoolOperationListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ElasticPoolOperationListResult;
    };
};

// @public
export type ElasticPoolOperationsListByElasticPoolResponse = ElasticPoolOperationListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ElasticPoolOperationListResult;
    };
};

// @public
export interface ElasticPoolPerDatabaseMaxPerformanceLevelCapability {
    readonly limit?: number;
    reason?: string;
    readonly status?: CapabilityStatus;
    readonly supportedPerDatabaseMinPerformanceLevels?: ElasticPoolPerDatabaseMinPerformanceLevelCapability[];
    readonly unit?: PerformanceLevelUnit;
}

// @public
export interface ElasticPoolPerDatabaseMinPerformanceLevelCapability {
    readonly limit?: number;
    reason?: string;
    readonly status?: CapabilityStatus;
    readonly unit?: PerformanceLevelUnit;
}

// @public
export interface ElasticPoolPerDatabaseSettings {
    maxCapacity?: number;
    minCapacity?: number;
}

// @public
export interface ElasticPoolPerformanceLevelCapability {
    readonly includedMaxSize?: MaxSizeCapability;
    readonly maxDatabaseCount?: number;
    readonly performanceLevel?: PerformanceLevelCapability;
    reason?: string;
    readonly sku?: Sku;
    readonly status?: CapabilityStatus;
    readonly supportedLicenseTypes?: LicenseTypeCapability[];
    readonly supportedMaxSizes?: MaxSizeRangeCapability[];
    readonly supportedPerDatabaseMaxPerformanceLevels?: ElasticPoolPerDatabaseMaxPerformanceLevelCapability[];
    readonly supportedPerDatabaseMaxSizes?: MaxSizeRangeCapability[];
    readonly zoneRedundant?: boolean;
}

// @public
export interface ElasticPools {
    createOrUpdate(resourceGroupName: string, serverName: string, elasticPoolName: string, parameters: ElasticPool, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<ElasticPoolsCreateOrUpdateResponse>, ElasticPoolsCreateOrUpdateResponse>>;
    delete(resourceGroupName: string, serverName: string, elasticPoolName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    failover(resourceGroupName: string, serverName: string, elasticPoolName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    get(resourceGroupName: string, serverName: string, elasticPoolName: string, options?: coreHttp.OperationOptions): Promise<ElasticPoolsGetResponse>;
    listByServer(resourceGroupName: string, serverName: string, options?: ElasticPoolsListByServerOptionalParams): PagedAsyncIterableIterator<ElasticPool>;
    listMetricDefinitions(resourceGroupName: string, serverName: string, elasticPoolName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<MetricDefinition>;
    listMetrics(resourceGroupName: string, serverName: string, elasticPoolName: string, filter: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<Metric>;
    update(resourceGroupName: string, serverName: string, elasticPoolName: string, parameters: ElasticPoolUpdate, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<ElasticPoolsUpdateResponse>, ElasticPoolsUpdateResponse>>;
}

// @public
export type ElasticPoolsCreateOrUpdateResponse = ElasticPool & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ElasticPool;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type ElasticPoolsGetResponse = ElasticPool & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ElasticPool;
    };
};

// @public
export interface ElasticPoolsListByServerNextOptionalParams extends coreHttp.OperationOptions {
    skip?: number;
}

// @public
export type ElasticPoolsListByServerNextResponse = ElasticPoolListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ElasticPoolListResult;
    };
};

// @public
export interface ElasticPoolsListByServerOptionalParams extends coreHttp.OperationOptions {
    skip?: number;
}

// @public
export type ElasticPoolsListByServerResponse = ElasticPoolListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ElasticPoolListResult;
    };
};

// @public
export type ElasticPoolsListMetricDefinitionsResponse = MetricDefinitionListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: MetricDefinitionListResult;
    };
};

// @public
export type ElasticPoolsListMetricsResponse = MetricListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: MetricListResult;
    };
};

// @public
export type ElasticPoolState = string;

// @public
export type ElasticPoolsUpdateResponse = ElasticPool & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ElasticPool;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export interface ElasticPoolUpdate {
    licenseType?: ElasticPoolLicenseType;
    maxSizeBytes?: number;
    perDatabaseSettings?: ElasticPoolPerDatabaseSettings;
    sku?: Sku;
    tags?: {
        [propertyName: string]: string;
    };
    zoneRedundant?: boolean;
}

// @public
export type EncryptionProtector = ProxyResource & {
    readonly kind?: string;
    readonly location?: string;
    readonly subregion?: string;
    serverKeyName?: string;
    serverKeyType?: ServerKeyType;
    readonly uri?: string;
    readonly thumbprint?: string;
};

// @public
export interface EncryptionProtectorListResult {
    readonly nextLink?: string;
    readonly value?: EncryptionProtector[];
}

// @public
export type EncryptionProtectorName = string;

// @public
export interface EncryptionProtectors {
    createOrUpdate(resourceGroupName: string, serverName: string, encryptionProtectorName: EncryptionProtectorName, parameters: EncryptionProtector, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<EncryptionProtectorsCreateOrUpdateResponse>, EncryptionProtectorsCreateOrUpdateResponse>>;
    get(resourceGroupName: string, serverName: string, encryptionProtectorName: EncryptionProtectorName, options?: coreHttp.OperationOptions): Promise<EncryptionProtectorsGetResponse>;
    listByServer(resourceGroupName: string, serverName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<EncryptionProtector>;
    revalidate(resourceGroupName: string, serverName: string, encryptionProtectorName: EncryptionProtectorName, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
}

// @public
export type EncryptionProtectorsCreateOrUpdateResponse = EncryptionProtector & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: EncryptionProtector;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type EncryptionProtectorsGetResponse = EncryptionProtector & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: EncryptionProtector;
    };
};

// @public
export type EncryptionProtectorsListByServerNextResponse = EncryptionProtectorListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: EncryptionProtectorListResult;
    };
};

// @public
export type EncryptionProtectorsListByServerResponse = EncryptionProtectorListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: EncryptionProtectorListResult;
    };
};

// @public
export type Enum21 = string;

// @public
export interface ExportRequest {
    administratorLogin: string;
    administratorLoginPassword: string;
    authenticationType?: AuthenticationType;
    storageKey: string;
    storageKeyType: StorageKeyType;
    storageUri: string;
}

// @public
export interface ExtendedDatabaseBlobAuditingPolicies {
    createOrUpdate(resourceGroupName: string, serverName: string, databaseName: string, parameters: ExtendedDatabaseBlobAuditingPolicy, options?: coreHttp.OperationOptions): Promise<ExtendedDatabaseBlobAuditingPoliciesCreateOrUpdateResponse>;
    get(resourceGroupName: string, serverName: string, databaseName: string, options?: coreHttp.OperationOptions): Promise<ExtendedDatabaseBlobAuditingPoliciesGetResponse>;
    listByDatabase(resourceGroupName: string, serverName: string, databaseName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<ExtendedDatabaseBlobAuditingPolicy>;
}

// @public
export type ExtendedDatabaseBlobAuditingPoliciesCreateOrUpdateResponse = ExtendedDatabaseBlobAuditingPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ExtendedDatabaseBlobAuditingPolicy;
    };
};

// @public
export type ExtendedDatabaseBlobAuditingPoliciesGetResponse = ExtendedDatabaseBlobAuditingPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ExtendedDatabaseBlobAuditingPolicy;
    };
};

// @public
export type ExtendedDatabaseBlobAuditingPoliciesListByDatabaseNextResponse = ExtendedDatabaseBlobAuditingPolicyListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ExtendedDatabaseBlobAuditingPolicyListResult;
    };
};

// @public
export type ExtendedDatabaseBlobAuditingPoliciesListByDatabaseResponse = ExtendedDatabaseBlobAuditingPolicyListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ExtendedDatabaseBlobAuditingPolicyListResult;
    };
};

// @public
export type ExtendedDatabaseBlobAuditingPolicy = ProxyResource & {
    predicateExpression?: string;
    state?: BlobAuditingPolicyState;
    storageEndpoint?: string;
    storageAccountAccessKey?: string;
    retentionDays?: number;
    auditActionsAndGroups?: string[];
    storageAccountSubscriptionId?: string;
    isStorageSecondaryKeyInUse?: boolean;
    isAzureMonitorTargetEnabled?: boolean;
    queueDelayMs?: number;
};

// @public
export interface ExtendedDatabaseBlobAuditingPolicyListResult {
    readonly nextLink?: string;
    readonly value?: ExtendedDatabaseBlobAuditingPolicy[];
}

// @public
export interface ExtendedServerBlobAuditingPolicies {
    createOrUpdate(resourceGroupName: string, serverName: string, parameters: ExtendedServerBlobAuditingPolicy, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<ExtendedServerBlobAuditingPoliciesCreateOrUpdateResponse>, ExtendedServerBlobAuditingPoliciesCreateOrUpdateResponse>>;
    get(resourceGroupName: string, serverName: string, options?: coreHttp.OperationOptions): Promise<ExtendedServerBlobAuditingPoliciesGetResponse>;
    listByServer(resourceGroupName: string, serverName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<ExtendedServerBlobAuditingPolicy>;
}

// @public
export type ExtendedServerBlobAuditingPoliciesCreateOrUpdateResponse = ExtendedServerBlobAuditingPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ExtendedServerBlobAuditingPolicy;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type ExtendedServerBlobAuditingPoliciesGetResponse = ExtendedServerBlobAuditingPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ExtendedServerBlobAuditingPolicy;
    };
};

// @public
export type ExtendedServerBlobAuditingPoliciesListByServerNextResponse = ExtendedServerBlobAuditingPolicyListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ExtendedServerBlobAuditingPolicyListResult;
    };
};

// @public
export type ExtendedServerBlobAuditingPoliciesListByServerResponse = ExtendedServerBlobAuditingPolicyListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ExtendedServerBlobAuditingPolicyListResult;
    };
};

// @public
export type ExtendedServerBlobAuditingPolicy = ProxyResource & {
    predicateExpression?: string;
    state?: BlobAuditingPolicyState;
    storageEndpoint?: string;
    storageAccountAccessKey?: string;
    retentionDays?: number;
    auditActionsAndGroups?: string[];
    storageAccountSubscriptionId?: string;
    isStorageSecondaryKeyInUse?: boolean;
    isAzureMonitorTargetEnabled?: boolean;
    queueDelayMs?: number;
};

// @public
export interface ExtendedServerBlobAuditingPolicyListResult {
    readonly nextLink?: string;
    readonly value?: ExtendedServerBlobAuditingPolicy[];
}

// @public
export type ExtensionName = string;

// @public
export type FailoverGroup = ProxyResource & {
    readonly location?: string;
    tags?: {
        [propertyName: string]: string;
    };
    readWriteEndpoint?: FailoverGroupReadWriteEndpoint;
    readOnlyEndpoint?: FailoverGroupReadOnlyEndpoint;
    readonly replicationRole?: FailoverGroupReplicationRole;
    readonly replicationState?: string;
    partnerServers?: PartnerInfo[];
    databases?: string[];
};

// @public
export interface FailoverGroupListResult {
    readonly nextLink?: string;
    readonly value?: FailoverGroup[];
}

// @public
export interface FailoverGroupReadOnlyEndpoint {
    failoverPolicy?: ReadOnlyEndpointFailoverPolicy;
}

// @public
export interface FailoverGroupReadWriteEndpoint {
    failoverPolicy: ReadWriteEndpointFailoverPolicy;
    failoverWithDataLossGracePeriodMinutes?: number;
}

// @public
export type FailoverGroupReplicationRole = string;

// @public
export interface FailoverGroups {
    createOrUpdate(resourceGroupName: string, serverName: string, failoverGroupName: string, parameters: FailoverGroup, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<FailoverGroupsCreateOrUpdateResponse>, FailoverGroupsCreateOrUpdateResponse>>;
    delete(resourceGroupName: string, serverName: string, failoverGroupName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    failover(resourceGroupName: string, serverName: string, failoverGroupName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<FailoverGroupsFailoverResponse>, FailoverGroupsFailoverResponse>>;
    forceFailoverAllowDataLoss(resourceGroupName: string, serverName: string, failoverGroupName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<FailoverGroupsForceFailoverAllowDataLossResponse>, FailoverGroupsForceFailoverAllowDataLossResponse>>;
    get(resourceGroupName: string, serverName: string, failoverGroupName: string, options?: coreHttp.OperationOptions): Promise<FailoverGroupsGetResponse>;
    listByServer(resourceGroupName: string, serverName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<FailoverGroup>;
    update(resourceGroupName: string, serverName: string, failoverGroupName: string, parameters: FailoverGroupUpdate, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<FailoverGroupsUpdateResponse>, FailoverGroupsUpdateResponse>>;
}

// @public
export type FailoverGroupsCreateOrUpdateResponse = FailoverGroup & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: FailoverGroup;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type FailoverGroupsFailoverResponse = FailoverGroup & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: FailoverGroup;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type FailoverGroupsForceFailoverAllowDataLossResponse = FailoverGroup & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: FailoverGroup;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type FailoverGroupsGetResponse = FailoverGroup & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: FailoverGroup;
    };
};

// @public
export type FailoverGroupsListByServerNextResponse = FailoverGroupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: FailoverGroupListResult;
    };
};

// @public
export type FailoverGroupsListByServerResponse = FailoverGroupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: FailoverGroupListResult;
    };
};

// @public
export type FailoverGroupsUpdateResponse = FailoverGroup & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: FailoverGroup;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export interface FailoverGroupUpdate {
    databases?: string[];
    readOnlyEndpoint?: FailoverGroupReadOnlyEndpoint;
    readWriteEndpoint?: FailoverGroupReadWriteEndpoint;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export type FirewallRule = ProxyResource & {
    readonly kind?: string;
    readonly location?: string;
    startIpAddress?: string;
    endIpAddress?: string;
};

// @public
export interface FirewallRuleListResult {
    value?: FirewallRule[];
}

// @public
export interface FirewallRules {
    createOrUpdate(resourceGroupName: string, serverName: string, firewallRuleName: string, parameters: FirewallRule, options?: coreHttp.OperationOptions): Promise<FirewallRulesCreateOrUpdateResponse>;
    delete(resourceGroupName: string, serverName: string, firewallRuleName: string, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    get(resourceGroupName: string, serverName: string, firewallRuleName: string, options?: coreHttp.OperationOptions): Promise<FirewallRulesGetResponse>;
    listByServer(resourceGroupName: string, serverName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<FirewallRule>;
}

// @public
export type FirewallRulesCreateOrUpdateResponse = FirewallRule & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: FirewallRule;
    };
};

// @public
export type FirewallRulesGetResponse = FirewallRule & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: FirewallRule;
    };
};

// @public
export type FirewallRulesListByServerResponse = FirewallRuleListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: FirewallRuleListResult;
    };
};

// @public
export interface GeoBackupPolicies {
    createOrUpdate(resourceGroupName: string, serverName: string, databaseName: string, geoBackupPolicyName: GeoBackupPolicyName, parameters: GeoBackupPolicy, options?: coreHttp.OperationOptions): Promise<GeoBackupPoliciesCreateOrUpdateResponse>;
    get(resourceGroupName: string, serverName: string, databaseName: string, geoBackupPolicyName: GeoBackupPolicyName, options?: coreHttp.OperationOptions): Promise<GeoBackupPoliciesGetResponse>;
    listByDatabase(resourceGroupName: string, serverName: string, databaseName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<GeoBackupPolicy>;
}

// @public
export type GeoBackupPoliciesCreateOrUpdateResponse = GeoBackupPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: GeoBackupPolicy;
    };
};

// @public
export type GeoBackupPoliciesGetResponse = GeoBackupPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: GeoBackupPolicy;
    };
};

// @public
export type GeoBackupPoliciesListByDatabaseResponse = GeoBackupPolicyListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: GeoBackupPolicyListResult;
    };
};

// @public
export type GeoBackupPolicy = ProxyResource & {
    readonly kind?: string;
    readonly location?: string;
    state: GeoBackupPolicyState;
    readonly storageType?: string;
};

// @public
export interface GeoBackupPolicyListResult {
    value?: GeoBackupPolicy[];
}

// @public
export type GeoBackupPolicyName = string;

// @public
export type GeoBackupPolicyState = "Disabled" | "Enabled";

// @public
export type IdentityType = string;

// @public
export type ImportExportResponse = ProxyResource & {
    readonly requestType?: string;
    readonly requestId?: string;
    readonly serverName?: string;
    readonly databaseName?: string;
    readonly status?: string;
    readonly lastModifiedTime?: string;
    readonly queuedTime?: string;
    readonly blobUri?: string;
    readonly errorMessage?: string;
};

// @public
export type ImportExtensionProperties = ExportRequest & {
    operationMode: "Import";
};

// @public
export interface ImportExtensionRequest {
    administratorLogin?: string;
    administratorLoginPassword?: string;
    authenticationType?: AuthenticationType;
    name?: string;
    operationMode?: "Import";
    storageKey?: string;
    storageKeyType?: StorageKeyType;
    storageUri?: string;
    type?: string;
}

// @public
export type ImportRequest = ExportRequest & {
    databaseName: string;
    edition: DatabaseEdition;
    serviceObjectiveName: ServiceObjectiveName;
    maxSizeBytes: string;
};

// @public
export type InstanceFailoverGroup = ProxyResource & {
    readWriteEndpoint?: InstanceFailoverGroupReadWriteEndpoint;
    readOnlyEndpoint?: InstanceFailoverGroupReadOnlyEndpoint;
    readonly replicationRole?: InstanceFailoverGroupReplicationRole;
    readonly replicationState?: string;
    partnerRegions?: PartnerRegionInfo[];
    managedInstancePairs?: ManagedInstancePairInfo[];
};

// @public
export interface InstanceFailoverGroupListResult {
    readonly nextLink?: string;
    readonly value?: InstanceFailoverGroup[];
}

// @public
export interface InstanceFailoverGroupReadOnlyEndpoint {
    failoverPolicy?: ReadOnlyEndpointFailoverPolicy;
}

// @public
export interface InstanceFailoverGroupReadWriteEndpoint {
    failoverPolicy: ReadWriteEndpointFailoverPolicy;
    failoverWithDataLossGracePeriodMinutes?: number;
}

// @public
export type InstanceFailoverGroupReplicationRole = string;

// @public
export interface InstanceFailoverGroups {
    createOrUpdate(resourceGroupName: string, locationName: string, failoverGroupName: string, parameters: InstanceFailoverGroup, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<InstanceFailoverGroupsCreateOrUpdateResponse>, InstanceFailoverGroupsCreateOrUpdateResponse>>;
    delete(resourceGroupName: string, locationName: string, failoverGroupName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    failover(resourceGroupName: string, locationName: string, failoverGroupName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<InstanceFailoverGroupsFailoverResponse>, InstanceFailoverGroupsFailoverResponse>>;
    forceFailoverAllowDataLoss(resourceGroupName: string, locationName: string, failoverGroupName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<InstanceFailoverGroupsForceFailoverAllowDataLossResponse>, InstanceFailoverGroupsForceFailoverAllowDataLossResponse>>;
    get(resourceGroupName: string, locationName: string, failoverGroupName: string, options?: coreHttp.OperationOptions): Promise<InstanceFailoverGroupsGetResponse>;
    listByLocation(resourceGroupName: string, locationName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<InstanceFailoverGroup>;
}

// @public
export type InstanceFailoverGroupsCreateOrUpdateResponse = InstanceFailoverGroup & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: InstanceFailoverGroup;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type InstanceFailoverGroupsFailoverResponse = InstanceFailoverGroup & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: InstanceFailoverGroup;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type InstanceFailoverGroupsForceFailoverAllowDataLossResponse = InstanceFailoverGroup & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: InstanceFailoverGroup;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type InstanceFailoverGroupsGetResponse = InstanceFailoverGroup & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: InstanceFailoverGroup;
    };
};

// @public
export type InstanceFailoverGroupsListByLocationNextResponse = InstanceFailoverGroupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: InstanceFailoverGroupListResult;
    };
};

// @public
export type InstanceFailoverGroupsListByLocationResponse = InstanceFailoverGroupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: InstanceFailoverGroupListResult;
    };
};

// @public
export type InstancePool = TrackedResource & {
    sku?: Sku;
    subnetId?: string;
    vCores?: number;
    licenseType?: InstancePoolLicenseType;
};

// @public
export interface InstancePoolEditionCapability {
    readonly name?: string;
    reason?: string;
    readonly status?: CapabilityStatus;
    readonly supportedFamilies?: InstancePoolFamilyCapability[];
}

// @public
export interface InstancePoolFamilyCapability {
    readonly name?: string;
    reason?: string;
    readonly status?: CapabilityStatus;
    readonly supportedLicenseTypes?: LicenseTypeCapability[];
    readonly supportedVcoresValues?: InstancePoolVcoresCapability[];
}

// @public
export type InstancePoolLicenseType = string;

// @public
export interface InstancePoolListResult {
    readonly nextLink?: string;
    readonly value?: InstancePool[];
}

// @public
export interface InstancePools {
    createOrUpdate(resourceGroupName: string, instancePoolName: string, parameters: InstancePool, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<InstancePoolsCreateOrUpdateResponse>, InstancePoolsCreateOrUpdateResponse>>;
    delete(resourceGroupName: string, instancePoolName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    get(resourceGroupName: string, instancePoolName: string, options?: coreHttp.OperationOptions): Promise<InstancePoolsGetResponse>;
    list(options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<InstancePool>;
    listByResourceGroup(resourceGroupName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<InstancePool>;
    update(resourceGroupName: string, instancePoolName: string, parameters: InstancePoolUpdate, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<InstancePoolsUpdateResponse>, InstancePoolsUpdateResponse>>;
}

// @public
export type InstancePoolsCreateOrUpdateResponse = InstancePool & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: InstancePool;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type InstancePoolsGetResponse = InstancePool & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: InstancePool;
    };
};

// @public
export type InstancePoolsListByResourceGroupNextResponse = InstancePoolListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: InstancePoolListResult;
    };
};

// @public
export type InstancePoolsListByResourceGroupResponse = InstancePoolListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: InstancePoolListResult;
    };
};

// @public
export type InstancePoolsListNextResponse = InstancePoolListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: InstancePoolListResult;
    };
};

// @public
export type InstancePoolsListResponse = InstancePoolListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: InstancePoolListResult;
    };
};

// @public
export type InstancePoolsUpdateResponse = InstancePool & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: InstancePool;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export interface InstancePoolUpdate {
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export interface InstancePoolVcoresCapability {
    readonly name?: string;
    reason?: string;
    readonly status?: CapabilityStatus;
    readonly storageLimit?: MaxSizeCapability;
    readonly value?: number;
}

// @public
export type Job = ProxyResource & {
    description?: string;
    readonly version?: number;
    schedule?: JobSchedule;
};

// @public
export type JobAgent = TrackedResource & {
    sku?: Sku;
    databaseId?: string;
    readonly state?: JobAgentState;
};

// @public
export interface JobAgentListResult {
    readonly nextLink?: string;
    readonly value?: JobAgent[];
}

// @public
export interface JobAgents {
    createOrUpdate(resourceGroupName: string, serverName: string, jobAgentName: string, parameters: JobAgent, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<JobAgentsCreateOrUpdateResponse>, JobAgentsCreateOrUpdateResponse>>;
    delete(resourceGroupName: string, serverName: string, jobAgentName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    get(resourceGroupName: string, serverName: string, jobAgentName: string, options?: coreHttp.OperationOptions): Promise<JobAgentsGetResponse>;
    listByServer(resourceGroupName: string, serverName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<JobAgent>;
    update(resourceGroupName: string, serverName: string, jobAgentName: string, parameters: JobAgentUpdate, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<JobAgentsUpdateResponse>, JobAgentsUpdateResponse>>;
}

// @public
export type JobAgentsCreateOrUpdateResponse = JobAgent & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobAgent;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type JobAgentsGetResponse = JobAgent & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobAgent;
    };
};

// @public
export type JobAgentsListByServerNextResponse = JobAgentListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobAgentListResult;
    };
};

// @public
export type JobAgentsListByServerResponse = JobAgentListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobAgentListResult;
    };
};

// @public
export type JobAgentState = string;

// @public
export type JobAgentsUpdateResponse = JobAgent & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobAgent;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export interface JobAgentUpdate {
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export type JobCredential = ProxyResource & {
    username?: string;
    password?: string;
};

// @public
export interface JobCredentialListResult {
    readonly nextLink?: string;
    readonly value?: JobCredential[];
}

// @public
export interface JobCredentials {
    createOrUpdate(resourceGroupName: string, serverName: string, jobAgentName: string, credentialName: string, parameters: JobCredential, options?: coreHttp.OperationOptions): Promise<JobCredentialsCreateOrUpdateResponse>;
    delete(resourceGroupName: string, serverName: string, jobAgentName: string, credentialName: string, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    get(resourceGroupName: string, serverName: string, jobAgentName: string, credentialName: string, options?: coreHttp.OperationOptions): Promise<JobCredentialsGetResponse>;
    listByAgent(resourceGroupName: string, serverName: string, jobAgentName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<JobCredential>;
}

// @public
export type JobCredentialsCreateOrUpdateResponse = JobCredential & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobCredential;
    };
};

// @public
export type JobCredentialsGetResponse = JobCredential & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobCredential;
    };
};

// @public
export type JobCredentialsListByAgentNextResponse = JobCredentialListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobCredentialListResult;
    };
};

// @public
export type JobCredentialsListByAgentResponse = JobCredentialListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobCredentialListResult;
    };
};

// @public
export type JobExecution = ProxyResource & {
    readonly jobVersion?: number;
    readonly stepName?: string;
    readonly stepId?: number;
    readonly jobExecutionId?: string;
    readonly lifecycle?: JobExecutionLifecycle;
    readonly provisioningState?: ProvisioningState;
    readonly createTime?: Date;
    readonly startTime?: Date;
    readonly endTime?: Date;
    currentAttempts?: number;
    readonly currentAttemptStartTime?: Date;
    readonly lastMessage?: string;
    readonly target?: JobExecutionTarget;
};

// @public
export type JobExecutionLifecycle = string;

// @public
export interface JobExecutionListResult {
    readonly nextLink?: string;
    readonly value?: JobExecution[];
}

// @public
export interface JobExecutions {
    cancel(resourceGroupName: string, serverName: string, jobAgentName: string, jobName: string, jobExecutionId: string, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    create(resourceGroupName: string, serverName: string, jobAgentName: string, jobName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<JobExecutionsCreateResponse>, JobExecutionsCreateResponse>>;
    createOrUpdate(resourceGroupName: string, serverName: string, jobAgentName: string, jobName: string, jobExecutionId: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<JobExecutionsCreateOrUpdateResponse>, JobExecutionsCreateOrUpdateResponse>>;
    get(resourceGroupName: string, serverName: string, jobAgentName: string, jobName: string, jobExecutionId: string, options?: coreHttp.OperationOptions): Promise<JobExecutionsGetResponse>;
    listByAgent(resourceGroupName: string, serverName: string, jobAgentName: string, options?: JobExecutionsListByAgentOptionalParams): PagedAsyncIterableIterator<JobExecution>;
    listByJob(resourceGroupName: string, serverName: string, jobAgentName: string, jobName: string, options?: JobExecutionsListByJobOptionalParams): PagedAsyncIterableIterator<JobExecution>;
}

// @public
export type JobExecutionsCreateOrUpdateResponse = JobExecution & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobExecution;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type JobExecutionsCreateResponse = JobExecution & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobExecution;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type JobExecutionsGetResponse = JobExecution & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobExecution;
    };
};

// @public
export interface JobExecutionsListByAgentNextOptionalParams extends coreHttp.OperationOptions {
    createTimeMax?: Date;
    createTimeMin?: Date;
    endTimeMax?: Date;
    endTimeMin?: Date;
    isActive?: boolean;
    skip?: number;
    top?: number;
}

// @public
export type JobExecutionsListByAgentNextResponse = JobExecutionListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobExecutionListResult;
    };
};

// @public
export interface JobExecutionsListByAgentOptionalParams extends coreHttp.OperationOptions {
    createTimeMax?: Date;
    createTimeMin?: Date;
    endTimeMax?: Date;
    endTimeMin?: Date;
    isActive?: boolean;
    skip?: number;
    top?: number;
}

// @public
export type JobExecutionsListByAgentResponse = JobExecutionListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobExecutionListResult;
    };
};

// @public
export interface JobExecutionsListByJobNextOptionalParams extends coreHttp.OperationOptions {
    createTimeMax?: Date;
    createTimeMin?: Date;
    endTimeMax?: Date;
    endTimeMin?: Date;
    isActive?: boolean;
    skip?: number;
    top?: number;
}

// @public
export type JobExecutionsListByJobNextResponse = JobExecutionListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobExecutionListResult;
    };
};

// @public
export interface JobExecutionsListByJobOptionalParams extends coreHttp.OperationOptions {
    createTimeMax?: Date;
    createTimeMin?: Date;
    endTimeMax?: Date;
    endTimeMin?: Date;
    isActive?: boolean;
    skip?: number;
    top?: number;
}

// @public
export type JobExecutionsListByJobResponse = JobExecutionListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobExecutionListResult;
    };
};

// @public
export interface JobExecutionTarget {
    readonly databaseName?: string;
    readonly serverName?: string;
    readonly type?: JobTargetType;
}

// @public
export interface JobListResult {
    readonly nextLink?: string;
    readonly value?: Job[];
}

// @public
export interface Jobs {
    createOrUpdate(resourceGroupName: string, serverName: string, jobAgentName: string, jobName: string, parameters: Job, options?: coreHttp.OperationOptions): Promise<JobsCreateOrUpdateResponse>;
    delete(resourceGroupName: string, serverName: string, jobAgentName: string, jobName: string, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    get(resourceGroupName: string, serverName: string, jobAgentName: string, jobName: string, options?: coreHttp.OperationOptions): Promise<JobsGetResponse>;
    listByAgent(resourceGroupName: string, serverName: string, jobAgentName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<Job>;
}

// @public
export interface JobSchedule {
    enabled?: boolean;
    endTime?: Date;
    interval?: string;
    startTime?: Date;
    type?: JobScheduleType;
}

// @public
export type JobScheduleType = "Once" | "Recurring";

// @public
export type JobsCreateOrUpdateResponse = Job & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: Job;
    };
};

// @public
export type JobsGetResponse = Job & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: Job;
    };
};

// @public
export type JobsListByAgentNextResponse = JobListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobListResult;
    };
};

// @public
export type JobsListByAgentResponse = JobListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobListResult;
    };
};

// @public
export type JobStep = ProxyResource & {
    stepId?: number;
    targetGroup?: string;
    credential?: string;
    action?: JobStepAction;
    output?: JobStepOutput;
    executionOptions?: JobStepExecutionOptions;
};

// @public
export interface JobStepAction {
    source?: JobStepActionSource;
    type?: JobStepActionType;
    value: string;
}

// @public
export type JobStepActionSource = string;

// @public
export type JobStepActionType = string;

// @public
export interface JobStepExecutionOptions {
    initialRetryIntervalSeconds?: number;
    maximumRetryIntervalSeconds?: number;
    retryAttempts?: number;
    retryIntervalBackoffMultiplier?: number;
    timeoutSeconds?: number;
}

// @public
export interface JobStepExecutions {
    get(resourceGroupName: string, serverName: string, jobAgentName: string, jobName: string, jobExecutionId: string, stepName: string, options?: coreHttp.OperationOptions): Promise<JobStepExecutionsGetResponse>;
    listByJobExecution(resourceGroupName: string, serverName: string, jobAgentName: string, jobName: string, jobExecutionId: string, options?: JobStepExecutionsListByJobExecutionOptionalParams): PagedAsyncIterableIterator<JobExecution>;
}

// @public
export type JobStepExecutionsGetResponse = JobExecution & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobExecution;
    };
};

// @public
export interface JobStepExecutionsListByJobExecutionNextOptionalParams extends coreHttp.OperationOptions {
    createTimeMax?: Date;
    createTimeMin?: Date;
    endTimeMax?: Date;
    endTimeMin?: Date;
    isActive?: boolean;
    skip?: number;
    top?: number;
}

// @public
export type JobStepExecutionsListByJobExecutionNextResponse = JobExecutionListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobExecutionListResult;
    };
};

// @public
export interface JobStepExecutionsListByJobExecutionOptionalParams extends coreHttp.OperationOptions {
    createTimeMax?: Date;
    createTimeMin?: Date;
    endTimeMax?: Date;
    endTimeMin?: Date;
    isActive?: boolean;
    skip?: number;
    top?: number;
}

// @public
export type JobStepExecutionsListByJobExecutionResponse = JobExecutionListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobExecutionListResult;
    };
};

// @public
export interface JobStepListResult {
    readonly nextLink?: string;
    readonly value?: JobStep[];
}

// @public
export interface JobStepOutput {
    credential: string;
    databaseName: string;
    resourceGroupName?: string;
    schemaName?: string;
    serverName: string;
    subscriptionId?: string;
    tableName: string;
    type?: JobStepOutputType;
}

// @public
export type JobStepOutputType = string;

// @public
export interface JobSteps {
    createOrUpdate(resourceGroupName: string, serverName: string, jobAgentName: string, jobName: string, stepName: string, parameters: JobStep, options?: coreHttp.OperationOptions): Promise<JobStepsCreateOrUpdateResponse>;
    delete(resourceGroupName: string, serverName: string, jobAgentName: string, jobName: string, stepName: string, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    get(resourceGroupName: string, serverName: string, jobAgentName: string, jobName: string, stepName: string, options?: coreHttp.OperationOptions): Promise<JobStepsGetResponse>;
    getByVersion(resourceGroupName: string, serverName: string, jobAgentName: string, jobName: string, jobVersion: number, stepName: string, options?: coreHttp.OperationOptions): Promise<JobStepsGetByVersionResponse>;
    listByJob(resourceGroupName: string, serverName: string, jobAgentName: string, jobName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<JobStep>;
    listByVersion(resourceGroupName: string, serverName: string, jobAgentName: string, jobName: string, jobVersion: number, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<JobStep>;
}

// @public
export type JobStepsCreateOrUpdateResponse = JobStep & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobStep;
    };
};

// @public
export type JobStepsGetByVersionResponse = JobStep & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobStep;
    };
};

// @public
export type JobStepsGetResponse = JobStep & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobStep;
    };
};

// @public
export type JobStepsListByJobNextResponse = JobStepListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobStepListResult;
    };
};

// @public
export type JobStepsListByJobResponse = JobStepListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobStepListResult;
    };
};

// @public
export type JobStepsListByVersionNextResponse = JobStepListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobStepListResult;
    };
};

// @public
export type JobStepsListByVersionResponse = JobStepListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobStepListResult;
    };
};

// @public
export interface JobTarget {
    databaseName?: string;
    elasticPoolName?: string;
    membershipType?: JobTargetGroupMembershipType;
    refreshCredential?: string;
    serverName?: string;
    shardMapName?: string;
    type: JobTargetType;
}

// @public
export interface JobTargetExecutions {
    get(resourceGroupName: string, serverName: string, jobAgentName: string, jobName: string, jobExecutionId: string, stepName: string, targetId: string, options?: coreHttp.OperationOptions): Promise<JobTargetExecutionsGetResponse>;
    listByJobExecution(resourceGroupName: string, serverName: string, jobAgentName: string, jobName: string, jobExecutionId: string, options?: JobTargetExecutionsListByJobExecutionOptionalParams): PagedAsyncIterableIterator<JobExecution>;
    listByStep(resourceGroupName: string, serverName: string, jobAgentName: string, jobName: string, jobExecutionId: string, stepName: string, options?: JobTargetExecutionsListByStepOptionalParams): PagedAsyncIterableIterator<JobExecution>;
}

// @public
export type JobTargetExecutionsGetResponse = JobExecution & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobExecution;
    };
};

// @public
export interface JobTargetExecutionsListByJobExecutionNextOptionalParams extends coreHttp.OperationOptions {
    createTimeMax?: Date;
    createTimeMin?: Date;
    endTimeMax?: Date;
    endTimeMin?: Date;
    isActive?: boolean;
    skip?: number;
    top?: number;
}

// @public
export type JobTargetExecutionsListByJobExecutionNextResponse = JobExecutionListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobExecutionListResult;
    };
};

// @public
export interface JobTargetExecutionsListByJobExecutionOptionalParams extends coreHttp.OperationOptions {
    createTimeMax?: Date;
    createTimeMin?: Date;
    endTimeMax?: Date;
    endTimeMin?: Date;
    isActive?: boolean;
    skip?: number;
    top?: number;
}

// @public
export type JobTargetExecutionsListByJobExecutionResponse = JobExecutionListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobExecutionListResult;
    };
};

// @public
export interface JobTargetExecutionsListByStepNextOptionalParams extends coreHttp.OperationOptions {
    createTimeMax?: Date;
    createTimeMin?: Date;
    endTimeMax?: Date;
    endTimeMin?: Date;
    isActive?: boolean;
    skip?: number;
    top?: number;
}

// @public
export type JobTargetExecutionsListByStepNextResponse = JobExecutionListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobExecutionListResult;
    };
};

// @public
export interface JobTargetExecutionsListByStepOptionalParams extends coreHttp.OperationOptions {
    createTimeMax?: Date;
    createTimeMin?: Date;
    endTimeMax?: Date;
    endTimeMin?: Date;
    isActive?: boolean;
    skip?: number;
    top?: number;
}

// @public
export type JobTargetExecutionsListByStepResponse = JobExecutionListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobExecutionListResult;
    };
};

// @public
export type JobTargetGroup = ProxyResource & {
    members?: JobTarget[];
};

// @public
export interface JobTargetGroupListResult {
    readonly nextLink?: string;
    readonly value?: JobTargetGroup[];
}

// @public
export type JobTargetGroupMembershipType = "Include" | "Exclude";

// @public
export interface JobTargetGroups {
    createOrUpdate(resourceGroupName: string, serverName: string, jobAgentName: string, targetGroupName: string, parameters: JobTargetGroup, options?: coreHttp.OperationOptions): Promise<JobTargetGroupsCreateOrUpdateResponse>;
    delete(resourceGroupName: string, serverName: string, jobAgentName: string, targetGroupName: string, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    get(resourceGroupName: string, serverName: string, jobAgentName: string, targetGroupName: string, options?: coreHttp.OperationOptions): Promise<JobTargetGroupsGetResponse>;
    listByAgent(resourceGroupName: string, serverName: string, jobAgentName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<JobTargetGroup>;
}

// @public
export type JobTargetGroupsCreateOrUpdateResponse = JobTargetGroup & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobTargetGroup;
    };
};

// @public
export type JobTargetGroupsGetResponse = JobTargetGroup & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobTargetGroup;
    };
};

// @public
export type JobTargetGroupsListByAgentNextResponse = JobTargetGroupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobTargetGroupListResult;
    };
};

// @public
export type JobTargetGroupsListByAgentResponse = JobTargetGroupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobTargetGroupListResult;
    };
};

// @public
export type JobTargetType = string;

// @public
export type JobVersion = ProxyResource & {};

// @public
export interface JobVersionListResult {
    readonly nextLink?: string;
    readonly value?: JobVersion[];
}

// @public
export interface JobVersions {
    get(resourceGroupName: string, serverName: string, jobAgentName: string, jobName: string, jobVersion: number, options?: coreHttp.OperationOptions): Promise<JobVersionsGetResponse>;
    listByJob(resourceGroupName: string, serverName: string, jobAgentName: string, jobName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<JobVersion>;
}

// @public
export type JobVersionsGetResponse = JobVersion & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobVersion;
    };
};

// @public
export type JobVersionsListByJobNextResponse = JobVersionListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobVersionListResult;
    };
};

// @public
export type JobVersionsListByJobResponse = JobVersionListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: JobVersionListResult;
    };
};

// @public
export const enum KnownAdministratorName {
    // (undocumented)
    ActiveDirectory = "ActiveDirectory"
}

// @public
export const enum KnownAdministratorType {
    // (undocumented)
    ActiveDirectory = "ActiveDirectory"
}

// @public
export const enum KnownCapabilityGroup {
    // (undocumented)
    SupportedEditions = "supportedEditions",
    // (undocumented)
    SupportedElasticPoolEditions = "supportedElasticPoolEditions",
    // (undocumented)
    SupportedInstancePoolEditions = "supportedInstancePoolEditions",
    // (undocumented)
    SupportedManagedInstanceEditions = "supportedManagedInstanceEditions",
    // (undocumented)
    SupportedManagedInstanceVersions = "supportedManagedInstanceVersions"
}

// @public
export const enum KnownCatalogCollationType {
    // (undocumented)
    DatabaseDefault = "DATABASE_DEFAULT",
    // (undocumented)
    SQLLatin1GeneralCP1CIAS = "SQL_Latin1_General_CP1_CI_AS"
}

// @public
export const enum KnownConnectionPolicyName {
    // (undocumented)
    Default = "default"
}

// @public
export const enum KnownCreateMode {
    // (undocumented)
    Copy = "Copy",
    // (undocumented)
    Default = "Default",
    // (undocumented)
    OnlineSecondary = "OnlineSecondary",
    // (undocumented)
    PointInTimeRestore = "PointInTimeRestore",
    // (undocumented)
    Recovery = "Recovery",
    // (undocumented)
    Restore = "Restore",
    // (undocumented)
    RestoreExternalBackup = "RestoreExternalBackup",
    // (undocumented)
    RestoreExternalBackupSecondary = "RestoreExternalBackupSecondary",
    // (undocumented)
    RestoreLongTermRetentionBackup = "RestoreLongTermRetentionBackup",
    // (undocumented)
    Secondary = "Secondary"
}

// @public
export const enum KnownDatabaseEdition {
    // (undocumented)
    Basic = "Basic",
    // (undocumented)
    Business = "Business",
    // (undocumented)
    BusinessCritical = "BusinessCritical",
    // (undocumented)
    DataWarehouse = "DataWarehouse",
    // (undocumented)
    Free = "Free",
    // (undocumented)
    GeneralPurpose = "GeneralPurpose",
    // (undocumented)
    Hyperscale = "Hyperscale",
    // (undocumented)
    Premium = "Premium",
    // (undocumented)
    PremiumRS = "PremiumRS",
    // (undocumented)
    Standard = "Standard",
    // (undocumented)
    Stretch = "Stretch",
    // (undocumented)
    System = "System",
    // (undocumented)
    System2 = "System2",
    // (undocumented)
    Web = "Web"
}

// @public
export const enum KnownDatabaseLicenseType {
    // (undocumented)
    BasePrice = "BasePrice",
    // (undocumented)
    LicenseIncluded = "LicenseIncluded"
}

// @public
export const enum KnownDatabaseReadScale {
    // (undocumented)
    Disabled = "Disabled",
    // (undocumented)
    Enabled = "Enabled"
}

// @public
export const enum KnownDatabaseState {
    // (undocumented)
    All = "All",
    // (undocumented)
    Deleted = "Deleted",
    // (undocumented)
    Live = "Live"
}

// @public
export const enum KnownDatabaseStatus {
    // (undocumented)
    AutoClosed = "AutoClosed",
    // (undocumented)
    Copying = "Copying",
    // (undocumented)
    Creating = "Creating",
    // (undocumented)
    Disabled = "Disabled",
    // (undocumented)
    EmergencyMode = "EmergencyMode",
    // (undocumented)
    Inaccessible = "Inaccessible",
    // (undocumented)
    Offline = "Offline",
    // (undocumented)
    OfflineChangingDwPerformanceTiers = "OfflineChangingDwPerformanceTiers",
    // (undocumented)
    OfflineSecondary = "OfflineSecondary",
    // (undocumented)
    Online = "Online",
    // (undocumented)
    OnlineChangingDwPerformanceTiers = "OnlineChangingDwPerformanceTiers",
    // (undocumented)
    Paused = "Paused",
    // (undocumented)
    Pausing = "Pausing",
    // (undocumented)
    Recovering = "Recovering",
    // (undocumented)
    RecoveryPending = "RecoveryPending",
    // (undocumented)
    Restoring = "Restoring",
    // (undocumented)
    Resuming = "Resuming",
    // (undocumented)
    Scaling = "Scaling",
    // (undocumented)
    Shutdown = "Shutdown",
    // (undocumented)
    Standby = "Standby",
    // (undocumented)
    Suspect = "Suspect"
}

// @public
export const enum KnownElasticPoolEdition {
    // (undocumented)
    Basic = "Basic",
    // (undocumented)
    BusinessCritical = "BusinessCritical",
    // (undocumented)
    GeneralPurpose = "GeneralPurpose",
    // (undocumented)
    Premium = "Premium",
    // (undocumented)
    Standard = "Standard"
}

// @public
export const enum KnownElasticPoolLicenseType {
    // (undocumented)
    BasePrice = "BasePrice",
    // (undocumented)
    LicenseIncluded = "LicenseIncluded"
}

// @public
export const enum KnownElasticPoolState {
    // (undocumented)
    Creating = "Creating",
    // (undocumented)
    Disabled = "Disabled",
    // (undocumented)
    Ready = "Ready"
}

// @public
export const enum KnownEncryptionProtectorName {
    // (undocumented)
    Current = "current"
}

// @public
export const enum KnownEnum21 {
    // (undocumented)
    All = "All",
    // (undocumented)
    Error = "Error",
    // (undocumented)
    Success = "Success",
    // (undocumented)
    Warning = "Warning"
}

// @public
export const enum KnownExtensionName {
    // (undocumented)
    Import = "import"
}

// @public
export const enum KnownFailoverGroupReplicationRole {
    // (undocumented)
    Primary = "Primary",
    // (undocumented)
    Secondary = "Secondary"
}

// @public
export const enum KnownGeoBackupPolicyName {
    // (undocumented)
    Default = "Default"
}

// @public
export const enum KnownIdentityType {
    // (undocumented)
    SystemAssigned = "SystemAssigned"
}

// @public
export const enum KnownInstanceFailoverGroupReplicationRole {
    // (undocumented)
    Primary = "Primary",
    // (undocumented)
    Secondary = "Secondary"
}

// @public
export const enum KnownInstancePoolLicenseType {
    // (undocumented)
    BasePrice = "BasePrice",
    // (undocumented)
    LicenseIncluded = "LicenseIncluded"
}

// @public
export const enum KnownJobAgentState {
    // (undocumented)
    Creating = "Creating",
    // (undocumented)
    Deleting = "Deleting",
    // (undocumented)
    Disabled = "Disabled",
    // (undocumented)
    Ready = "Ready",
    // (undocumented)
    Updating = "Updating"
}

// @public
export const enum KnownJobExecutionLifecycle {
    // (undocumented)
    Canceled = "Canceled",
    // (undocumented)
    Created = "Created",
    // (undocumented)
    Failed = "Failed",
    // (undocumented)
    InProgress = "InProgress",
    // (undocumented)
    Skipped = "Skipped",
    // (undocumented)
    Succeeded = "Succeeded",
    // (undocumented)
    SucceededWithSkipped = "SucceededWithSkipped",
    // (undocumented)
    TimedOut = "TimedOut",
    // (undocumented)
    WaitingForChildJobExecutions = "WaitingForChildJobExecutions",
    // (undocumented)
    WaitingForRetry = "WaitingForRetry"
}

// @public
export const enum KnownJobStepActionSource {
    // (undocumented)
    Inline = "Inline"
}

// @public
export const enum KnownJobStepActionType {
    // (undocumented)
    TSql = "TSql"
}

// @public
export const enum KnownJobStepOutputType {
    // (undocumented)
    SqlDatabase = "SqlDatabase"
}

// @public
export const enum KnownJobTargetType {
    // (undocumented)
    SqlDatabase = "SqlDatabase",
    // (undocumented)
    SqlElasticPool = "SqlElasticPool",
    // (undocumented)
    SqlServer = "SqlServer",
    // (undocumented)
    SqlShardMap = "SqlShardMap",
    // (undocumented)
    TargetGroup = "TargetGroup"
}

// @public
export const enum KnownLogSizeUnit {
    // (undocumented)
    Gigabytes = "Gigabytes",
    // (undocumented)
    Megabytes = "Megabytes",
    // (undocumented)
    Percent = "Percent",
    // (undocumented)
    Petabytes = "Petabytes",
    // (undocumented)
    Terabytes = "Terabytes"
}

// @public
export const enum KnownLongTermRetentionDatabaseState {
    // (undocumented)
    All = "All",
    // (undocumented)
    Deleted = "Deleted",
    // (undocumented)
    Live = "Live"
}

// @public
export const enum KnownLongTermRetentionPolicyName {
    // (undocumented)
    Default = "default"
}

// @public
export const enum KnownManagedDatabaseCreateMode {
    // (undocumented)
    Default = "Default",
    // (undocumented)
    PointInTimeRestore = "PointInTimeRestore",
    // (undocumented)
    Recovery = "Recovery",
    // (undocumented)
    RestoreExternalBackup = "RestoreExternalBackup",
    // (undocumented)
    RestoreLongTermRetentionBackup = "RestoreLongTermRetentionBackup"
}

// @public
export const enum KnownManagedDatabaseStatus {
    // (undocumented)
    Creating = "Creating",
    // (undocumented)
    Inaccessible = "Inaccessible",
    // (undocumented)
    Offline = "Offline",
    // (undocumented)
    Online = "Online",
    // (undocumented)
    Restoring = "Restoring",
    // (undocumented)
    Shutdown = "Shutdown",
    // (undocumented)
    Updating = "Updating"
}

// @public
export const enum KnownManagedInstanceAdministratorType {
    // (undocumented)
    ActiveDirectory = "ActiveDirectory"
}

// @public
export const enum KnownManagedInstanceLicenseType {
    // (undocumented)
    BasePrice = "BasePrice",
    // (undocumented)
    LicenseIncluded = "LicenseIncluded"
}

// @public
export const enum KnownManagedInstanceLongTermRetentionPolicyName {
    // (undocumented)
    Default = "default"
}

// @public
export const enum KnownManagedInstanceProxyOverride {
    // (undocumented)
    Default = "Default",
    // (undocumented)
    Proxy = "Proxy",
    // (undocumented)
    Redirect = "Redirect"
}

// @public
export const enum KnownManagedServerCreateMode {
    // (undocumented)
    Default = "Default",
    // (undocumented)
    PointInTimeRestore = "PointInTimeRestore"
}

// @public
export const enum KnownManagedShortTermRetentionPolicyName {
    // (undocumented)
    Default = "default"
}

// @public
export const enum KnownManagementOperationState {
    // (undocumented)
    CancelInProgress = "CancelInProgress",
    // (undocumented)
    Cancelled = "Cancelled",
    // (undocumented)
    Failed = "Failed",
    // (undocumented)
    InProgress = "InProgress",
    // (undocumented)
    Pending = "Pending",
    // (undocumented)
    Succeeded = "Succeeded"
}

// @public
export const enum KnownMaxSizeUnit {
    // (undocumented)
    Gigabytes = "Gigabytes",
    // (undocumented)
    Megabytes = "Megabytes",
    // (undocumented)
    Petabytes = "Petabytes",
    // (undocumented)
    Terabytes = "Terabytes"
}

// @public
export const enum KnownOperationOrigin {
    // (undocumented)
    System = "system",
    // (undocumented)
    User = "user"
}

// @public
export const enum KnownPauseDelayTimeUnit {
    // (undocumented)
    Minutes = "Minutes"
}

// @public
export const enum KnownPerformanceLevelUnit {
    // (undocumented)
    DTU = "DTU",
    // (undocumented)
    VCores = "VCores"
}

// @public
export const enum KnownPrimaryAggregationType {
    // (undocumented)
    Average = "Average",
    // (undocumented)
    Count = "Count",
    // (undocumented)
    Maximum = "Maximum",
    // (undocumented)
    Minimum = "Minimum",
    // (undocumented)
    None = "None",
    // (undocumented)
    Total = "Total"
}

// @public
export const enum KnownPrivateEndpointProvisioningState {
    // (undocumented)
    Approving = "Approving",
    // (undocumented)
    Dropping = "Dropping",
    // (undocumented)
    Failed = "Failed",
    // (undocumented)
    Ready = "Ready",
    // (undocumented)
    Rejecting = "Rejecting"
}

// @public
export const enum KnownPrivateLinkServiceConnectionStateActionsRequire {
    // (undocumented)
    None = "None"
}

// @public
export const enum KnownPrivateLinkServiceConnectionStateStatus {
    // (undocumented)
    Approved = "Approved",
    // (undocumented)
    Disconnected = "Disconnected",
    // (undocumented)
    Pending = "Pending",
    // (undocumented)
    Rejected = "Rejected"
}

// @public
export const enum KnownProvisioningState {
    // (undocumented)
    Canceled = "Canceled",
    // (undocumented)
    Created = "Created",
    // (undocumented)
    Failed = "Failed",
    // (undocumented)
    InProgress = "InProgress",
    // (undocumented)
    Succeeded = "Succeeded"
}

// @public
export const enum KnownReadOnlyEndpointFailoverPolicy {
    // (undocumented)
    Disabled = "Disabled",
    // (undocumented)
    Enabled = "Enabled"
}

// @public
export const enum KnownReadWriteEndpointFailoverPolicy {
    // (undocumented)
    Automatic = "Automatic",
    // (undocumented)
    Manual = "Manual"
}

// @public
export const enum KnownReplicationState {
    // (undocumented)
    CatchUP = "CATCH_UP",
    // (undocumented)
    Pending = "PENDING",
    // (undocumented)
    Seeding = "SEEDING",
    // (undocumented)
    Suspended = "SUSPENDED"
}

// @public
export const enum KnownReplicaType {
    // (undocumented)
    Primary = "Primary",
    // (undocumented)
    ReadableSecondary = "ReadableSecondary"
}

// @public
export const enum KnownRestoreDetailsName {
    // (undocumented)
    Default = "Default"
}

// @public
export const enum KnownSampleName {
    // (undocumented)
    AdventureWorksLT = "AdventureWorksLT",
    // (undocumented)
    WideWorldImportersFull = "WideWorldImportersFull",
    // (undocumented)
    WideWorldImportersStd = "WideWorldImportersStd"
}

// @public
export const enum KnownSecurityAlertPolicyName {
    // (undocumented)
    Default = "default"
}

// @public
export const enum KnownSecurityAlertPolicyNameAutoGenerated {
    // (undocumented)
    Default = "Default"
}

// @public
export const enum KnownServerKeyType {
    // (undocumented)
    AzureKeyVault = "AzureKeyVault",
    // (undocumented)
    ServiceManaged = "ServiceManaged"
}

// @public
export const enum KnownServerPublicNetworkAccess {
    // (undocumented)
    Disabled = "Disabled",
    // (undocumented)
    Enabled = "Enabled"
}

// @public
export const enum KnownServiceObjectiveName {
    // (undocumented)
    Basic = "Basic",
    // (undocumented)
    DS100 = "DS100",
    // (undocumented)
    DS1000 = "DS1000",
    // (undocumented)
    DS1200 = "DS1200",
    // (undocumented)
    DS1500 = "DS1500",
    // (undocumented)
    DS200 = "DS200",
    // (undocumented)
    DS2000 = "DS2000",
    // (undocumented)
    DS300 = "DS300",
    // (undocumented)
    DS400 = "DS400",
    // (undocumented)
    DS500 = "DS500",
    // (undocumented)
    DS600 = "DS600",
    // (undocumented)
    DW100 = "DW100",
    // (undocumented)
    DW1000 = "DW1000",
    // (undocumented)
    DW10000C = "DW10000c",
    // (undocumented)
    DW1000C = "DW1000c",
    // (undocumented)
    DW1200 = "DW1200",
    // (undocumented)
    DW1500 = "DW1500",
    // (undocumented)
    DW15000C = "DW15000c",
    // (undocumented)
    DW1500C = "DW1500c",
    // (undocumented)
    DW200 = "DW200",
    // (undocumented)
    DW2000 = "DW2000",
    // (undocumented)
    DW2000C = "DW2000c",
    // (undocumented)
    DW2500C = "DW2500c",
    // (undocumented)
    DW300 = "DW300",
    // (undocumented)
    DW3000 = "DW3000",
    // (undocumented)
    DW30000C = "DW30000c",
    // (undocumented)
    DW3000C = "DW3000c",
    // (undocumented)
    DW400 = "DW400",
    // (undocumented)
    DW500 = "DW500",
    // (undocumented)
    DW5000C = "DW5000c",
    // (undocumented)
    DW600 = "DW600",
    // (undocumented)
    DW6000 = "DW6000",
    // (undocumented)
    DW6000C = "DW6000c",
    // (undocumented)
    DW7500C = "DW7500c",
    // (undocumented)
    ElasticPool = "ElasticPool",
    // (undocumented)
    Free = "Free",
    // (undocumented)
    P1 = "P1",
    // (undocumented)
    P11 = "P11",
    // (undocumented)
    P15 = "P15",
    // (undocumented)
    P2 = "P2",
    // (undocumented)
    P3 = "P3",
    // (undocumented)
    P4 = "P4",
    // (undocumented)
    P6 = "P6",
    // (undocumented)
    PRS1 = "PRS1",
    // (undocumented)
    PRS2 = "PRS2",
    // (undocumented)
    PRS4 = "PRS4",
    // (undocumented)
    PRS6 = "PRS6",
    // (undocumented)
    S0 = "S0",
    // (undocumented)
    S1 = "S1",
    // (undocumented)
    S12 = "S12",
    // (undocumented)
    S2 = "S2",
    // (undocumented)
    S3 = "S3",
    // (undocumented)
    S4 = "S4",
    // (undocumented)
    S6 = "S6",
    // (undocumented)
    S7 = "S7",
    // (undocumented)
    S9 = "S9",
    // (undocumented)
    System = "System",
    // (undocumented)
    System0 = "System0",
    // (undocumented)
    System1 = "System1",
    // (undocumented)
    System2 = "System2",
    // (undocumented)
    System2L = "System2L",
    // (undocumented)
    System3 = "System3",
    // (undocumented)
    System3L = "System3L",
    // (undocumented)
    System4 = "System4",
    // (undocumented)
    System4L = "System4L"
}

// @public
export const enum KnownShortTermRetentionPolicyName {
    // (undocumented)
    Default = "default"
}

// @public
export const enum KnownStorageCapabilityStorageAccountType {
    // (undocumented)
    GRS = "GRS",
    // (undocumented)
    LRS = "LRS",
    // (undocumented)
    ZRS = "ZRS"
}

// @public
export const enum KnownSyncAgentState {
    // (undocumented)
    NeverConnected = "NeverConnected",
    // (undocumented)
    Offline = "Offline",
    // (undocumented)
    Online = "Online"
}

// @public
export const enum KnownSyncConflictResolutionPolicy {
    // (undocumented)
    HubWin = "HubWin",
    // (undocumented)
    MemberWin = "MemberWin"
}

// @public
export const enum KnownSyncDirection {
    // (undocumented)
    Bidirectional = "Bidirectional",
    // (undocumented)
    OneWayHubToMember = "OneWayHubToMember",
    // (undocumented)
    OneWayMemberToHub = "OneWayMemberToHub"
}

// @public
export const enum KnownSyncGroupLogType {
    // (undocumented)
    All = "All",
    // (undocumented)
    Error = "Error",
    // (undocumented)
    Success = "Success",
    // (undocumented)
    Warning = "Warning"
}

// @public
export const enum KnownSyncGroupState {
    // (undocumented)
    Error = "Error",
    // (undocumented)
    Good = "Good",
    // (undocumented)
    NotReady = "NotReady",
    // (undocumented)
    Progressing = "Progressing",
    // (undocumented)
    Warning = "Warning"
}

// @public
export const enum KnownSyncMemberDbType {
    // (undocumented)
    AzureSqlDatabase = "AzureSqlDatabase",
    // (undocumented)
    SqlServerDatabase = "SqlServerDatabase"
}

// @public
export const enum KnownSyncMemberState {
    // (undocumented)
    DeProvisioned = "DeProvisioned",
    // (undocumented)
    DeProvisionFailed = "DeProvisionFailed",
    // (undocumented)
    DeProvisioning = "DeProvisioning",
    // (undocumented)
    DisabledBackupRestore = "DisabledBackupRestore",
    // (undocumented)
    DisabledTombstoneCleanup = "DisabledTombstoneCleanup",
    // (undocumented)
    Provisioned = "Provisioned",
    // (undocumented)
    ProvisionFailed = "ProvisionFailed",
    // (undocumented)
    Provisioning = "Provisioning",
    // (undocumented)
    ReprovisionFailed = "ReprovisionFailed",
    // (undocumented)
    Reprovisioning = "Reprovisioning",
    // (undocumented)
    SyncCancelled = "SyncCancelled",
    // (undocumented)
    SyncCancelling = "SyncCancelling",
    // (undocumented)
    SyncFailed = "SyncFailed",
    // (undocumented)
    SyncInProgress = "SyncInProgress",
    // (undocumented)
    SyncSucceeded = "SyncSucceeded",
    // (undocumented)
    SyncSucceededWithWarnings = "SyncSucceededWithWarnings",
    // (undocumented)
    UnProvisioned = "UnProvisioned",
    // (undocumented)
    UnReprovisioned = "UnReprovisioned"
}

// @public
export const enum KnownTransparentDataEncryptionActivityStatus {
    // (undocumented)
    Decrypting = "Decrypting",
    // (undocumented)
    Encrypting = "Encrypting"
}

// @public
export const enum KnownTransparentDataEncryptionName {
    // (undocumented)
    Current = "current"
}

// @public
export const enum KnownUnitDefinitionType {
    // (undocumented)
    Bytes = "Bytes",
    // (undocumented)
    BytesPerSecond = "BytesPerSecond",
    // (undocumented)
    Count = "Count",
    // (undocumented)
    CountPerSecond = "CountPerSecond",
    // (undocumented)
    Percent = "Percent",
    // (undocumented)
    Seconds = "Seconds"
}

// @public
export const enum KnownUnitType {
    // (undocumented)
    Bytes = "bytes",
    // (undocumented)
    BytesPerSecond = "bytesPerSecond",
    // (undocumented)
    Count = "count",
    // (undocumented)
    CountPerSecond = "countPerSecond",
    // (undocumented)
    Percent = "percent",
    // (undocumented)
    Seconds = "seconds"
}

// @public
export const enum KnownVirtualNetworkRuleState {
    // (undocumented)
    Deleting = "Deleting",
    // (undocumented)
    Initializing = "Initializing",
    // (undocumented)
    InProgress = "InProgress",
    // (undocumented)
    Ready = "Ready",
    // (undocumented)
    Unknown = "Unknown"
}

// @public
export const enum KnownVulnerabilityAssessmentName {
    // (undocumented)
    Default = "default"
}

// @public
export const enum KnownVulnerabilityAssessmentScanState {
    // (undocumented)
    Failed = "Failed",
    // (undocumented)
    FailedToRun = "FailedToRun",
    // (undocumented)
    InProgress = "InProgress",
    // (undocumented)
    Passed = "Passed"
}

// @public
export const enum KnownVulnerabilityAssessmentScanTriggerType {
    // (undocumented)
    OnDemand = "OnDemand",
    // (undocumented)
    Recurring = "Recurring"
}

// @public
export interface LicenseTypeCapability {
    readonly name?: string;
    reason?: string;
    readonly status?: CapabilityStatus;
}

// @public
export interface LocationCapabilities {
    readonly name?: string;
    reason?: string;
    readonly status?: CapabilityStatus;
    readonly supportedManagedInstanceVersions?: ManagedInstanceVersionCapability[];
    readonly supportedServerVersions?: ServerVersionCapability[];
}

// @public
export interface LogicalServerSecurityAlertPolicyListResult {
    readonly nextLink?: string;
    readonly value?: ServerSecurityAlertPolicy[];
}

// @public
export interface LogSizeCapability {
    readonly limit?: number;
    readonly unit?: LogSizeUnit;
}

// @public
export type LogSizeUnit = string;

// @public
export type LongTermRetentionBackup = ProxyResource & {
    readonly serverName?: string;
    readonly serverCreateTime?: Date;
    readonly databaseName?: string;
    readonly databaseDeletionTime?: Date;
    readonly backupTime?: Date;
    readonly backupExpirationTime?: Date;
};

// @public
export interface LongTermRetentionBackupListResult {
    readonly nextLink?: string;
    readonly value?: LongTermRetentionBackup[];
}

// @public
export interface LongTermRetentionBackups {
    delete(locationName: string, longTermRetentionServerName: string, longTermRetentionDatabaseName: string, backupName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    deleteByResourceGroup(resourceGroupName: string, locationName: string, longTermRetentionServerName: string, longTermRetentionDatabaseName: string, backupName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    get(locationName: string, longTermRetentionServerName: string, longTermRetentionDatabaseName: string, backupName: string, options?: coreHttp.OperationOptions): Promise<LongTermRetentionBackupsGetResponse>;
    getByResourceGroup(resourceGroupName: string, locationName: string, longTermRetentionServerName: string, longTermRetentionDatabaseName: string, backupName: string, options?: coreHttp.OperationOptions): Promise<LongTermRetentionBackupsGetByResourceGroupResponse>;
    listByDatabase(locationName: string, longTermRetentionServerName: string, longTermRetentionDatabaseName: string, options?: LongTermRetentionBackupsListByDatabaseOptionalParams): PagedAsyncIterableIterator<LongTermRetentionBackup>;
    listByLocation(locationName: string, options?: LongTermRetentionBackupsListByLocationOptionalParams): PagedAsyncIterableIterator<LongTermRetentionBackup>;
    listByResourceGroupDatabase(resourceGroupName: string, locationName: string, longTermRetentionServerName: string, longTermRetentionDatabaseName: string, options?: LongTermRetentionBackupsListByResourceGroupDatabaseOptionalParams): PagedAsyncIterableIterator<LongTermRetentionBackup>;
    listByResourceGroupLocation(resourceGroupName: string, locationName: string, options?: LongTermRetentionBackupsListByResourceGroupLocationOptionalParams): PagedAsyncIterableIterator<LongTermRetentionBackup>;
    listByResourceGroupServer(resourceGroupName: string, locationName: string, longTermRetentionServerName: string, options?: LongTermRetentionBackupsListByResourceGroupServerOptionalParams): PagedAsyncIterableIterator<LongTermRetentionBackup>;
    listByServer(locationName: string, longTermRetentionServerName: string, options?: LongTermRetentionBackupsListByServerOptionalParams): PagedAsyncIterableIterator<LongTermRetentionBackup>;
}

// @public
export type LongTermRetentionBackupsGetByResourceGroupResponse = LongTermRetentionBackup & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: LongTermRetentionBackup;
    };
};

// @public
export type LongTermRetentionBackupsGetResponse = LongTermRetentionBackup & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: LongTermRetentionBackup;
    };
};

// @public
export interface LongTermRetentionBackupsListByDatabaseNextOptionalParams extends coreHttp.OperationOptions {
    databaseState?: LongTermRetentionDatabaseState;
    onlyLatestPerDatabase?: boolean;
}

// @public
export type LongTermRetentionBackupsListByDatabaseNextResponse = LongTermRetentionBackupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: LongTermRetentionBackupListResult;
    };
};

// @public
export interface LongTermRetentionBackupsListByDatabaseOptionalParams extends coreHttp.OperationOptions {
    databaseState?: LongTermRetentionDatabaseState;
    onlyLatestPerDatabase?: boolean;
}

// @public
export type LongTermRetentionBackupsListByDatabaseResponse = LongTermRetentionBackupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: LongTermRetentionBackupListResult;
    };
};

// @public
export interface LongTermRetentionBackupsListByLocationNextOptionalParams extends coreHttp.OperationOptions {
    databaseState?: LongTermRetentionDatabaseState;
    onlyLatestPerDatabase?: boolean;
}

// @public
export type LongTermRetentionBackupsListByLocationNextResponse = LongTermRetentionBackupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: LongTermRetentionBackupListResult;
    };
};

// @public
export interface LongTermRetentionBackupsListByLocationOptionalParams extends coreHttp.OperationOptions {
    databaseState?: LongTermRetentionDatabaseState;
    onlyLatestPerDatabase?: boolean;
}

// @public
export type LongTermRetentionBackupsListByLocationResponse = LongTermRetentionBackupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: LongTermRetentionBackupListResult;
    };
};

// @public
export interface LongTermRetentionBackupsListByResourceGroupDatabaseNextOptionalParams extends coreHttp.OperationOptions {
    databaseState?: LongTermRetentionDatabaseState;
    onlyLatestPerDatabase?: boolean;
}

// @public
export type LongTermRetentionBackupsListByResourceGroupDatabaseNextResponse = LongTermRetentionBackupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: LongTermRetentionBackupListResult;
    };
};

// @public
export interface LongTermRetentionBackupsListByResourceGroupDatabaseOptionalParams extends coreHttp.OperationOptions {
    databaseState?: LongTermRetentionDatabaseState;
    onlyLatestPerDatabase?: boolean;
}

// @public
export type LongTermRetentionBackupsListByResourceGroupDatabaseResponse = LongTermRetentionBackupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: LongTermRetentionBackupListResult;
    };
};

// @public
export interface LongTermRetentionBackupsListByResourceGroupLocationNextOptionalParams extends coreHttp.OperationOptions {
    databaseState?: LongTermRetentionDatabaseState;
    onlyLatestPerDatabase?: boolean;
}

// @public
export type LongTermRetentionBackupsListByResourceGroupLocationNextResponse = LongTermRetentionBackupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: LongTermRetentionBackupListResult;
    };
};

// @public
export interface LongTermRetentionBackupsListByResourceGroupLocationOptionalParams extends coreHttp.OperationOptions {
    databaseState?: LongTermRetentionDatabaseState;
    onlyLatestPerDatabase?: boolean;
}

// @public
export type LongTermRetentionBackupsListByResourceGroupLocationResponse = LongTermRetentionBackupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: LongTermRetentionBackupListResult;
    };
};

// @public
export interface LongTermRetentionBackupsListByResourceGroupServerNextOptionalParams extends coreHttp.OperationOptions {
    databaseState?: LongTermRetentionDatabaseState;
    onlyLatestPerDatabase?: boolean;
}

// @public
export type LongTermRetentionBackupsListByResourceGroupServerNextResponse = LongTermRetentionBackupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: LongTermRetentionBackupListResult;
    };
};

// @public
export interface LongTermRetentionBackupsListByResourceGroupServerOptionalParams extends coreHttp.OperationOptions {
    databaseState?: LongTermRetentionDatabaseState;
    onlyLatestPerDatabase?: boolean;
}

// @public
export type LongTermRetentionBackupsListByResourceGroupServerResponse = LongTermRetentionBackupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: LongTermRetentionBackupListResult;
    };
};

// @public
export interface LongTermRetentionBackupsListByServerNextOptionalParams extends coreHttp.OperationOptions {
    databaseState?: LongTermRetentionDatabaseState;
    onlyLatestPerDatabase?: boolean;
}

// @public
export type LongTermRetentionBackupsListByServerNextResponse = LongTermRetentionBackupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: LongTermRetentionBackupListResult;
    };
};

// @public
export interface LongTermRetentionBackupsListByServerOptionalParams extends coreHttp.OperationOptions {
    databaseState?: LongTermRetentionDatabaseState;
    onlyLatestPerDatabase?: boolean;
}

// @public
export type LongTermRetentionBackupsListByServerResponse = LongTermRetentionBackupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: LongTermRetentionBackupListResult;
    };
};

// @public
export type LongTermRetentionDatabaseState = string;

// @public
export interface LongTermRetentionManagedInstanceBackups {
    delete(locationName: string, managedInstanceName: string, databaseName: string, backupName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    deleteByResourceGroup(resourceGroupName: string, locationName: string, managedInstanceName: string, databaseName: string, backupName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    get(locationName: string, managedInstanceName: string, databaseName: string, backupName: string, options?: coreHttp.OperationOptions): Promise<LongTermRetentionManagedInstanceBackupsGetResponse>;
    getByResourceGroup(resourceGroupName: string, locationName: string, managedInstanceName: string, databaseName: string, backupName: string, options?: coreHttp.OperationOptions): Promise<LongTermRetentionManagedInstanceBackupsGetByResourceGroupResponse>;
    listByDatabase(locationName: string, managedInstanceName: string, databaseName: string, options?: LongTermRetentionManagedInstanceBackupsListByDatabaseOptionalParams): PagedAsyncIterableIterator<ManagedInstanceLongTermRetentionBackup>;
    listByInstance(locationName: string, managedInstanceName: string, options?: LongTermRetentionManagedInstanceBackupsListByInstanceOptionalParams): PagedAsyncIterableIterator<ManagedInstanceLongTermRetentionBackup>;
    listByLocation(locationName: string, options?: LongTermRetentionManagedInstanceBackupsListByLocationOptionalParams): PagedAsyncIterableIterator<ManagedInstanceLongTermRetentionBackup>;
    listByResourceGroupDatabase(resourceGroupName: string, locationName: string, managedInstanceName: string, databaseName: string, options?: LongTermRetentionManagedInstanceBackupsListByResourceGroupDatabaseOptionalParams): PagedAsyncIterableIterator<ManagedInstanceLongTermRetentionBackup>;
    listByResourceGroupInstance(resourceGroupName: string, locationName: string, managedInstanceName: string, options?: LongTermRetentionManagedInstanceBackupsListByResourceGroupInstanceOptionalParams): PagedAsyncIterableIterator<ManagedInstanceLongTermRetentionBackup>;
    listByResourceGroupLocation(resourceGroupName: string, locationName: string, options?: LongTermRetentionManagedInstanceBackupsListByResourceGroupLocationOptionalParams): PagedAsyncIterableIterator<ManagedInstanceLongTermRetentionBackup>;
}

// @public
export type LongTermRetentionManagedInstanceBackupsGetByResourceGroupResponse = ManagedInstanceLongTermRetentionBackup & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceLongTermRetentionBackup;
    };
};

// @public
export type LongTermRetentionManagedInstanceBackupsGetResponse = ManagedInstanceLongTermRetentionBackup & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceLongTermRetentionBackup;
    };
};

// @public
export interface LongTermRetentionManagedInstanceBackupsListByDatabaseNextOptionalParams extends coreHttp.OperationOptions {
    databaseState?: DatabaseState;
    onlyLatestPerDatabase?: boolean;
}

// @public
export type LongTermRetentionManagedInstanceBackupsListByDatabaseNextResponse = ManagedInstanceLongTermRetentionBackupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceLongTermRetentionBackupListResult;
    };
};

// @public
export interface LongTermRetentionManagedInstanceBackupsListByDatabaseOptionalParams extends coreHttp.OperationOptions {
    databaseState?: DatabaseState;
    onlyLatestPerDatabase?: boolean;
}

// @public
export type LongTermRetentionManagedInstanceBackupsListByDatabaseResponse = ManagedInstanceLongTermRetentionBackupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceLongTermRetentionBackupListResult;
    };
};

// @public
export interface LongTermRetentionManagedInstanceBackupsListByInstanceNextOptionalParams extends coreHttp.OperationOptions {
    databaseState?: DatabaseState;
    onlyLatestPerDatabase?: boolean;
}

// @public
export type LongTermRetentionManagedInstanceBackupsListByInstanceNextResponse = ManagedInstanceLongTermRetentionBackupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceLongTermRetentionBackupListResult;
    };
};

// @public
export interface LongTermRetentionManagedInstanceBackupsListByInstanceOptionalParams extends coreHttp.OperationOptions {
    databaseState?: DatabaseState;
    onlyLatestPerDatabase?: boolean;
}

// @public
export type LongTermRetentionManagedInstanceBackupsListByInstanceResponse = ManagedInstanceLongTermRetentionBackupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceLongTermRetentionBackupListResult;
    };
};

// @public
export interface LongTermRetentionManagedInstanceBackupsListByLocationNextOptionalParams extends coreHttp.OperationOptions {
    databaseState?: DatabaseState;
    onlyLatestPerDatabase?: boolean;
}

// @public
export type LongTermRetentionManagedInstanceBackupsListByLocationNextResponse = ManagedInstanceLongTermRetentionBackupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceLongTermRetentionBackupListResult;
    };
};

// @public
export interface LongTermRetentionManagedInstanceBackupsListByLocationOptionalParams extends coreHttp.OperationOptions {
    databaseState?: DatabaseState;
    onlyLatestPerDatabase?: boolean;
}

// @public
export type LongTermRetentionManagedInstanceBackupsListByLocationResponse = ManagedInstanceLongTermRetentionBackupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceLongTermRetentionBackupListResult;
    };
};

// @public
export interface LongTermRetentionManagedInstanceBackupsListByResourceGroupDatabaseNextOptionalParams extends coreHttp.OperationOptions {
    databaseState?: DatabaseState;
    onlyLatestPerDatabase?: boolean;
}

// @public
export type LongTermRetentionManagedInstanceBackupsListByResourceGroupDatabaseNextResponse = ManagedInstanceLongTermRetentionBackupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceLongTermRetentionBackupListResult;
    };
};

// @public
export interface LongTermRetentionManagedInstanceBackupsListByResourceGroupDatabaseOptionalParams extends coreHttp.OperationOptions {
    databaseState?: DatabaseState;
    onlyLatestPerDatabase?: boolean;
}

// @public
export type LongTermRetentionManagedInstanceBackupsListByResourceGroupDatabaseResponse = ManagedInstanceLongTermRetentionBackupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceLongTermRetentionBackupListResult;
    };
};

// @public
export interface LongTermRetentionManagedInstanceBackupsListByResourceGroupInstanceNextOptionalParams extends coreHttp.OperationOptions {
    databaseState?: DatabaseState;
    onlyLatestPerDatabase?: boolean;
}

// @public
export type LongTermRetentionManagedInstanceBackupsListByResourceGroupInstanceNextResponse = ManagedInstanceLongTermRetentionBackupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceLongTermRetentionBackupListResult;
    };
};

// @public
export interface LongTermRetentionManagedInstanceBackupsListByResourceGroupInstanceOptionalParams extends coreHttp.OperationOptions {
    databaseState?: DatabaseState;
    onlyLatestPerDatabase?: boolean;
}

// @public
export type LongTermRetentionManagedInstanceBackupsListByResourceGroupInstanceResponse = ManagedInstanceLongTermRetentionBackupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceLongTermRetentionBackupListResult;
    };
};

// @public
export interface LongTermRetentionManagedInstanceBackupsListByResourceGroupLocationNextOptionalParams extends coreHttp.OperationOptions {
    databaseState?: DatabaseState;
    onlyLatestPerDatabase?: boolean;
}

// @public
export type LongTermRetentionManagedInstanceBackupsListByResourceGroupLocationNextResponse = ManagedInstanceLongTermRetentionBackupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceLongTermRetentionBackupListResult;
    };
};

// @public
export interface LongTermRetentionManagedInstanceBackupsListByResourceGroupLocationOptionalParams extends coreHttp.OperationOptions {
    databaseState?: DatabaseState;
    onlyLatestPerDatabase?: boolean;
}

// @public
export type LongTermRetentionManagedInstanceBackupsListByResourceGroupLocationResponse = ManagedInstanceLongTermRetentionBackupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceLongTermRetentionBackupListResult;
    };
};

// @public
export type LongTermRetentionPolicyName = string;

// Warning: (ae-forgotten-export) The symbol "BaseResult" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export interface LROOperationState<TResult extends BaseResult> extends PollOperationState<TResult> {
    // Warning: (ae-forgotten-export) The symbol "FinalStateVia" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    finalStateVia?: FinalStateVia;
    // (undocumented)
    initialOperation: LROOperationStep<TResult>;
    // Warning: (ae-forgotten-export) The symbol "LROOperationStep" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    lastOperation: LROOperationStep<TResult>;
    // Warning: (ae-forgotten-export) The symbol "LROStrategy" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    pollingStrategy: LROStrategy<TResult>;
}

// @public
export interface ManagedBackupShortTermRetentionPolicies {
    createOrUpdate(resourceGroupName: string, managedInstanceName: string, databaseName: string, policyName: ManagedShortTermRetentionPolicyName, parameters: ManagedBackupShortTermRetentionPolicy, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<ManagedBackupShortTermRetentionPoliciesCreateOrUpdateResponse>, ManagedBackupShortTermRetentionPoliciesCreateOrUpdateResponse>>;
    get(resourceGroupName: string, managedInstanceName: string, databaseName: string, policyName: ManagedShortTermRetentionPolicyName, options?: coreHttp.OperationOptions): Promise<ManagedBackupShortTermRetentionPoliciesGetResponse>;
    listByDatabase(resourceGroupName: string, managedInstanceName: string, databaseName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<ManagedBackupShortTermRetentionPolicy>;
    update(resourceGroupName: string, managedInstanceName: string, databaseName: string, policyName: ManagedShortTermRetentionPolicyName, parameters: ManagedBackupShortTermRetentionPolicy, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<ManagedBackupShortTermRetentionPoliciesUpdateResponse>, ManagedBackupShortTermRetentionPoliciesUpdateResponse>>;
}

// @public
export type ManagedBackupShortTermRetentionPoliciesCreateOrUpdateResponse = ManagedBackupShortTermRetentionPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedBackupShortTermRetentionPolicy;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type ManagedBackupShortTermRetentionPoliciesGetResponse = ManagedBackupShortTermRetentionPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedBackupShortTermRetentionPolicy;
    };
};

// @public
export type ManagedBackupShortTermRetentionPoliciesListByDatabaseNextResponse = ManagedBackupShortTermRetentionPolicyListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedBackupShortTermRetentionPolicyListResult;
    };
};

// @public
export type ManagedBackupShortTermRetentionPoliciesListByDatabaseResponse = ManagedBackupShortTermRetentionPolicyListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedBackupShortTermRetentionPolicyListResult;
    };
};

// @public
export type ManagedBackupShortTermRetentionPoliciesUpdateResponse = ManagedBackupShortTermRetentionPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedBackupShortTermRetentionPolicy;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type ManagedBackupShortTermRetentionPolicy = ProxyResource & {
    retentionDays?: number;
};

// @public
export interface ManagedBackupShortTermRetentionPolicyListResult {
    readonly nextLink?: string;
    readonly value?: ManagedBackupShortTermRetentionPolicy[];
}

// @public
export type ManagedDatabase = TrackedResource & {
    collation?: string;
    readonly status?: ManagedDatabaseStatus;
    readonly creationDate?: Date;
    readonly earliestRestorePoint?: Date;
    restorePointInTime?: Date;
    readonly defaultSecondaryLocation?: string;
    catalogCollation?: CatalogCollationType;
    createMode?: ManagedDatabaseCreateMode;
    storageContainerUri?: string;
    sourceDatabaseId?: string;
    restorableDroppedDatabaseId?: string;
    storageContainerSasToken?: string;
    readonly failoverGroupId?: string;
    recoverableDatabaseId?: string;
    longTermRetentionBackupResourceId?: string;
};

// @public
export type ManagedDatabaseCreateMode = string;

// @public
export interface ManagedDatabaseListResult {
    readonly nextLink?: string;
    readonly value?: ManagedDatabase[];
}

// @public
export interface ManagedDatabaseRestoreDetails {
    get(resourceGroupName: string, managedInstanceName: string, databaseName: string, restoreDetailsName: RestoreDetailsName, options?: coreHttp.OperationOptions): Promise<ManagedDatabaseRestoreDetailsGetResponse>;
}

// @public
export type ManagedDatabaseRestoreDetailsGetResponse = ManagedDatabaseRestoreDetailsResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedDatabaseRestoreDetailsResult;
    };
};

// @public
export type ManagedDatabaseRestoreDetailsResult = ProxyResource & {
    readonly status?: string;
    readonly currentRestoringFileName?: string;
    readonly lastRestoredFileName?: string;
    readonly lastRestoredFileTime?: Date;
    readonly percentCompleted?: number;
    readonly unrestorableFiles?: string[];
    readonly numberOfFilesDetected?: number;
    readonly lastUploadedFileName?: string;
    readonly lastUploadedFileTime?: Date;
    readonly blockReason?: string;
};

// @public
export interface ManagedDatabases {
    completeRestore(resourceGroupName: string, managedInstanceName: string, databaseName: string, parameters: CompleteDatabaseRestoreDefinition, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    createOrUpdate(resourceGroupName: string, managedInstanceName: string, databaseName: string, parameters: ManagedDatabase, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<ManagedDatabasesCreateOrUpdateResponse>, ManagedDatabasesCreateOrUpdateResponse>>;
    delete(resourceGroupName: string, managedInstanceName: string, databaseName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    get(resourceGroupName: string, managedInstanceName: string, databaseName: string, options?: coreHttp.OperationOptions): Promise<ManagedDatabasesGetResponse>;
    listByInstance(resourceGroupName: string, managedInstanceName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<ManagedDatabase>;
    listInaccessibleByInstance(resourceGroupName: string, managedInstanceName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<ManagedDatabase>;
    update(resourceGroupName: string, managedInstanceName: string, databaseName: string, parameters: ManagedDatabaseUpdate, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<ManagedDatabasesUpdateResponse>, ManagedDatabasesUpdateResponse>>;
}

// @public
export type ManagedDatabasesCreateOrUpdateResponse = ManagedDatabase & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedDatabase;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export interface ManagedDatabaseSecurityAlertPolicies {
    createOrUpdate(resourceGroupName: string, managedInstanceName: string, databaseName: string, securityAlertPolicyName: SecurityAlertPolicyName, parameters: ManagedDatabaseSecurityAlertPolicy, options?: coreHttp.OperationOptions): Promise<ManagedDatabaseSecurityAlertPoliciesCreateOrUpdateResponse>;
    get(resourceGroupName: string, managedInstanceName: string, databaseName: string, securityAlertPolicyName: SecurityAlertPolicyName, options?: coreHttp.OperationOptions): Promise<ManagedDatabaseSecurityAlertPoliciesGetResponse>;
    listByDatabase(resourceGroupName: string, managedInstanceName: string, databaseName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<ManagedDatabaseSecurityAlertPolicy>;
}

// @public
export type ManagedDatabaseSecurityAlertPoliciesCreateOrUpdateResponse = ManagedDatabaseSecurityAlertPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedDatabaseSecurityAlertPolicy;
    };
};

// @public
export type ManagedDatabaseSecurityAlertPoliciesGetResponse = ManagedDatabaseSecurityAlertPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedDatabaseSecurityAlertPolicy;
    };
};

// @public
export type ManagedDatabaseSecurityAlertPoliciesListByDatabaseNextResponse = ManagedDatabaseSecurityAlertPolicyListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedDatabaseSecurityAlertPolicyListResult;
    };
};

// @public
export type ManagedDatabaseSecurityAlertPoliciesListByDatabaseResponse = ManagedDatabaseSecurityAlertPolicyListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedDatabaseSecurityAlertPolicyListResult;
    };
};

// @public
export type ManagedDatabaseSecurityAlertPolicy = ProxyResource & {
    state?: SecurityAlertPolicyState;
    disabledAlerts?: string[];
    emailAddresses?: string[];
    emailAccountAdmins?: boolean;
    storageEndpoint?: string;
    storageAccountAccessKey?: string;
    retentionDays?: number;
    readonly creationTime?: Date;
};

// @public
export interface ManagedDatabaseSecurityAlertPolicyListResult {
    readonly nextLink?: string;
    readonly value?: ManagedDatabaseSecurityAlertPolicy[];
}

// @public
export interface ManagedDatabaseSensitivityLabels {
    createOrUpdate(resourceGroupName: string, managedInstanceName: string, databaseName: string, schemaName: string, tableName: string, columnName: string, parameters: SensitivityLabel, options?: coreHttp.OperationOptions): Promise<ManagedDatabaseSensitivityLabelsCreateOrUpdateResponse>;
    delete(resourceGroupName: string, managedInstanceName: string, databaseName: string, schemaName: string, tableName: string, columnName: string, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    disableRecommendation(resourceGroupName: string, managedInstanceName: string, databaseName: string, schemaName: string, tableName: string, columnName: string, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    enableRecommendation(resourceGroupName: string, managedInstanceName: string, databaseName: string, schemaName: string, tableName: string, columnName: string, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    get(resourceGroupName: string, managedInstanceName: string, databaseName: string, schemaName: string, tableName: string, columnName: string, sensitivityLabelSource: SensitivityLabelSource, options?: coreHttp.OperationOptions): Promise<ManagedDatabaseSensitivityLabelsGetResponse>;
    listCurrentByDatabase(resourceGroupName: string, managedInstanceName: string, databaseName: string, options?: ManagedDatabaseSensitivityLabelsListCurrentByDatabaseOptionalParams): PagedAsyncIterableIterator<SensitivityLabel>;
    listRecommendedByDatabase(resourceGroupName: string, managedInstanceName: string, databaseName: string, options?: ManagedDatabaseSensitivityLabelsListRecommendedByDatabaseOptionalParams): PagedAsyncIterableIterator<SensitivityLabel>;
}

// @public
export type ManagedDatabaseSensitivityLabelsCreateOrUpdateResponse = SensitivityLabel & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SensitivityLabel;
    };
};

// @public
export type ManagedDatabaseSensitivityLabelsGetResponse = SensitivityLabel & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SensitivityLabel;
    };
};

// @public
export interface ManagedDatabaseSensitivityLabelsListCurrentByDatabaseNextOptionalParams extends coreHttp.OperationOptions {
    filter?: string;
}

// @public
export type ManagedDatabaseSensitivityLabelsListCurrentByDatabaseNextResponse = SensitivityLabelListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SensitivityLabelListResult;
    };
};

// @public
export interface ManagedDatabaseSensitivityLabelsListCurrentByDatabaseOptionalParams extends coreHttp.OperationOptions {
    filter?: string;
}

// @public
export type ManagedDatabaseSensitivityLabelsListCurrentByDatabaseResponse = SensitivityLabelListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SensitivityLabelListResult;
    };
};

// @public
export interface ManagedDatabaseSensitivityLabelsListRecommendedByDatabaseNextOptionalParams extends coreHttp.OperationOptions {
    filter?: string;
    includeDisabledRecommendations?: boolean;
    // (undocumented)
    skipToken?: string;
}

// @public
export type ManagedDatabaseSensitivityLabelsListRecommendedByDatabaseNextResponse = SensitivityLabelListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SensitivityLabelListResult;
    };
};

// @public
export interface ManagedDatabaseSensitivityLabelsListRecommendedByDatabaseOptionalParams extends coreHttp.OperationOptions {
    filter?: string;
    includeDisabledRecommendations?: boolean;
    // (undocumented)
    skipToken?: string;
}

// @public
export type ManagedDatabaseSensitivityLabelsListRecommendedByDatabaseResponse = SensitivityLabelListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SensitivityLabelListResult;
    };
};

// @public
export type ManagedDatabasesGetResponse = ManagedDatabase & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedDatabase;
    };
};

// @public
export type ManagedDatabasesListByInstanceNextResponse = ManagedDatabaseListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedDatabaseListResult;
    };
};

// @public
export type ManagedDatabasesListByInstanceResponse = ManagedDatabaseListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedDatabaseListResult;
    };
};

// @public
export type ManagedDatabasesListInaccessibleByInstanceNextResponse = ManagedDatabaseListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedDatabaseListResult;
    };
};

// @public
export type ManagedDatabasesListInaccessibleByInstanceResponse = ManagedDatabaseListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedDatabaseListResult;
    };
};

// @public
export type ManagedDatabaseStatus = string;

// @public
export type ManagedDatabasesUpdateResponse = ManagedDatabase & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedDatabase;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export interface ManagedDatabaseUpdate {
    catalogCollation?: CatalogCollationType;
    collation?: string;
    createMode?: ManagedDatabaseCreateMode;
    readonly creationDate?: Date;
    readonly defaultSecondaryLocation?: string;
    readonly earliestRestorePoint?: Date;
    readonly failoverGroupId?: string;
    longTermRetentionBackupResourceId?: string;
    recoverableDatabaseId?: string;
    restorableDroppedDatabaseId?: string;
    restorePointInTime?: Date;
    sourceDatabaseId?: string;
    readonly status?: ManagedDatabaseStatus;
    storageContainerSasToken?: string;
    storageContainerUri?: string;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export interface ManagedDatabaseVulnerabilityAssessmentRuleBaselines {
    createOrUpdate(resourceGroupName: string, managedInstanceName: string, databaseName: string, vulnerabilityAssessmentName: VulnerabilityAssessmentName, ruleId: string, baselineName: VulnerabilityAssessmentPolicyBaselineName, parameters: DatabaseVulnerabilityAssessmentRuleBaseline, options?: coreHttp.OperationOptions): Promise<ManagedDatabaseVulnerabilityAssessmentRuleBaselinesCreateOrUpdateResponse>;
    delete(resourceGroupName: string, managedInstanceName: string, databaseName: string, vulnerabilityAssessmentName: VulnerabilityAssessmentName, ruleId: string, baselineName: VulnerabilityAssessmentPolicyBaselineName, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    get(resourceGroupName: string, managedInstanceName: string, databaseName: string, vulnerabilityAssessmentName: VulnerabilityAssessmentName, ruleId: string, baselineName: VulnerabilityAssessmentPolicyBaselineName, options?: coreHttp.OperationOptions): Promise<ManagedDatabaseVulnerabilityAssessmentRuleBaselinesGetResponse>;
}

// @public
export type ManagedDatabaseVulnerabilityAssessmentRuleBaselinesCreateOrUpdateResponse = DatabaseVulnerabilityAssessmentRuleBaseline & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DatabaseVulnerabilityAssessmentRuleBaseline;
    };
};

// @public
export type ManagedDatabaseVulnerabilityAssessmentRuleBaselinesGetResponse = DatabaseVulnerabilityAssessmentRuleBaseline & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DatabaseVulnerabilityAssessmentRuleBaseline;
    };
};

// @public
export interface ManagedDatabaseVulnerabilityAssessments {
    createOrUpdate(resourceGroupName: string, managedInstanceName: string, databaseName: string, vulnerabilityAssessmentName: VulnerabilityAssessmentName, parameters: DatabaseVulnerabilityAssessment, options?: coreHttp.OperationOptions): Promise<ManagedDatabaseVulnerabilityAssessmentsCreateOrUpdateResponse>;
    delete(resourceGroupName: string, managedInstanceName: string, databaseName: string, vulnerabilityAssessmentName: VulnerabilityAssessmentName, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    get(resourceGroupName: string, managedInstanceName: string, databaseName: string, vulnerabilityAssessmentName: VulnerabilityAssessmentName, options?: coreHttp.OperationOptions): Promise<ManagedDatabaseVulnerabilityAssessmentsGetResponse>;
    listByDatabase(resourceGroupName: string, managedInstanceName: string, databaseName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<DatabaseVulnerabilityAssessment>;
}

// @public
export interface ManagedDatabaseVulnerabilityAssessmentScans {
    export(resourceGroupName: string, managedInstanceName: string, databaseName: string, vulnerabilityAssessmentName: VulnerabilityAssessmentName, scanId: string, options?: coreHttp.OperationOptions): Promise<ManagedDatabaseVulnerabilityAssessmentScansExportResponse>;
    get(resourceGroupName: string, managedInstanceName: string, databaseName: string, vulnerabilityAssessmentName: VulnerabilityAssessmentName, scanId: string, options?: coreHttp.OperationOptions): Promise<ManagedDatabaseVulnerabilityAssessmentScansGetResponse>;
    initiateScan(resourceGroupName: string, managedInstanceName: string, databaseName: string, vulnerabilityAssessmentName: VulnerabilityAssessmentName, scanId: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    listByDatabase(resourceGroupName: string, managedInstanceName: string, databaseName: string, vulnerabilityAssessmentName: VulnerabilityAssessmentName, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<VulnerabilityAssessmentScanRecord>;
}

// @public
export type ManagedDatabaseVulnerabilityAssessmentScansExportResponse = DatabaseVulnerabilityAssessmentScansExport & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DatabaseVulnerabilityAssessmentScansExport;
    };
};

// @public
export type ManagedDatabaseVulnerabilityAssessmentScansGetResponse = VulnerabilityAssessmentScanRecord & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: VulnerabilityAssessmentScanRecord;
    };
};

// @public
export type ManagedDatabaseVulnerabilityAssessmentScansListByDatabaseNextResponse = VulnerabilityAssessmentScanRecordListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: VulnerabilityAssessmentScanRecordListResult;
    };
};

// @public
export type ManagedDatabaseVulnerabilityAssessmentScansListByDatabaseResponse = VulnerabilityAssessmentScanRecordListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: VulnerabilityAssessmentScanRecordListResult;
    };
};

// @public
export type ManagedDatabaseVulnerabilityAssessmentsCreateOrUpdateResponse = DatabaseVulnerabilityAssessment & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DatabaseVulnerabilityAssessment;
    };
};

// @public
export type ManagedDatabaseVulnerabilityAssessmentsGetResponse = DatabaseVulnerabilityAssessment & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DatabaseVulnerabilityAssessment;
    };
};

// @public
export type ManagedDatabaseVulnerabilityAssessmentsListByDatabaseNextResponse = DatabaseVulnerabilityAssessmentListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DatabaseVulnerabilityAssessmentListResult;
    };
};

// @public
export type ManagedDatabaseVulnerabilityAssessmentsListByDatabaseResponse = DatabaseVulnerabilityAssessmentListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: DatabaseVulnerabilityAssessmentListResult;
    };
};

// @public
export type ManagedInstance = TrackedResource & {
    identity?: ResourceIdentity;
    sku?: Sku;
    managedInstanceCreateMode?: ManagedServerCreateMode;
    readonly fullyQualifiedDomainName?: string;
    administratorLogin?: string;
    administratorLoginPassword?: string;
    subnetId?: string;
    readonly state?: string;
    licenseType?: ManagedInstanceLicenseType;
    vCores?: number;
    storageSizeInGB?: number;
    collation?: string;
    readonly dnsZone?: string;
    dnsZonePartner?: string;
    publicDataEndpointEnabled?: boolean;
    sourceManagedInstanceId?: string;
    restorePointInTime?: Date;
    proxyOverride?: ManagedInstanceProxyOverride;
    timezoneId?: string;
    instancePoolId?: string;
    minimalTlsVersion?: string;
};

// @public
export type ManagedInstanceAdministrator = ProxyResource & {
    administratorType?: ManagedInstanceAdministratorType;
    login?: string;
    sid?: string;
    tenantId?: string;
};

// @public
export interface ManagedInstanceAdministratorListResult {
    readonly nextLink?: string;
    readonly value?: ManagedInstanceAdministrator[];
}

// @public
export interface ManagedInstanceAdministrators {
    createOrUpdate(resourceGroupName: string, managedInstanceName: string, parameters: ManagedInstanceAdministrator, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<ManagedInstanceAdministratorsCreateOrUpdateResponse>, ManagedInstanceAdministratorsCreateOrUpdateResponse>>;
    delete(resourceGroupName: string, managedInstanceName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    get(resourceGroupName: string, managedInstanceName: string, options?: coreHttp.OperationOptions): Promise<ManagedInstanceAdministratorsGetResponse>;
    listByInstance(resourceGroupName: string, managedInstanceName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<ManagedInstanceAdministrator>;
}

// @public
export type ManagedInstanceAdministratorsCreateOrUpdateResponse = ManagedInstanceAdministrator & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceAdministrator;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type ManagedInstanceAdministratorsGetResponse = ManagedInstanceAdministrator & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceAdministrator;
    };
};

// @public
export type ManagedInstanceAdministratorsListByInstanceNextResponse = ManagedInstanceAdministratorListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceAdministratorListResult;
    };
};

// @public
export type ManagedInstanceAdministratorsListByInstanceResponse = ManagedInstanceAdministratorListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceAdministratorListResult;
    };
};

// @public
export type ManagedInstanceAdministratorType = string;

// @public
export interface ManagedInstanceEditionCapability {
    readonly name?: string;
    reason?: string;
    readonly status?: CapabilityStatus;
    readonly supportedFamilies?: ManagedInstanceFamilyCapability[];
}

// @public
export type ManagedInstanceEncryptionProtector = ProxyResource & {
    readonly kind?: string;
    serverKeyName?: string;
    serverKeyType?: ServerKeyType;
    readonly uri?: string;
    readonly thumbprint?: string;
};

// @public
export interface ManagedInstanceEncryptionProtectorListResult {
    readonly nextLink?: string;
    readonly value?: ManagedInstanceEncryptionProtector[];
}

// @public
export interface ManagedInstanceEncryptionProtectors {
    createOrUpdate(resourceGroupName: string, managedInstanceName: string, encryptionProtectorName: EncryptionProtectorName, parameters: ManagedInstanceEncryptionProtector, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<ManagedInstanceEncryptionProtectorsCreateOrUpdateResponse>, ManagedInstanceEncryptionProtectorsCreateOrUpdateResponse>>;
    get(resourceGroupName: string, managedInstanceName: string, encryptionProtectorName: EncryptionProtectorName, options?: coreHttp.OperationOptions): Promise<ManagedInstanceEncryptionProtectorsGetResponse>;
    listByInstance(resourceGroupName: string, managedInstanceName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<ManagedInstanceEncryptionProtector>;
    revalidate(resourceGroupName: string, managedInstanceName: string, encryptionProtectorName: EncryptionProtectorName, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
}

// @public
export type ManagedInstanceEncryptionProtectorsCreateOrUpdateResponse = ManagedInstanceEncryptionProtector & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceEncryptionProtector;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type ManagedInstanceEncryptionProtectorsGetResponse = ManagedInstanceEncryptionProtector & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceEncryptionProtector;
    };
};

// @public
export type ManagedInstanceEncryptionProtectorsListByInstanceNextResponse = ManagedInstanceEncryptionProtectorListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceEncryptionProtectorListResult;
    };
};

// @public
export type ManagedInstanceEncryptionProtectorsListByInstanceResponse = ManagedInstanceEncryptionProtectorListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceEncryptionProtectorListResult;
    };
};

// @public
export interface ManagedInstanceFamilyCapability {
    readonly name?: string;
    reason?: string;
    readonly sku?: string;
    readonly status?: CapabilityStatus;
    readonly supportedLicenseTypes?: LicenseTypeCapability[];
    readonly supportedVcoresValues?: ManagedInstanceVcoresCapability[];
}

// @public
export type ManagedInstanceKey = ProxyResource & {
    readonly kind?: string;
    serverKeyType?: ServerKeyType;
    uri?: string;
    readonly thumbprint?: string;
    readonly creationDate?: Date;
};

// @public
export interface ManagedInstanceKeyListResult {
    readonly nextLink?: string;
    readonly value?: ManagedInstanceKey[];
}

// @public
export interface ManagedInstanceKeys {
    createOrUpdate(resourceGroupName: string, managedInstanceName: string, keyName: string, parameters: ManagedInstanceKey, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<ManagedInstanceKeysCreateOrUpdateResponse>, ManagedInstanceKeysCreateOrUpdateResponse>>;
    delete(resourceGroupName: string, managedInstanceName: string, keyName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    get(resourceGroupName: string, managedInstanceName: string, keyName: string, options?: coreHttp.OperationOptions): Promise<ManagedInstanceKeysGetResponse>;
    listByInstance(resourceGroupName: string, managedInstanceName: string, options?: ManagedInstanceKeysListByInstanceOptionalParams): PagedAsyncIterableIterator<ManagedInstanceKey>;
}

// @public
export type ManagedInstanceKeysCreateOrUpdateResponse = ManagedInstanceKey & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceKey;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type ManagedInstanceKeysGetResponse = ManagedInstanceKey & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceKey;
    };
};

// @public
export interface ManagedInstanceKeysListByInstanceNextOptionalParams extends coreHttp.OperationOptions {
    filter?: string;
}

// @public
export type ManagedInstanceKeysListByInstanceNextResponse = ManagedInstanceKeyListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceKeyListResult;
    };
};

// @public
export interface ManagedInstanceKeysListByInstanceOptionalParams extends coreHttp.OperationOptions {
    filter?: string;
}

// @public
export type ManagedInstanceKeysListByInstanceResponse = ManagedInstanceKeyListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceKeyListResult;
    };
};

// @public
export type ManagedInstanceLicenseType = string;

// @public
export interface ManagedInstanceListResult {
    readonly nextLink?: string;
    readonly value?: ManagedInstance[];
}

// @public
export type ManagedInstanceLongTermRetentionBackup = ProxyResource & {
    readonly managedInstanceName?: string;
    readonly managedInstanceCreateTime?: Date;
    readonly databaseName?: string;
    readonly databaseDeletionTime?: Date;
    readonly backupTime?: Date;
    readonly backupExpirationTime?: Date;
};

// @public
export interface ManagedInstanceLongTermRetentionBackupListResult {
    readonly nextLink?: string;
    readonly value?: ManagedInstanceLongTermRetentionBackup[];
}

// @public
export interface ManagedInstanceLongTermRetentionPolicies {
    createOrUpdate(resourceGroupName: string, managedInstanceName: string, databaseName: string, policyName: ManagedInstanceLongTermRetentionPolicyName, parameters: ManagedInstanceLongTermRetentionPolicy, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<ManagedInstanceLongTermRetentionPoliciesCreateOrUpdateResponse>, ManagedInstanceLongTermRetentionPoliciesCreateOrUpdateResponse>>;
    get(resourceGroupName: string, managedInstanceName: string, databaseName: string, policyName: ManagedInstanceLongTermRetentionPolicyName, options?: coreHttp.OperationOptions): Promise<ManagedInstanceLongTermRetentionPoliciesGetResponse>;
    listByDatabase(resourceGroupName: string, managedInstanceName: string, databaseName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<ManagedInstanceLongTermRetentionPolicy>;
}

// @public
export type ManagedInstanceLongTermRetentionPoliciesCreateOrUpdateResponse = ManagedInstanceLongTermRetentionPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceLongTermRetentionPolicy;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type ManagedInstanceLongTermRetentionPoliciesGetResponse = ManagedInstanceLongTermRetentionPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceLongTermRetentionPolicy;
    };
};

// @public
export type ManagedInstanceLongTermRetentionPoliciesListByDatabaseNextResponse = ManagedInstanceLongTermRetentionPolicyListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceLongTermRetentionPolicyListResult;
    };
};

// @public
export type ManagedInstanceLongTermRetentionPoliciesListByDatabaseResponse = ManagedInstanceLongTermRetentionPolicyListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceLongTermRetentionPolicyListResult;
    };
};

// @public
export type ManagedInstanceLongTermRetentionPolicy = ProxyResource & {
    weeklyRetention?: string;
    monthlyRetention?: string;
    yearlyRetention?: string;
    weekOfYear?: number;
};

// @public
export interface ManagedInstanceLongTermRetentionPolicyListResult {
    readonly nextLink?: string;
    readonly value?: ManagedInstanceLongTermRetentionPolicy[];
}

// @public
export type ManagedInstanceLongTermRetentionPolicyName = string;

// @public
export type ManagedInstanceOperation = ProxyResource & {
    readonly managedInstanceName?: string;
    readonly operation?: string;
    readonly operationFriendlyName?: string;
    readonly percentComplete?: number;
    readonly startTime?: Date;
    readonly state?: ManagementOperationState;
    readonly errorCode?: number;
    readonly errorDescription?: string;
    readonly errorSeverity?: number;
    readonly isUserError?: boolean;
    readonly estimatedCompletionTime?: Date;
    readonly description?: string;
    readonly isCancellable?: boolean;
};

// @public
export interface ManagedInstanceOperationListResult {
    readonly nextLink?: string;
    readonly value?: ManagedInstanceOperation[];
}

// @public
export interface ManagedInstanceOperations {
    cancel(resourceGroupName: string, managedInstanceName: string, operationId: string, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    get(resourceGroupName: string, managedInstanceName: string, operationId: string, options?: coreHttp.OperationOptions): Promise<ManagedInstanceOperationsGetResponse>;
    listByManagedInstance(resourceGroupName: string, managedInstanceName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<ManagedInstanceOperation>;
}

// @public
export type ManagedInstanceOperationsGetResponse = ManagedInstanceOperation & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceOperation;
    };
};

// @public
export type ManagedInstanceOperationsListByManagedInstanceNextResponse = ManagedInstanceOperationListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceOperationListResult;
    };
};

// @public
export type ManagedInstanceOperationsListByManagedInstanceResponse = ManagedInstanceOperationListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceOperationListResult;
    };
};

// @public
export interface ManagedInstancePairInfo {
    partnerManagedInstanceId?: string;
    primaryManagedInstanceId?: string;
}

// @public
export type ManagedInstanceProxyOverride = string;

// @public
export interface ManagedInstances {
    createOrUpdate(resourceGroupName: string, managedInstanceName: string, parameters: ManagedInstance, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<ManagedInstancesCreateOrUpdateResponse>, ManagedInstancesCreateOrUpdateResponse>>;
    delete(resourceGroupName: string, managedInstanceName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    get(resourceGroupName: string, managedInstanceName: string, options?: coreHttp.OperationOptions): Promise<ManagedInstancesGetResponse>;
    list(options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<ManagedInstance>;
    listByInstancePool(resourceGroupName: string, instancePoolName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<ManagedInstance>;
    listByResourceGroup(resourceGroupName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<ManagedInstance>;
    update(resourceGroupName: string, managedInstanceName: string, parameters: ManagedInstanceUpdate, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<ManagedInstancesUpdateResponse>, ManagedInstancesUpdateResponse>>;
}

// @public
export type ManagedInstancesCreateOrUpdateResponse = ManagedInstance & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstance;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type ManagedInstancesGetResponse = ManagedInstance & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstance;
    };
};

// @public
export type ManagedInstancesListByInstancePoolNextResponse = ManagedInstanceListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceListResult;
    };
};

// @public
export type ManagedInstancesListByInstancePoolResponse = ManagedInstanceListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceListResult;
    };
};

// @public
export type ManagedInstancesListByResourceGroupNextResponse = ManagedInstanceListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceListResult;
    };
};

// @public
export type ManagedInstancesListByResourceGroupResponse = ManagedInstanceListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceListResult;
    };
};

// @public
export type ManagedInstancesListNextResponse = ManagedInstanceListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceListResult;
    };
};

// @public
export type ManagedInstancesListResponse = ManagedInstanceListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceListResult;
    };
};

// @public
export type ManagedInstancesUpdateResponse = ManagedInstance & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstance;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export interface ManagedInstanceTdeCertificates {
    create(resourceGroupName: string, managedInstanceName: string, parameters: TdeCertificate, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
}

// @public
export interface ManagedInstanceUpdate {
    administratorLogin?: string;
    administratorLoginPassword?: string;
    collation?: string;
    readonly dnsZone?: string;
    dnsZonePartner?: string;
    readonly fullyQualifiedDomainName?: string;
    instancePoolId?: string;
    licenseType?: ManagedInstanceLicenseType;
    managedInstanceCreateMode?: ManagedServerCreateMode;
    minimalTlsVersion?: string;
    proxyOverride?: ManagedInstanceProxyOverride;
    publicDataEndpointEnabled?: boolean;
    restorePointInTime?: Date;
    sku?: Sku;
    sourceManagedInstanceId?: string;
    readonly state?: string;
    storageSizeInGB?: number;
    subnetId?: string;
    tags?: {
        [propertyName: string]: string;
    };
    timezoneId?: string;
    vCores?: number;
}

// @public
export interface ManagedInstanceVcoresCapability {
    readonly includedMaxSize?: MaxSizeCapability;
    readonly instancePoolSupported?: boolean;
    readonly name?: string;
    reason?: string;
    readonly standaloneSupported?: boolean;
    readonly status?: CapabilityStatus;
    readonly supportedStorageSizes?: MaxSizeRangeCapability[];
    readonly value?: number;
}

// @public
export interface ManagedInstanceVersionCapability {
    readonly name?: string;
    reason?: string;
    readonly status?: CapabilityStatus;
    readonly supportedEditions?: ManagedInstanceEditionCapability[];
    readonly supportedInstancePoolEditions?: InstancePoolEditionCapability[];
}

// @public
export type ManagedInstanceVulnerabilityAssessment = ProxyResource & {
    storageContainerPath?: string;
    storageContainerSasKey?: string;
    storageAccountAccessKey?: string;
    recurringScans?: VulnerabilityAssessmentRecurringScansProperties;
};

// @public
export interface ManagedInstanceVulnerabilityAssessmentListResult {
    readonly nextLink?: string;
    readonly value?: ManagedInstanceVulnerabilityAssessment[];
}

// @public
export interface ManagedInstanceVulnerabilityAssessments {
    createOrUpdate(resourceGroupName: string, managedInstanceName: string, vulnerabilityAssessmentName: VulnerabilityAssessmentName, parameters: ManagedInstanceVulnerabilityAssessment, options?: coreHttp.OperationOptions): Promise<ManagedInstanceVulnerabilityAssessmentsCreateOrUpdateResponse>;
    delete(resourceGroupName: string, managedInstanceName: string, vulnerabilityAssessmentName: VulnerabilityAssessmentName, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    get(resourceGroupName: string, managedInstanceName: string, vulnerabilityAssessmentName: VulnerabilityAssessmentName, options?: coreHttp.OperationOptions): Promise<ManagedInstanceVulnerabilityAssessmentsGetResponse>;
    listByInstance(resourceGroupName: string, managedInstanceName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<ManagedInstanceVulnerabilityAssessment>;
}

// @public
export type ManagedInstanceVulnerabilityAssessmentsCreateOrUpdateResponse = ManagedInstanceVulnerabilityAssessment & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceVulnerabilityAssessment;
    };
};

// @public
export type ManagedInstanceVulnerabilityAssessmentsGetResponse = ManagedInstanceVulnerabilityAssessment & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceVulnerabilityAssessment;
    };
};

// @public
export type ManagedInstanceVulnerabilityAssessmentsListByInstanceNextResponse = ManagedInstanceVulnerabilityAssessmentListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceVulnerabilityAssessmentListResult;
    };
};

// @public
export type ManagedInstanceVulnerabilityAssessmentsListByInstanceResponse = ManagedInstanceVulnerabilityAssessmentListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedInstanceVulnerabilityAssessmentListResult;
    };
};

// @public
export interface ManagedRestorableDroppedDatabaseBackupShortTermRetentionPolicies {
    createOrUpdate(resourceGroupName: string, managedInstanceName: string, restorableDroppedDatabaseId: string, policyName: ManagedShortTermRetentionPolicyName, parameters: ManagedBackupShortTermRetentionPolicy, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdateResponse>, ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdateResponse>>;
    get(resourceGroupName: string, managedInstanceName: string, restorableDroppedDatabaseId: string, policyName: ManagedShortTermRetentionPolicyName, options?: coreHttp.OperationOptions): Promise<ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesGetResponse>;
    listByRestorableDroppedDatabase(resourceGroupName: string, managedInstanceName: string, restorableDroppedDatabaseId: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<ManagedBackupShortTermRetentionPolicy>;
    update(resourceGroupName: string, managedInstanceName: string, restorableDroppedDatabaseId: string, policyName: ManagedShortTermRetentionPolicyName, parameters: ManagedBackupShortTermRetentionPolicy, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdateResponse>, ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdateResponse>>;
}

// @public
export type ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesCreateOrUpdateResponse = ManagedBackupShortTermRetentionPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedBackupShortTermRetentionPolicy;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesGetResponse = ManagedBackupShortTermRetentionPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedBackupShortTermRetentionPolicy;
    };
};

// @public
export type ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesListByRestorableDroppedDatabaseNextResponse = ManagedBackupShortTermRetentionPolicyListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedBackupShortTermRetentionPolicyListResult;
    };
};

// @public
export type ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesListByRestorableDroppedDatabaseResponse = ManagedBackupShortTermRetentionPolicyListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedBackupShortTermRetentionPolicyListResult;
    };
};

// @public
export type ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesUpdateResponse = ManagedBackupShortTermRetentionPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedBackupShortTermRetentionPolicy;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type ManagedServerCreateMode = string;

// @public
export interface ManagedServerSecurityAlertPolicies {
    createOrUpdate(resourceGroupName: string, managedInstanceName: string, securityAlertPolicyName: SecurityAlertPolicyNameAutoGenerated, parameters: ManagedServerSecurityAlertPolicy, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<ManagedServerSecurityAlertPoliciesCreateOrUpdateResponse>, ManagedServerSecurityAlertPoliciesCreateOrUpdateResponse>>;
    get(resourceGroupName: string, managedInstanceName: string, securityAlertPolicyName: SecurityAlertPolicyNameAutoGenerated, options?: coreHttp.OperationOptions): Promise<ManagedServerSecurityAlertPoliciesGetResponse>;
    listByInstance(resourceGroupName: string, managedInstanceName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<ManagedServerSecurityAlertPolicy>;
}

// @public
export type ManagedServerSecurityAlertPoliciesCreateOrUpdateResponse = ManagedServerSecurityAlertPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedServerSecurityAlertPolicy;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type ManagedServerSecurityAlertPoliciesGetResponse = ManagedServerSecurityAlertPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedServerSecurityAlertPolicy;
    };
};

// @public
export type ManagedServerSecurityAlertPoliciesListByInstanceNextResponse = ManagedServerSecurityAlertPolicyListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedServerSecurityAlertPolicyListResult;
    };
};

// @public
export type ManagedServerSecurityAlertPoliciesListByInstanceResponse = ManagedServerSecurityAlertPolicyListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagedServerSecurityAlertPolicyListResult;
    };
};

// @public
export type ManagedServerSecurityAlertPolicy = ProxyResource & {
    state?: SecurityAlertPolicyState;
    disabledAlerts?: string[];
    emailAddresses?: string[];
    emailAccountAdmins?: boolean;
    storageEndpoint?: string;
    storageAccountAccessKey?: string;
    retentionDays?: number;
    readonly creationTime?: Date;
};

// @public
export interface ManagedServerSecurityAlertPolicyListResult {
    readonly nextLink?: string;
    readonly value?: ManagedServerSecurityAlertPolicy[];
}

// @public
export type ManagedShortTermRetentionPolicyName = string;

// @public
export type ManagementOperationState = string;

// @public
export interface MaxSizeCapability {
    readonly limit?: number;
    readonly unit?: MaxSizeUnit;
}

// @public
export interface MaxSizeRangeCapability {
    readonly logSize?: LogSizeCapability;
    readonly maxValue?: MaxSizeCapability;
    readonly minValue?: MaxSizeCapability;
    reason?: string;
    readonly scaleSize?: MaxSizeCapability;
    readonly status?: CapabilityStatus;
}

// @public
export type MaxSizeUnit = string;

// @public
export interface Metric {
    readonly endTime?: Date;
    readonly metricValues?: MetricValue[];
    readonly name?: MetricName;
    readonly startTime?: Date;
    readonly timeGrain?: string;
    readonly unit?: UnitType;
}

// @public
export interface MetricAvailability {
    readonly retention?: string;
    readonly timeGrain?: string;
}

// @public
export interface MetricDefinition {
    readonly metricAvailabilities?: MetricAvailability[];
    readonly name?: MetricName;
    readonly primaryAggregationType?: PrimaryAggregationType;
    readonly resourceUri?: string;
    readonly unit?: UnitDefinitionType;
}

// @public
export interface MetricDefinitionListResult {
    value: MetricDefinition[];
}

// @public
export interface MetricListResult {
    value: Metric[];
}

// @public
export interface MetricName {
    readonly localizedValue?: string;
    readonly value?: string;
}

// @public
export interface MetricValue {
    readonly average?: number;
    readonly count?: number;
    readonly maximum?: number;
    readonly minimum?: number;
    readonly timestamp?: Date;
    readonly total?: number;
}

// @public
export interface MinCapacityCapability {
    reason?: string;
    readonly status?: CapabilityStatus;
    readonly value?: number;
}

// @public
export interface Name {
    localizedValue?: string;
    value?: string;
}

// @public
export interface Operation {
    readonly display?: OperationDisplay;
    readonly name?: string;
    readonly origin?: OperationOrigin;
    readonly properties?: {
        [propertyName: string]: any;
    };
}

// @public
export interface OperationDisplay {
    readonly description?: string;
    readonly operation?: string;
    readonly provider?: string;
    readonly resource?: string;
}

// @public
export interface OperationImpact {
    readonly changeValueAbsolute?: number;
    readonly changeValueRelative?: number;
    readonly name?: string;
    readonly unit?: string;
}

// @public
export interface OperationListResult {
    readonly nextLink?: string;
    readonly value?: Operation[];
}

// @public
export type OperationOrigin = string;

// @public
export interface Operations {
    list(options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<Operation>;
}

// @public
export type OperationsListNextResponse = OperationListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: OperationListResult;
    };
};

// @public
export type OperationsListResponse = OperationListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: OperationListResult;
    };
};

// @public
export interface PartnerInfo {
    id: string;
    readonly location?: string;
    readonly replicationRole?: FailoverGroupReplicationRole;
}

// @public
export interface PartnerRegionInfo {
    location?: string;
    readonly replicationRole?: InstanceFailoverGroupReplicationRole;
}

// @public
export type PauseDelayTimeUnit = string;

// @public
export interface PerformanceLevelCapability {
    readonly unit?: PerformanceLevelUnit;
    readonly value?: number;
}

// @public
export type PerformanceLevelUnit = string;

// @public
export type PrimaryAggregationType = string;

// @public
export type PrivateEndpointConnection = ProxyResource & {
    privateEndpoint?: PrivateEndpointProperty;
    privateLinkServiceConnectionState?: PrivateLinkServiceConnectionStateProperty;
    readonly provisioningState?: string;
};

// @public
export interface PrivateEndpointConnectionListResult {
    readonly nextLink?: string;
    readonly value?: PrivateEndpointConnection[];
}

// @public
export interface PrivateEndpointConnectionProperties {
    privateEndpoint?: PrivateEndpointProperty;
    privateLinkServiceConnectionState?: PrivateLinkServiceConnectionStatePropertyAutoGenerated;
    readonly provisioningState?: PrivateEndpointProvisioningState;
}

// @public
export interface PrivateEndpointConnections {
    createOrUpdate(resourceGroupName: string, serverName: string, privateEndpointConnectionName: string, parameters: PrivateEndpointConnection, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<PrivateEndpointConnectionsCreateOrUpdateResponse>, PrivateEndpointConnectionsCreateOrUpdateResponse>>;
    delete(resourceGroupName: string, serverName: string, privateEndpointConnectionName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    get(resourceGroupName: string, serverName: string, privateEndpointConnectionName: string, options?: coreHttp.OperationOptions): Promise<PrivateEndpointConnectionsGetResponse>;
    listByServer(resourceGroupName: string, serverName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<PrivateEndpointConnection>;
}

// @public
export type PrivateEndpointConnectionsCreateOrUpdateResponse = PrivateEndpointConnection & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: PrivateEndpointConnection;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type PrivateEndpointConnectionsGetResponse = PrivateEndpointConnection & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: PrivateEndpointConnection;
    };
};

// @public
export type PrivateEndpointConnectionsListByServerNextResponse = PrivateEndpointConnectionListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: PrivateEndpointConnectionListResult;
    };
};

// @public
export type PrivateEndpointConnectionsListByServerResponse = PrivateEndpointConnectionListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: PrivateEndpointConnectionListResult;
    };
};

// @public (undocumented)
export interface PrivateEndpointProperty {
    id?: string;
}

// @public
export type PrivateEndpointProvisioningState = string;

// @public
export type PrivateLinkResource = ProxyResource & {
    readonly properties?: PrivateLinkResourceProperties;
};

// @public
export interface PrivateLinkResourceListResult {
    readonly nextLink?: string;
    readonly value?: PrivateLinkResource[];
}

// @public
export interface PrivateLinkResourceProperties {
    readonly groupId?: string;
    readonly requiredMembers?: string[];
}

// @public
export interface PrivateLinkResources {
    get(resourceGroupName: string, serverName: string, groupName: string, options?: coreHttp.OperationOptions): Promise<PrivateLinkResourcesGetResponse>;
    listByServer(resourceGroupName: string, serverName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<PrivateLinkResource>;
}

// @public
export type PrivateLinkResourcesGetResponse = PrivateLinkResource & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: PrivateLinkResource;
    };
};

// @public
export type PrivateLinkResourcesListByServerNextResponse = PrivateLinkResourceListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: PrivateLinkResourceListResult;
    };
};

// @public
export type PrivateLinkResourcesListByServerResponse = PrivateLinkResourceListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: PrivateLinkResourceListResult;
    };
};

// @public
export type PrivateLinkServiceConnectionStateActionsRequire = string;

// @public (undocumented)
export interface PrivateLinkServiceConnectionStateProperty {
    readonly actionsRequired?: string;
    description: string;
    status: string;
}

// @public (undocumented)
export interface PrivateLinkServiceConnectionStatePropertyAutoGenerated {
    readonly actionsRequired?: PrivateLinkServiceConnectionStateActionsRequire;
    description: string;
    status: PrivateLinkServiceConnectionStateStatus;
}

// @public
export type PrivateLinkServiceConnectionStateStatus = string;

// @public
export type ProvisioningState = string;

// @public
export type ProxyResource = Resource & {};

// @public
export type ReadOnlyEndpointFailoverPolicy = string;

// @public
export interface ReadScaleCapability {
    readonly maxNumberOfReplicas?: number;
    reason?: string;
    readonly status?: CapabilityStatus;
}

// @public
export type ReadWriteEndpointFailoverPolicy = string;

// @public
export type RecommendedElasticPool = ProxyResource & {
    readonly databaseEdition?: ElasticPoolEdition;
    dtu?: number;
    databaseDtuMin?: number;
    databaseDtuMax?: number;
    storageMB?: number;
    readonly observationPeriodStart?: Date;
    readonly observationPeriodEnd?: Date;
    readonly maxObservedDtu?: number;
    readonly maxObservedStorageMB?: number;
    readonly databases?: TrackedResource[];
    readonly metrics?: RecommendedElasticPoolMetric[];
};

// @public
export interface RecommendedElasticPoolListMetricsResult {
    value: RecommendedElasticPoolMetric[];
}

// @public
export interface RecommendedElasticPoolListResult {
    value: RecommendedElasticPool[];
}

// @public
export interface RecommendedElasticPoolMetric {
    dateTime?: Date;
    dtu?: number;
    sizeGB?: number;
}

// @public
export interface RecommendedElasticPools {
    get(resourceGroupName: string, serverName: string, recommendedElasticPoolName: string, options?: coreHttp.OperationOptions): Promise<RecommendedElasticPoolsGetResponse>;
    listByServer(resourceGroupName: string, serverName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<RecommendedElasticPool>;
    listMetrics(resourceGroupName: string, serverName: string, recommendedElasticPoolName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<RecommendedElasticPoolMetric>;
}

// @public
export type RecommendedElasticPoolsGetResponse = RecommendedElasticPool & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: RecommendedElasticPool;
    };
};

// @public
export type RecommendedElasticPoolsListByServerResponse = RecommendedElasticPoolListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: RecommendedElasticPoolListResult;
    };
};

// @public
export type RecommendedElasticPoolsListMetricsResponse = RecommendedElasticPoolListMetricsResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: RecommendedElasticPoolListMetricsResult;
    };
};

// @public
export type RecommendedIndex = ProxyResource & {
    readonly action?: RecommendedIndexAction;
    readonly state?: RecommendedIndexState;
    readonly created?: Date;
    readonly lastModified?: Date;
    readonly indexType?: RecommendedIndexType;
    readonly schema?: string;
    readonly table?: string;
    readonly columns?: string[];
    readonly includedColumns?: string[];
    readonly indexScript?: string;
    readonly estimatedImpact?: OperationImpact[];
    readonly reportedImpact?: OperationImpact[];
};

// @public
export type RecommendedIndexAction = "Create" | "Drop" | "Rebuild";

// @public
export type RecommendedIndexState = "Active" | "Pending" | "Executing" | "Verifying" | "Pending Revert" | "Reverting" | "Reverted" | "Ignored" | "Expired" | "Blocked" | "Success";

// @public
export type RecommendedIndexType = "CLUSTERED" | "NONCLUSTERED" | "COLUMNSTORE" | "CLUSTERED COLUMNSTORE";

// @public
export type RecoverableDatabase = ProxyResource & {
    readonly edition?: string;
    readonly serviceLevelObjective?: string;
    readonly elasticPoolName?: string;
    readonly lastAvailableBackupDate?: Date;
};

// @public
export interface RecoverableDatabaseListResult {
    value: RecoverableDatabase[];
}

// @public
export interface RecoverableDatabases {
    get(resourceGroupName: string, serverName: string, databaseName: string, options?: coreHttp.OperationOptions): Promise<RecoverableDatabasesGetResponse>;
    listByServer(resourceGroupName: string, serverName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<RecoverableDatabase>;
}

// @public
export type RecoverableDatabasesGetResponse = RecoverableDatabase & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: RecoverableDatabase;
    };
};

// @public
export type RecoverableDatabasesListByServerResponse = RecoverableDatabaseListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: RecoverableDatabaseListResult;
    };
};

// @public
export type RecoverableManagedDatabase = ProxyResource & {
    readonly lastAvailableBackupDate?: string;
};

// @public
export interface RecoverableManagedDatabaseListResult {
    readonly nextLink?: string;
    readonly value?: RecoverableManagedDatabase[];
}

// @public
export interface RecoverableManagedDatabases {
    get(resourceGroupName: string, managedInstanceName: string, recoverableDatabaseName: string, options?: coreHttp.OperationOptions): Promise<RecoverableManagedDatabasesGetResponse>;
    listByInstance(resourceGroupName: string, managedInstanceName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<RecoverableManagedDatabase>;
}

// @public
export type RecoverableManagedDatabasesGetResponse = RecoverableManagedDatabase & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: RecoverableManagedDatabase;
    };
};

// @public
export type RecoverableManagedDatabasesListByInstanceNextResponse = RecoverableManagedDatabaseListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: RecoverableManagedDatabaseListResult;
    };
};

// @public
export type RecoverableManagedDatabasesListByInstanceResponse = RecoverableManagedDatabaseListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: RecoverableManagedDatabaseListResult;
    };
};

// @public
export type ReplicationLink = ProxyResource & {
    readonly location?: string;
    readonly isTerminationAllowed?: boolean;
    readonly replicationMode?: string;
    readonly partnerServer?: string;
    readonly partnerDatabase?: string;
    readonly partnerLocation?: string;
    readonly role?: ReplicationRole;
    readonly partnerRole?: ReplicationRole;
    readonly startTime?: Date;
    readonly percentComplete?: number;
    readonly replicationState?: ReplicationState;
};

// @public
export interface ReplicationLinkListResult {
    value?: ReplicationLink[];
}

// @public
export interface ReplicationLinks {
    delete(resourceGroupName: string, serverName: string, databaseName: string, linkId: string, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    failover(resourceGroupName: string, serverName: string, databaseName: string, linkId: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    failoverAllowDataLoss(resourceGroupName: string, serverName: string, databaseName: string, linkId: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    get(resourceGroupName: string, serverName: string, databaseName: string, linkId: string, options?: coreHttp.OperationOptions): Promise<ReplicationLinksGetResponse>;
    listByDatabase(resourceGroupName: string, serverName: string, databaseName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<ReplicationLink>;
    unlink(resourceGroupName: string, serverName: string, databaseName: string, linkId: string, parameters: UnlinkParameters, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
}

// @public
export type ReplicationLinksGetResponse = ReplicationLink & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ReplicationLink;
    };
};

// @public
export type ReplicationLinksListByDatabaseResponse = ReplicationLinkListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ReplicationLinkListResult;
    };
};

// @public
export type ReplicationRole = "Primary" | "Secondary" | "NonReadableSecondary" | "Source" | "Copy";

// @public
export type ReplicationState = string;

// @public
export type ReplicaType = string;

// @public
export interface Resource {
    readonly id?: string;
    readonly name?: string;
    readonly type?: string;
}

// @public
export interface ResourceIdentity {
    readonly principalId?: string;
    readonly tenantId?: string;
    type?: IdentityType;
}

// @public
export interface ResourceMoveDefinition {
    id: string;
}

// @public
export type RestorableDroppedDatabase = ProxyResource & {
    readonly location?: string;
    readonly databaseName?: string;
    readonly edition?: string;
    readonly maxSizeBytes?: string;
    readonly serviceLevelObjective?: string;
    readonly elasticPoolName?: string;
    readonly creationDate?: Date;
    readonly deletionDate?: Date;
    readonly earliestRestoreDate?: Date;
};

// @public
export interface RestorableDroppedDatabaseListResult {
    value: RestorableDroppedDatabase[];
}

// @public
export interface RestorableDroppedDatabases {
    get(resourceGroupName: string, serverName: string, restorableDroppededDatabaseId: string, options?: coreHttp.OperationOptions): Promise<RestorableDroppedDatabasesGetResponse>;
    listByServer(resourceGroupName: string, serverName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<RestorableDroppedDatabase>;
}

// @public
export type RestorableDroppedDatabasesGetResponse = RestorableDroppedDatabase & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: RestorableDroppedDatabase;
    };
};

// @public
export type RestorableDroppedDatabasesListByServerResponse = RestorableDroppedDatabaseListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: RestorableDroppedDatabaseListResult;
    };
};

// @public
export type RestorableDroppedManagedDatabase = TrackedResource & {
    readonly databaseName?: string;
    readonly creationDate?: Date;
    readonly deletionDate?: Date;
    readonly earliestRestoreDate?: Date;
};

// @public
export interface RestorableDroppedManagedDatabaseListResult {
    readonly nextLink?: string;
    readonly value?: RestorableDroppedManagedDatabase[];
}

// @public
export interface RestorableDroppedManagedDatabases {
    get(resourceGroupName: string, managedInstanceName: string, restorableDroppedDatabaseId: string, options?: coreHttp.OperationOptions): Promise<RestorableDroppedManagedDatabasesGetResponse>;
    listByInstance(resourceGroupName: string, managedInstanceName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<RestorableDroppedManagedDatabase>;
}

// @public
export type RestorableDroppedManagedDatabasesGetResponse = RestorableDroppedManagedDatabase & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: RestorableDroppedManagedDatabase;
    };
};

// @public
export type RestorableDroppedManagedDatabasesListByInstanceNextResponse = RestorableDroppedManagedDatabaseListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: RestorableDroppedManagedDatabaseListResult;
    };
};

// @public
export type RestorableDroppedManagedDatabasesListByInstanceResponse = RestorableDroppedManagedDatabaseListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: RestorableDroppedManagedDatabaseListResult;
    };
};

// @public
export type RestoreDetailsName = string;

// @public
export type RestorePoint = ProxyResource & {
    readonly location?: string;
    readonly restorePointType?: RestorePointType;
    readonly earliestRestoreDate?: Date;
    readonly restorePointCreationDate?: Date;
    readonly restorePointLabel?: string;
};

// @public
export interface RestorePointListResult {
    readonly nextLink?: string;
    readonly value?: RestorePoint[];
}

// @public
export interface RestorePoints {
    create(resourceGroupName: string, serverName: string, databaseName: string, parameters: CreateDatabaseRestorePointDefinition, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<RestorePointsCreateResponse>, RestorePointsCreateResponse>>;
    delete(resourceGroupName: string, serverName: string, databaseName: string, restorePointName: string, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    get(resourceGroupName: string, serverName: string, databaseName: string, restorePointName: string, options?: coreHttp.OperationOptions): Promise<RestorePointsGetResponse>;
    listByDatabase(resourceGroupName: string, serverName: string, databaseName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<RestorePoint>;
}

// @public
export type RestorePointsCreateResponse = RestorePoint & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: RestorePoint;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type RestorePointsGetResponse = RestorePoint & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: RestorePoint;
    };
};

// @public
export type RestorePointsListByDatabaseResponse = RestorePointListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: RestorePointListResult;
    };
};

// @public
export type RestorePointType = "CONTINUOUS" | "DISCRETE";

// @public
export type SampleName = string;

// @public
export type SecurityAlertPolicyEmailAccountAdmins = "Enabled" | "Disabled";

// @public
export type SecurityAlertPolicyName = string;

// @public
export type SecurityAlertPolicyNameAutoGenerated = string;

// @public
export type SecurityAlertPolicyState = "New" | "Enabled" | "Disabled";

// @public
export type SecurityAlertPolicyUseServerDefault = "Enabled" | "Disabled";

// @public
export type SensitivityLabel = ProxyResource & {
    labelName?: string;
    labelId?: string;
    informationType?: string;
    informationTypeId?: string;
    readonly isDisabled?: boolean;
    rank?: SensitivityLabelRank;
};

// @public
export interface SensitivityLabelListResult {
    readonly nextLink?: string;
    readonly value?: SensitivityLabel[];
}

// @public
export type SensitivityLabelRank = "None" | "Low" | "Medium" | "High" | "Critical";

// @public
export interface SensitivityLabels {
    createOrUpdate(resourceGroupName: string, serverName: string, databaseName: string, schemaName: string, tableName: string, columnName: string, parameters: SensitivityLabel, options?: coreHttp.OperationOptions): Promise<SensitivityLabelsCreateOrUpdateResponse>;
    delete(resourceGroupName: string, serverName: string, databaseName: string, schemaName: string, tableName: string, columnName: string, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    disableRecommendation(resourceGroupName: string, serverName: string, databaseName: string, schemaName: string, tableName: string, columnName: string, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    enableRecommendation(resourceGroupName: string, serverName: string, databaseName: string, schemaName: string, tableName: string, columnName: string, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    get(resourceGroupName: string, serverName: string, databaseName: string, schemaName: string, tableName: string, columnName: string, sensitivityLabelSource: SensitivityLabelSource, options?: coreHttp.OperationOptions): Promise<SensitivityLabelsGetResponse>;
    listCurrentByDatabase(resourceGroupName: string, serverName: string, databaseName: string, options?: SensitivityLabelsListCurrentByDatabaseOptionalParams): PagedAsyncIterableIterator<SensitivityLabel>;
    listRecommendedByDatabase(resourceGroupName: string, serverName: string, databaseName: string, options?: SensitivityLabelsListRecommendedByDatabaseOptionalParams): PagedAsyncIterableIterator<SensitivityLabel>;
}

// @public
export type SensitivityLabelsCreateOrUpdateResponse = SensitivityLabel & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SensitivityLabel;
    };
};

// @public
export type SensitivityLabelsGetResponse = SensitivityLabel & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SensitivityLabel;
    };
};

// @public
export interface SensitivityLabelsListCurrentByDatabaseNextOptionalParams extends coreHttp.OperationOptions {
    filter?: string;
}

// @public
export type SensitivityLabelsListCurrentByDatabaseNextResponse = SensitivityLabelListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SensitivityLabelListResult;
    };
};

// @public
export interface SensitivityLabelsListCurrentByDatabaseOptionalParams extends coreHttp.OperationOptions {
    filter?: string;
}

// @public
export type SensitivityLabelsListCurrentByDatabaseResponse = SensitivityLabelListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SensitivityLabelListResult;
    };
};

// @public
export interface SensitivityLabelsListRecommendedByDatabaseNextOptionalParams extends coreHttp.OperationOptions {
    filter?: string;
    includeDisabledRecommendations?: boolean;
    // (undocumented)
    skipToken?: string;
}

// @public
export type SensitivityLabelsListRecommendedByDatabaseNextResponse = SensitivityLabelListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SensitivityLabelListResult;
    };
};

// @public
export interface SensitivityLabelsListRecommendedByDatabaseOptionalParams extends coreHttp.OperationOptions {
    filter?: string;
    includeDisabledRecommendations?: boolean;
    // (undocumented)
    skipToken?: string;
}

// @public
export type SensitivityLabelsListRecommendedByDatabaseResponse = SensitivityLabelListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SensitivityLabelListResult;
    };
};

// @public
export type SensitivityLabelSource = "current" | "recommended";

// @public
export type Server = TrackedResource & {
    identity?: ResourceIdentity;
    readonly kind?: string;
    administratorLogin?: string;
    administratorLoginPassword?: string;
    version?: string;
    readonly state?: string;
    readonly fullyQualifiedDomainName?: string;
    readonly privateEndpointConnections?: ServerPrivateEndpointConnection[];
    minimalTlsVersion?: string;
    publicNetworkAccess?: ServerPublicNetworkAccess;
};

// @public
export interface ServerAutomaticTuning {
    get(resourceGroupName: string, serverName: string, options?: coreHttp.OperationOptions): Promise<ServerAutomaticTuningGetResponse>;
    update(resourceGroupName: string, serverName: string, parameters: ServerAutomaticTuningDef, options?: coreHttp.OperationOptions): Promise<ServerAutomaticTuningUpdateResponse>;
}

// @public
export type ServerAutomaticTuningDef = ProxyResource & {
    desiredState?: AutomaticTuningServerMode;
    readonly actualState?: AutomaticTuningServerMode;
    options?: {
        [propertyName: string]: AutomaticTuningServerOptions;
    };
};

// @public
export type ServerAutomaticTuningGetResponse = ServerAutomaticTuningDef & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerAutomaticTuningDef;
    };
};

// @public
export type ServerAutomaticTuningUpdateResponse = ServerAutomaticTuningDef & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerAutomaticTuningDef;
    };
};

// @public
export type ServerAzureADAdministrator = ProxyResource & {
    administratorType?: AdministratorType;
    login?: string;
    sid?: string;
    tenantId?: string;
    azureADOnlyAuthentication?: boolean;
};

// @public
export interface ServerAzureADAdministrators {
    createOrUpdate(resourceGroupName: string, serverName: string, administratorName: AdministratorName, parameters: ServerAzureADAdministrator, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<ServerAzureADAdministratorsCreateOrUpdateResponse>, ServerAzureADAdministratorsCreateOrUpdateResponse>>;
    delete(resourceGroupName: string, serverName: string, administratorName: AdministratorName, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    disableAzureADOnlyAuthentication(resourceGroupName: string, serverName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<ServerAzureADAdministratorsDisableAzureADOnlyAuthenticationResponse>, ServerAzureADAdministratorsDisableAzureADOnlyAuthenticationResponse>>;
    get(resourceGroupName: string, serverName: string, administratorName: AdministratorName, options?: coreHttp.OperationOptions): Promise<ServerAzureADAdministratorsGetResponse>;
    listByServer(resourceGroupName: string, serverName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<ServerAzureADAdministrator>;
}

// @public
export type ServerAzureADAdministratorsCreateOrUpdateResponse = ServerAzureADAdministrator & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerAzureADAdministrator;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type ServerAzureADAdministratorsDisableAzureADOnlyAuthenticationResponse = ServerAzureADAdministrator & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerAzureADAdministrator;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type ServerAzureADAdministratorsGetResponse = ServerAzureADAdministrator & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerAzureADAdministrator;
    };
};

// @public
export type ServerAzureADAdministratorsListByServerNextResponse = AdministratorListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: AdministratorListResult;
    };
};

// @public
export type ServerAzureADAdministratorsListByServerResponse = AdministratorListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: AdministratorListResult;
    };
};

// @public
export interface ServerBlobAuditingPolicies {
    createOrUpdate(resourceGroupName: string, serverName: string, parameters: ServerBlobAuditingPolicy, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<ServerBlobAuditingPoliciesCreateOrUpdateResponse>, ServerBlobAuditingPoliciesCreateOrUpdateResponse>>;
    get(resourceGroupName: string, serverName: string, options?: coreHttp.OperationOptions): Promise<ServerBlobAuditingPoliciesGetResponse>;
    listByServer(resourceGroupName: string, serverName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<ServerBlobAuditingPolicy>;
}

// @public
export type ServerBlobAuditingPoliciesCreateOrUpdateResponse = ServerBlobAuditingPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerBlobAuditingPolicy;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type ServerBlobAuditingPoliciesGetResponse = ServerBlobAuditingPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerBlobAuditingPolicy;
    };
};

// @public
export type ServerBlobAuditingPoliciesListByServerNextResponse = ServerBlobAuditingPolicyListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerBlobAuditingPolicyListResult;
    };
};

// @public
export type ServerBlobAuditingPoliciesListByServerResponse = ServerBlobAuditingPolicyListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerBlobAuditingPolicyListResult;
    };
};

// @public
export type ServerBlobAuditingPolicy = ProxyResource & {
    state?: BlobAuditingPolicyState;
    storageEndpoint?: string;
    storageAccountAccessKey?: string;
    retentionDays?: number;
    auditActionsAndGroups?: string[];
    storageAccountSubscriptionId?: string;
    isStorageSecondaryKeyInUse?: boolean;
    isAzureMonitorTargetEnabled?: boolean;
    queueDelayMs?: number;
};

// @public
export interface ServerBlobAuditingPolicyListResult {
    readonly nextLink?: string;
    readonly value?: ServerBlobAuditingPolicy[];
}

// @public
export type ServerCommunicationLink = ProxyResource & {
    readonly location?: string;
    readonly kind?: string;
    readonly state?: string;
    partnerServer?: string;
};

// @public
export interface ServerCommunicationLinkListResult {
    value?: ServerCommunicationLink[];
}

// @public
export interface ServerCommunicationLinks {
    createOrUpdate(resourceGroupName: string, serverName: string, communicationLinkName: string, parameters: ServerCommunicationLink, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<ServerCommunicationLinksCreateOrUpdateResponse>, ServerCommunicationLinksCreateOrUpdateResponse>>;
    delete(resourceGroupName: string, serverName: string, communicationLinkName: string, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    get(resourceGroupName: string, serverName: string, communicationLinkName: string, options?: coreHttp.OperationOptions): Promise<ServerCommunicationLinksGetResponse>;
    listByServer(resourceGroupName: string, serverName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<ServerCommunicationLink>;
}

// @public
export type ServerCommunicationLinksCreateOrUpdateResponse = ServerCommunicationLink & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerCommunicationLink;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type ServerCommunicationLinksGetResponse = ServerCommunicationLink & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerCommunicationLink;
    };
};

// @public
export type ServerCommunicationLinksListByServerResponse = ServerCommunicationLinkListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerCommunicationLinkListResult;
    };
};

// @public
export interface ServerConnectionPolicies {
    createOrUpdate(resourceGroupName: string, serverName: string, connectionPolicyName: ConnectionPolicyName, parameters: ServerConnectionPolicy, options?: coreHttp.OperationOptions): Promise<ServerConnectionPoliciesCreateOrUpdateResponse>;
    get(resourceGroupName: string, serverName: string, connectionPolicyName: ConnectionPolicyName, options?: coreHttp.OperationOptions): Promise<ServerConnectionPoliciesGetResponse>;
}

// @public
export type ServerConnectionPoliciesCreateOrUpdateResponse = ServerConnectionPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerConnectionPolicy;
    };
};

// @public
export type ServerConnectionPoliciesGetResponse = ServerConnectionPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerConnectionPolicy;
    };
};

// @public
export type ServerConnectionPolicy = ProxyResource & {
    readonly kind?: string;
    readonly location?: string;
    connectionType?: ServerConnectionType;
};

// @public
export type ServerConnectionType = "Default" | "Proxy" | "Redirect";

// @public
export type ServerDnsAlias = ProxyResource & {
    readonly azureDnsRecord?: string;
};

// @public
export interface ServerDnsAliasAcquisition {
    oldServerDnsAliasId?: string;
}

// @public
export interface ServerDnsAliases {
    acquire(resourceGroupName: string, serverName: string, dnsAliasName: string, parameters: ServerDnsAliasAcquisition, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    createOrUpdate(resourceGroupName: string, serverName: string, dnsAliasName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<ServerDnsAliasesCreateOrUpdateResponse>, ServerDnsAliasesCreateOrUpdateResponse>>;
    delete(resourceGroupName: string, serverName: string, dnsAliasName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    get(resourceGroupName: string, serverName: string, dnsAliasName: string, options?: coreHttp.OperationOptions): Promise<ServerDnsAliasesGetResponse>;
    listByServer(resourceGroupName: string, serverName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<ServerDnsAlias>;
}

// @public
export type ServerDnsAliasesCreateOrUpdateResponse = ServerDnsAlias & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerDnsAlias;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type ServerDnsAliasesGetResponse = ServerDnsAlias & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerDnsAlias;
    };
};

// @public
export type ServerDnsAliasesListByServerNextResponse = ServerDnsAliasListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerDnsAliasListResult;
    };
};

// @public
export type ServerDnsAliasesListByServerResponse = ServerDnsAliasListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerDnsAliasListResult;
    };
};

// @public
export interface ServerDnsAliasListResult {
    readonly nextLink?: string;
    readonly value?: ServerDnsAlias[];
}

// @public
export type ServerKey = ProxyResource & {
    kind?: string;
    readonly location?: string;
    readonly subregion?: string;
    serverKeyType?: ServerKeyType;
    uri?: string;
    thumbprint?: string;
    creationDate?: Date;
};

// @public
export interface ServerKeyListResult {
    readonly nextLink?: string;
    readonly value?: ServerKey[];
}

// @public
export interface ServerKeys {
    createOrUpdate(resourceGroupName: string, serverName: string, keyName: string, parameters: ServerKey, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<ServerKeysCreateOrUpdateResponse>, ServerKeysCreateOrUpdateResponse>>;
    delete(resourceGroupName: string, serverName: string, keyName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    get(resourceGroupName: string, serverName: string, keyName: string, options?: coreHttp.OperationOptions): Promise<ServerKeysGetResponse>;
    listByServer(resourceGroupName: string, serverName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<ServerKey>;
}

// @public
export type ServerKeysCreateOrUpdateResponse = ServerKey & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerKey;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type ServerKeysGetResponse = ServerKey & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerKey;
    };
};

// @public
export type ServerKeysListByServerNextResponse = ServerKeyListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerKeyListResult;
    };
};

// @public
export type ServerKeysListByServerResponse = ServerKeyListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerKeyListResult;
    };
};

// @public
export type ServerKeyType = string;

// @public
export interface ServerListResult {
    readonly nextLink?: string;
    readonly value?: Server[];
}

// @public
export interface ServerPrivateEndpointConnection {
    readonly id?: string;
    readonly properties?: PrivateEndpointConnectionProperties;
}

// @public
export type ServerPublicNetworkAccess = string;

// @public
export interface Servers {
    checkNameAvailability(parameters: CheckNameAvailabilityRequest, options?: coreHttp.OperationOptions): Promise<ServersCheckNameAvailabilityResponse>;
    createOrUpdate(resourceGroupName: string, serverName: string, parameters: Server, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<ServersCreateOrUpdateResponse>, ServersCreateOrUpdateResponse>>;
    delete(resourceGroupName: string, serverName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    get(resourceGroupName: string, serverName: string, options?: coreHttp.OperationOptions): Promise<ServersGetResponse>;
    list(options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<Server>;
    listByResourceGroup(resourceGroupName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<Server>;
    update(resourceGroupName: string, serverName: string, parameters: ServerUpdate, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<ServersUpdateResponse>, ServersUpdateResponse>>;
}

// @public
export type ServersCheckNameAvailabilityResponse = CheckNameAvailabilityResponse & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: CheckNameAvailabilityResponse;
    };
};

// @public
export type ServersCreateOrUpdateResponse = Server & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: Server;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export interface ServerSecurityAlertPolicies {
    createOrUpdate(resourceGroupName: string, serverName: string, securityAlertPolicyName: SecurityAlertPolicyNameAutoGenerated, parameters: ServerSecurityAlertPolicy, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<ServerSecurityAlertPoliciesCreateOrUpdateResponse>, ServerSecurityAlertPoliciesCreateOrUpdateResponse>>;
    get(resourceGroupName: string, serverName: string, securityAlertPolicyName: SecurityAlertPolicyNameAutoGenerated, options?: coreHttp.OperationOptions): Promise<ServerSecurityAlertPoliciesGetResponse>;
    listByServer(resourceGroupName: string, serverName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<ServerSecurityAlertPolicy>;
}

// @public
export type ServerSecurityAlertPoliciesCreateOrUpdateResponse = ServerSecurityAlertPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerSecurityAlertPolicy;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type ServerSecurityAlertPoliciesGetResponse = ServerSecurityAlertPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerSecurityAlertPolicy;
    };
};

// @public
export type ServerSecurityAlertPoliciesListByServerNextResponse = LogicalServerSecurityAlertPolicyListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: LogicalServerSecurityAlertPolicyListResult;
    };
};

// @public
export type ServerSecurityAlertPoliciesListByServerResponse = LogicalServerSecurityAlertPolicyListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: LogicalServerSecurityAlertPolicyListResult;
    };
};

// @public
export type ServerSecurityAlertPolicy = ProxyResource & {
    state?: SecurityAlertPolicyState;
    disabledAlerts?: string[];
    emailAddresses?: string[];
    emailAccountAdmins?: boolean;
    storageEndpoint?: string;
    storageAccountAccessKey?: string;
    retentionDays?: number;
    readonly creationTime?: Date;
};

// @public
export type ServersGetResponse = Server & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: Server;
    };
};

// @public
export type ServersListByResourceGroupNextResponse = ServerListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerListResult;
    };
};

// @public
export type ServersListByResourceGroupResponse = ServerListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerListResult;
    };
};

// @public
export type ServersListNextResponse = ServerListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerListResult;
    };
};

// @public
export type ServersListResponse = ServerListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerListResult;
    };
};

// @public
export type ServersUpdateResponse = Server & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: Server;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export interface ServerUpdate {
    administratorLogin?: string;
    administratorLoginPassword?: string;
    readonly fullyQualifiedDomainName?: string;
    minimalTlsVersion?: string;
    readonly privateEndpointConnections?: ServerPrivateEndpointConnection[];
    publicNetworkAccess?: ServerPublicNetworkAccess;
    readonly state?: string;
    tags?: {
        [propertyName: string]: string;
    };
    version?: string;
}

// @public
export interface ServerUsage {
    readonly currentValue?: number;
    readonly displayName?: string;
    readonly limit?: number;
    readonly name?: string;
    readonly nextResetTime?: Date;
    readonly resourceName?: string;
    readonly unit?: string;
}

// @public
export interface ServerUsageListResult {
    value: ServerUsage[];
}

// @public
export interface ServerUsages {
    listByServer(resourceGroupName: string, serverName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<ServerUsage>;
}

// @public
export type ServerUsagesListByServerResponse = ServerUsageListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerUsageListResult;
    };
};

// @public
export interface ServerVersionCapability {
    readonly name?: string;
    reason?: string;
    readonly status?: CapabilityStatus;
    readonly supportedEditions?: EditionCapability[];
    readonly supportedElasticPoolEditions?: ElasticPoolEditionCapability[];
}

// @public
export type ServerVulnerabilityAssessment = ProxyResource & {
    storageContainerPath?: string;
    storageContainerSasKey?: string;
    storageAccountAccessKey?: string;
    recurringScans?: VulnerabilityAssessmentRecurringScansProperties;
};

// @public
export interface ServerVulnerabilityAssessmentListResult {
    readonly nextLink?: string;
    readonly value?: ServerVulnerabilityAssessment[];
}

// @public
export interface ServerVulnerabilityAssessments {
    createOrUpdate(resourceGroupName: string, serverName: string, vulnerabilityAssessmentName: VulnerabilityAssessmentName, parameters: ServerVulnerabilityAssessment, options?: coreHttp.OperationOptions): Promise<ServerVulnerabilityAssessmentsCreateOrUpdateResponse>;
    delete(resourceGroupName: string, serverName: string, vulnerabilityAssessmentName: VulnerabilityAssessmentName, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    get(resourceGroupName: string, serverName: string, vulnerabilityAssessmentName: VulnerabilityAssessmentName, options?: coreHttp.OperationOptions): Promise<ServerVulnerabilityAssessmentsGetResponse>;
    listByServer(resourceGroupName: string, serverName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<ServerVulnerabilityAssessment>;
}

// @public
export type ServerVulnerabilityAssessmentsCreateOrUpdateResponse = ServerVulnerabilityAssessment & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerVulnerabilityAssessment;
    };
};

// @public
export type ServerVulnerabilityAssessmentsGetResponse = ServerVulnerabilityAssessment & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerVulnerabilityAssessment;
    };
};

// @public
export type ServerVulnerabilityAssessmentsListByServerNextResponse = ServerVulnerabilityAssessmentListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerVulnerabilityAssessmentListResult;
    };
};

// @public
export type ServerVulnerabilityAssessmentsListByServerResponse = ServerVulnerabilityAssessmentListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServerVulnerabilityAssessmentListResult;
    };
};

// @public
export type ServiceObjective = ProxyResource & {
    readonly serviceObjectiveName?: string;
    readonly isDefault?: boolean;
    readonly isSystem?: boolean;
    readonly description?: string;
    readonly enabled?: boolean;
};

// @public
export interface ServiceObjectiveCapability {
    readonly computeModel?: string;
    readonly id?: string;
    readonly includedMaxSize?: MaxSizeCapability;
    readonly name?: string;
    readonly performanceLevel?: PerformanceLevelCapability;
    reason?: string;
    readonly sku?: Sku;
    readonly status?: CapabilityStatus;
    readonly supportedAutoPauseDelay?: AutoPauseDelayTimeRange;
    readonly supportedLicenseTypes?: LicenseTypeCapability[];
    readonly supportedMaxSizes?: MaxSizeRangeCapability[];
    readonly supportedMinCapacities?: MinCapacityCapability[];
    readonly zoneRedundant?: boolean;
}

// @public
export interface ServiceObjectiveListResult {
    value: ServiceObjective[];
}

// @public
export type ServiceObjectiveName = string;

// @public
export interface ServiceObjectives {
    get(resourceGroupName: string, serverName: string, serviceObjectiveName: string, options?: coreHttp.OperationOptions): Promise<ServiceObjectivesGetResponse>;
    listByServer(resourceGroupName: string, serverName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<ServiceObjective>;
}

// @public
export type ServiceObjectivesGetResponse = ServiceObjective & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServiceObjective;
    };
};

// @public
export type ServiceObjectivesListByServerResponse = ServiceObjectiveListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServiceObjectiveListResult;
    };
};

// @public
export type ServiceTierAdvisor = ProxyResource & {
    readonly observationPeriodStart?: Date;
    readonly observationPeriodEnd?: Date;
    readonly activeTimeRatio?: number;
    readonly minDtu?: number;
    readonly avgDtu?: number;
    readonly maxDtu?: number;
    readonly maxSizeInGB?: number;
    readonly serviceLevelObjectiveUsageMetrics?: SloUsageMetric[];
    readonly currentServiceLevelObjective?: string;
    readonly currentServiceLevelObjectiveId?: string;
    readonly usageBasedRecommendationServiceLevelObjective?: string;
    readonly usageBasedRecommendationServiceLevelObjectiveId?: string;
    readonly databaseSizeBasedRecommendationServiceLevelObjective?: string;
    readonly databaseSizeBasedRecommendationServiceLevelObjectiveId?: string;
    readonly disasterPlanBasedRecommendationServiceLevelObjective?: string;
    readonly disasterPlanBasedRecommendationServiceLevelObjectiveId?: string;
    readonly overallRecommendationServiceLevelObjective?: string;
    readonly overallRecommendationServiceLevelObjectiveId?: string;
    readonly confidence?: number;
};

// @public
export interface ServiceTierAdvisorListResult {
    value: ServiceTierAdvisor[];
}

// @public
export interface ServiceTierAdvisors {
    get(resourceGroupName: string, serverName: string, databaseName: string, serviceTierAdvisorName: string, options?: coreHttp.OperationOptions): Promise<ServiceTierAdvisorsGetResponse>;
    listByDatabase(resourceGroupName: string, serverName: string, databaseName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<ServiceTierAdvisor>;
}

// @public
export type ServiceTierAdvisorsGetResponse = ServiceTierAdvisor & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServiceTierAdvisor;
    };
};

// @public
export type ServiceTierAdvisorsListByDatabaseResponse = ServiceTierAdvisorListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ServiceTierAdvisorListResult;
    };
};

// @public
export type ShortTermRetentionPolicyName = string;

// @public
export interface Sku {
    capacity?: number;
    family?: string;
    name: string;
    size?: string;
    tier?: string;
}

// @public
export interface SloUsageMetric {
    readonly inRangeTimeRatio?: number;
    readonly serviceLevelObjective?: ServiceObjectiveName;
    readonly serviceLevelObjectiveId?: string;
}

// @public (undocumented)
export class SqlManagementClient extends SqlManagementClientContext {
    constructor(credentials: coreHttp.TokenCredential | coreHttp.ServiceClientCredentials, subscriptionId: string, options?: SqlManagementClientOptionalParams);
    // (undocumented)
    backupLongTermRetentionPolicies: BackupLongTermRetentionPolicies;
    // (undocumented)
    backupShortTermRetentionPolicies: BackupShortTermRetentionPolicies;
    // (undocumented)
    capabilities: Capabilities;
    // (undocumented)
    databaseAutomaticTuning: DatabaseAutomaticTuning;
    // (undocumented)
    databaseBlobAuditingPolicies: DatabaseBlobAuditingPolicies;
    // (undocumented)
    databaseOperations: DatabaseOperations;
    // (undocumented)
    databases: Databases;
    // (undocumented)
    databaseThreatDetectionPolicies: DatabaseThreatDetectionPolicies;
    // (undocumented)
    databaseUsages: DatabaseUsages;
    // (undocumented)
    databaseVulnerabilityAssessmentRuleBaselines: DatabaseVulnerabilityAssessmentRuleBaselines;
    // (undocumented)
    databaseVulnerabilityAssessments: DatabaseVulnerabilityAssessments;
    // (undocumented)
    databaseVulnerabilityAssessmentScans: DatabaseVulnerabilityAssessmentScans;
    // (undocumented)
    dataMaskingPolicies: DataMaskingPolicies;
    // (undocumented)
    dataMaskingRules: DataMaskingRules;
    // (undocumented)
    elasticPoolActivities: ElasticPoolActivities;
    // (undocumented)
    elasticPoolDatabaseActivities: ElasticPoolDatabaseActivities;
    // (undocumented)
    elasticPoolOperations: ElasticPoolOperations;
    // (undocumented)
    elasticPools: ElasticPools;
    // (undocumented)
    encryptionProtectors: EncryptionProtectors;
    // (undocumented)
    extendedDatabaseBlobAuditingPolicies: ExtendedDatabaseBlobAuditingPolicies;
    // (undocumented)
    extendedServerBlobAuditingPolicies: ExtendedServerBlobAuditingPolicies;
    // (undocumented)
    failoverGroups: FailoverGroups;
    // (undocumented)
    firewallRules: FirewallRules;
    // (undocumented)
    geoBackupPolicies: GeoBackupPolicies;
    // (undocumented)
    instanceFailoverGroups: InstanceFailoverGroups;
    // (undocumented)
    instancePools: InstancePools;
    // (undocumented)
    jobAgents: JobAgents;
    // (undocumented)
    jobCredentials: JobCredentials;
    // (undocumented)
    jobExecutions: JobExecutions;
    // (undocumented)
    jobs: Jobs;
    // (undocumented)
    jobStepExecutions: JobStepExecutions;
    // (undocumented)
    jobSteps: JobSteps;
    // (undocumented)
    jobTargetExecutions: JobTargetExecutions;
    // (undocumented)
    jobTargetGroups: JobTargetGroups;
    // (undocumented)
    jobVersions: JobVersions;
    // (undocumented)
    longTermRetentionBackups: LongTermRetentionBackups;
    // (undocumented)
    longTermRetentionManagedInstanceBackups: LongTermRetentionManagedInstanceBackups;
    // (undocumented)
    managedBackupShortTermRetentionPolicies: ManagedBackupShortTermRetentionPolicies;
    // (undocumented)
    managedDatabaseRestoreDetails: ManagedDatabaseRestoreDetails;
    // (undocumented)
    managedDatabases: ManagedDatabases;
    // (undocumented)
    managedDatabaseSecurityAlertPolicies: ManagedDatabaseSecurityAlertPolicies;
    // (undocumented)
    managedDatabaseSensitivityLabels: ManagedDatabaseSensitivityLabels;
    // (undocumented)
    managedDatabaseVulnerabilityAssessmentRuleBaselines: ManagedDatabaseVulnerabilityAssessmentRuleBaselines;
    // (undocumented)
    managedDatabaseVulnerabilityAssessments: ManagedDatabaseVulnerabilityAssessments;
    // (undocumented)
    managedDatabaseVulnerabilityAssessmentScans: ManagedDatabaseVulnerabilityAssessmentScans;
    // (undocumented)
    managedInstanceAdministrators: ManagedInstanceAdministrators;
    // (undocumented)
    managedInstanceEncryptionProtectors: ManagedInstanceEncryptionProtectors;
    // (undocumented)
    managedInstanceKeys: ManagedInstanceKeys;
    // (undocumented)
    managedInstanceLongTermRetentionPolicies: ManagedInstanceLongTermRetentionPolicies;
    // (undocumented)
    managedInstanceOperations: ManagedInstanceOperations;
    // (undocumented)
    managedInstances: ManagedInstances;
    // (undocumented)
    managedInstanceTdeCertificates: ManagedInstanceTdeCertificates;
    // (undocumented)
    managedInstanceVulnerabilityAssessments: ManagedInstanceVulnerabilityAssessments;
    // (undocumented)
    managedRestorableDroppedDatabaseBackupShortTermRetentionPolicies: ManagedRestorableDroppedDatabaseBackupShortTermRetentionPolicies;
    // (undocumented)
    managedServerSecurityAlertPolicies: ManagedServerSecurityAlertPolicies;
    // (undocumented)
    operations: Operations;
    // (undocumented)
    privateEndpointConnections: PrivateEndpointConnections;
    // (undocumented)
    privateLinkResources: PrivateLinkResources;
    // (undocumented)
    recommendedElasticPools: RecommendedElasticPools;
    // (undocumented)
    recoverableDatabases: RecoverableDatabases;
    // (undocumented)
    recoverableManagedDatabases: RecoverableManagedDatabases;
    // (undocumented)
    replicationLinks: ReplicationLinks;
    // (undocumented)
    restorableDroppedDatabases: RestorableDroppedDatabases;
    // (undocumented)
    restorableDroppedManagedDatabases: RestorableDroppedManagedDatabases;
    // (undocumented)
    restorePoints: RestorePoints;
    // (undocumented)
    sensitivityLabels: SensitivityLabels;
    // (undocumented)
    serverAutomaticTuning: ServerAutomaticTuning;
    // (undocumented)
    serverAzureADAdministrators: ServerAzureADAdministrators;
    // (undocumented)
    serverBlobAuditingPolicies: ServerBlobAuditingPolicies;
    // (undocumented)
    serverCommunicationLinks: ServerCommunicationLinks;
    // (undocumented)
    serverConnectionPolicies: ServerConnectionPolicies;
    // (undocumented)
    serverDnsAliases: ServerDnsAliases;
    // (undocumented)
    serverKeys: ServerKeys;
    // (undocumented)
    servers: Servers;
    // (undocumented)
    serverSecurityAlertPolicies: ServerSecurityAlertPolicies;
    // (undocumented)
    serverUsages: ServerUsages;
    // (undocumented)
    serverVulnerabilityAssessments: ServerVulnerabilityAssessments;
    // (undocumented)
    serviceObjectives: ServiceObjectives;
    // (undocumented)
    serviceTierAdvisors: ServiceTierAdvisors;
    // (undocumented)
    subscriptionUsages: SubscriptionUsages;
    // (undocumented)
    syncAgents: SyncAgents;
    // (undocumented)
    syncGroups: SyncGroups;
    // (undocumented)
    syncMembers: SyncMembers;
    // (undocumented)
    tdeCertificates: TdeCertificates;
    // (undocumented)
    transparentDataEncryptionActivities: TransparentDataEncryptionActivities;
    // (undocumented)
    transparentDataEncryptions: TransparentDataEncryptions;
    // (undocumented)
    usages: Usages;
    // (undocumented)
    virtualClusters: VirtualClusters;
    // (undocumented)
    virtualNetworkRules: VirtualNetworkRules;
    // (undocumented)
    workloadClassifiers: WorkloadClassifiers;
    // (undocumented)
    workloadGroups: WorkloadGroups;
}

// @public (undocumented)
export class SqlManagementClientContext extends coreHttp.ServiceClient {
    // (undocumented)
    $host: string;
    constructor(credentials: coreHttp.TokenCredential | coreHttp.ServiceClientCredentials, subscriptionId: string, options?: SqlManagementClientOptionalParams);
    // (undocumented)
    subscriptionId: string;
}

// @public
export interface SqlManagementClientOptionalParams extends coreHttp.ServiceClientOptions {
    $host?: string;
    endpoint?: string;
}

// @public
export interface StorageCapability {
    reason?: string;
    readonly status?: CapabilityStatus;
    readonly storageAccountType?: StorageCapabilityStorageAccountType;
}

// @public
export type StorageCapabilityStorageAccountType = string;

// @public
export type StorageKeyType = "StorageAccessKey" | "SharedAccessKey";

// @public
export type SubscriptionUsage = ProxyResource & {
    readonly displayName?: string;
    readonly currentValue?: number;
    readonly limit?: number;
    readonly unit?: string;
};

// @public
export interface SubscriptionUsageListResult {
    readonly nextLink?: string;
    readonly value?: SubscriptionUsage[];
}

// @public
export interface SubscriptionUsages {
    get(locationName: string, usageName: string, options?: coreHttp.OperationOptions): Promise<SubscriptionUsagesGetResponse>;
    listByLocation(locationName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<SubscriptionUsage>;
}

// @public
export type SubscriptionUsagesGetResponse = SubscriptionUsage & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SubscriptionUsage;
    };
};

// @public
export type SubscriptionUsagesListByLocationNextResponse = SubscriptionUsageListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SubscriptionUsageListResult;
    };
};

// @public
export type SubscriptionUsagesListByLocationResponse = SubscriptionUsageListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SubscriptionUsageListResult;
    };
};

// @public
export type SyncAgent = ProxyResource & {
    readonly namePropertiesName?: string;
    syncDatabaseId?: string;
    readonly lastAliveTime?: Date;
    readonly state?: SyncAgentState;
    readonly isUpToDate?: boolean;
    readonly expiryTime?: Date;
    readonly version?: string;
};

// @public
export interface SyncAgentKeyProperties {
    readonly syncAgentKey?: string;
}

// @public
export type SyncAgentLinkedDatabase = ProxyResource & {
    readonly databaseType?: SyncMemberDbType;
    readonly databaseId?: string;
    readonly description?: string;
    readonly serverName?: string;
    readonly databaseName?: string;
    readonly userName?: string;
};

// @public
export interface SyncAgentLinkedDatabaseListResult {
    readonly nextLink?: string;
    readonly value?: SyncAgentLinkedDatabase[];
}

// @public
export interface SyncAgentListResult {
    readonly nextLink?: string;
    readonly value?: SyncAgent[];
}

// @public
export interface SyncAgents {
    createOrUpdate(resourceGroupName: string, serverName: string, syncAgentName: string, parameters: SyncAgent, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<SyncAgentsCreateOrUpdateResponse>, SyncAgentsCreateOrUpdateResponse>>;
    delete(resourceGroupName: string, serverName: string, syncAgentName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    generateKey(resourceGroupName: string, serverName: string, syncAgentName: string, options?: coreHttp.OperationOptions): Promise<SyncAgentsGenerateKeyResponse>;
    get(resourceGroupName: string, serverName: string, syncAgentName: string, options?: coreHttp.OperationOptions): Promise<SyncAgentsGetResponse>;
    listByServer(resourceGroupName: string, serverName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<SyncAgent>;
    listLinkedDatabases(resourceGroupName: string, serverName: string, syncAgentName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<SyncAgentLinkedDatabase>;
}

// @public
export type SyncAgentsCreateOrUpdateResponse = SyncAgent & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SyncAgent;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type SyncAgentsGenerateKeyResponse = SyncAgentKeyProperties & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SyncAgentKeyProperties;
    };
};

// @public
export type SyncAgentsGetResponse = SyncAgent & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SyncAgent;
    };
};

// @public
export type SyncAgentsListByServerNextResponse = SyncAgentListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SyncAgentListResult;
    };
};

// @public
export type SyncAgentsListByServerResponse = SyncAgentListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SyncAgentListResult;
    };
};

// @public
export type SyncAgentsListLinkedDatabasesNextResponse = SyncAgentLinkedDatabaseListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SyncAgentLinkedDatabaseListResult;
    };
};

// @public
export type SyncAgentsListLinkedDatabasesResponse = SyncAgentLinkedDatabaseListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SyncAgentLinkedDatabaseListResult;
    };
};

// @public
export type SyncAgentState = string;

// @public
export type SyncConflictResolutionPolicy = string;

// @public
export interface SyncDatabaseIdListResult {
    readonly nextLink?: string;
    readonly value?: SyncDatabaseIdProperties[];
}

// @public
export interface SyncDatabaseIdProperties {
    readonly id?: string;
}

// @public
export type SyncDirection = string;

// @public
export interface SyncFullSchemaProperties {
    readonly lastUpdateTime?: Date;
    readonly tables?: SyncFullSchemaTable[];
}

// @public
export interface SyncFullSchemaPropertiesListResult {
    readonly nextLink?: string;
    readonly value?: SyncFullSchemaProperties[];
}

// @public
export interface SyncFullSchemaTable {
    readonly columns?: SyncFullSchemaTableColumn[];
    readonly errorId?: string;
    readonly hasError?: boolean;
    readonly name?: string;
    readonly quotedName?: string;
}

// @public
export interface SyncFullSchemaTableColumn {
    readonly dataSize?: string;
    readonly dataType?: string;
    readonly errorId?: string;
    readonly hasError?: boolean;
    readonly isPrimaryKey?: boolean;
    readonly name?: string;
    readonly quotedName?: string;
}

// @public
export type SyncGroup = ProxyResource & {
    interval?: number;
    readonly lastSyncTime?: Date;
    conflictResolutionPolicy?: SyncConflictResolutionPolicy;
    syncDatabaseId?: string;
    hubDatabaseUserName?: string;
    hubDatabasePassword?: string;
    readonly syncState?: SyncGroupState;
    schema?: SyncGroupSchema;
};

// @public
export interface SyncGroupListResult {
    readonly nextLink?: string;
    readonly value?: SyncGroup[];
}

// @public
export interface SyncGroupLogListResult {
    readonly nextLink?: string;
    readonly value?: SyncGroupLogProperties[];
}

// @public
export interface SyncGroupLogProperties {
    readonly details?: string;
    readonly operationStatus?: string;
    readonly source?: string;
    readonly timestamp?: Date;
    readonly tracingId?: string;
    readonly type?: SyncGroupLogType;
}

// @public
export type SyncGroupLogType = string;

// @public
export interface SyncGroups {
    cancelSync(resourceGroupName: string, serverName: string, databaseName: string, syncGroupName: string, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    createOrUpdate(resourceGroupName: string, serverName: string, databaseName: string, syncGroupName: string, parameters: SyncGroup, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<SyncGroupsCreateOrUpdateResponse>, SyncGroupsCreateOrUpdateResponse>>;
    delete(resourceGroupName: string, serverName: string, databaseName: string, syncGroupName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    get(resourceGroupName: string, serverName: string, databaseName: string, syncGroupName: string, options?: coreHttp.OperationOptions): Promise<SyncGroupsGetResponse>;
    listByDatabase(resourceGroupName: string, serverName: string, databaseName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<SyncGroup>;
    listHubSchemas(resourceGroupName: string, serverName: string, databaseName: string, syncGroupName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<SyncFullSchemaProperties>;
    listLogs(resourceGroupName: string, serverName: string, databaseName: string, syncGroupName: string, startTime: string, endTime: string, typeParam: Enum21, options?: SyncGroupsListLogsOptionalParams): PagedAsyncIterableIterator<SyncGroupLogProperties>;
    listSyncDatabaseIds(locationName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<SyncDatabaseIdProperties>;
    refreshHubSchema(resourceGroupName: string, serverName: string, databaseName: string, syncGroupName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    triggerSync(resourceGroupName: string, serverName: string, databaseName: string, syncGroupName: string, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    update(resourceGroupName: string, serverName: string, databaseName: string, syncGroupName: string, parameters: SyncGroup, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<SyncGroupsUpdateResponse>, SyncGroupsUpdateResponse>>;
}

// @public
export interface SyncGroupSchema {
    masterSyncMemberName?: string;
    tables?: SyncGroupSchemaTable[];
}

// @public
export interface SyncGroupSchemaTable {
    columns?: SyncGroupSchemaTableColumn[];
    quotedName?: string;
}

// @public
export interface SyncGroupSchemaTableColumn {
    dataSize?: string;
    dataType?: string;
    quotedName?: string;
}

// @public
export type SyncGroupsCreateOrUpdateResponse = SyncGroup & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SyncGroup;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type SyncGroupsGetResponse = SyncGroup & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SyncGroup;
    };
};

// @public
export type SyncGroupsListByDatabaseNextResponse = SyncGroupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SyncGroupListResult;
    };
};

// @public
export type SyncGroupsListByDatabaseResponse = SyncGroupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SyncGroupListResult;
    };
};

// @public
export type SyncGroupsListHubSchemasNextResponse = SyncFullSchemaPropertiesListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SyncFullSchemaPropertiesListResult;
    };
};

// @public
export type SyncGroupsListHubSchemasResponse = SyncFullSchemaPropertiesListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SyncFullSchemaPropertiesListResult;
    };
};

// @public
export interface SyncGroupsListLogsNextOptionalParams extends coreHttp.OperationOptions {
    continuationToken?: string;
}

// @public
export type SyncGroupsListLogsNextResponse = SyncGroupLogListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SyncGroupLogListResult;
    };
};

// @public
export interface SyncGroupsListLogsOptionalParams extends coreHttp.OperationOptions {
    continuationToken?: string;
}

// @public
export type SyncGroupsListLogsResponse = SyncGroupLogListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SyncGroupLogListResult;
    };
};

// @public
export type SyncGroupsListSyncDatabaseIdsNextResponse = SyncDatabaseIdListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SyncDatabaseIdListResult;
    };
};

// @public
export type SyncGroupsListSyncDatabaseIdsResponse = SyncDatabaseIdListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SyncDatabaseIdListResult;
    };
};

// @public
export type SyncGroupState = string;

// @public
export type SyncGroupsUpdateResponse = SyncGroup & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SyncGroup;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type SyncMember = ProxyResource & {
    databaseType?: SyncMemberDbType;
    syncAgentId?: string;
    sqlServerDatabaseId?: string;
    serverName?: string;
    databaseName?: string;
    userName?: string;
    password?: string;
    syncDirection?: SyncDirection;
    readonly syncState?: SyncMemberState;
};

// @public
export type SyncMemberDbType = string;

// @public
export interface SyncMemberListResult {
    readonly nextLink?: string;
    readonly value?: SyncMember[];
}

// @public
export interface SyncMembers {
    createOrUpdate(resourceGroupName: string, serverName: string, databaseName: string, syncGroupName: string, syncMemberName: string, parameters: SyncMember, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<SyncMembersCreateOrUpdateResponse>, SyncMembersCreateOrUpdateResponse>>;
    delete(resourceGroupName: string, serverName: string, databaseName: string, syncGroupName: string, syncMemberName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    get(resourceGroupName: string, serverName: string, databaseName: string, syncGroupName: string, syncMemberName: string, options?: coreHttp.OperationOptions): Promise<SyncMembersGetResponse>;
    listBySyncGroup(resourceGroupName: string, serverName: string, databaseName: string, syncGroupName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<SyncMember>;
    listMemberSchemas(resourceGroupName: string, serverName: string, databaseName: string, syncGroupName: string, syncMemberName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<SyncFullSchemaProperties>;
    refreshMemberSchema(resourceGroupName: string, serverName: string, databaseName: string, syncGroupName: string, syncMemberName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    update(resourceGroupName: string, serverName: string, databaseName: string, syncGroupName: string, syncMemberName: string, parameters: SyncMember, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<SyncMembersUpdateResponse>, SyncMembersUpdateResponse>>;
}

// @public
export type SyncMembersCreateOrUpdateResponse = SyncMember & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SyncMember;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type SyncMembersGetResponse = SyncMember & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SyncMember;
    };
};

// @public
export type SyncMembersListBySyncGroupNextResponse = SyncMemberListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SyncMemberListResult;
    };
};

// @public
export type SyncMembersListBySyncGroupResponse = SyncMemberListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SyncMemberListResult;
    };
};

// @public
export type SyncMembersListMemberSchemasNextResponse = SyncFullSchemaPropertiesListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SyncFullSchemaPropertiesListResult;
    };
};

// @public
export type SyncMembersListMemberSchemasResponse = SyncFullSchemaPropertiesListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SyncFullSchemaPropertiesListResult;
    };
};

// @public
export type SyncMemberState = string;

// @public
export type SyncMembersUpdateResponse = SyncMember & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: SyncMember;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type TdeCertificate = ProxyResource & {
    privateBlob?: string;
    certPassword?: string;
};

// @public
export interface TdeCertificates {
    create(resourceGroupName: string, serverName: string, parameters: TdeCertificate, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
}

// @public
export type TrackedResource = Resource & {
    location: string;
    tags?: {
        [propertyName: string]: string;
    };
};

// @public
export type TransparentDataEncryption = ProxyResource & {
    readonly location?: string;
    status?: TransparentDataEncryptionStatus;
};

// @public
export interface TransparentDataEncryptionActivities {
    listByConfiguration(resourceGroupName: string, serverName: string, databaseName: string, transparentDataEncryptionName: TransparentDataEncryptionName, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<TransparentDataEncryptionActivity>;
}

// @public
export type TransparentDataEncryptionActivitiesListByConfigurationResponse = TransparentDataEncryptionActivityListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: TransparentDataEncryptionActivityListResult;
    };
};

// @public
export type TransparentDataEncryptionActivity = ProxyResource & {
    readonly location?: string;
    readonly status?: TransparentDataEncryptionActivityStatus;
    readonly percentComplete?: number;
};

// @public
export interface TransparentDataEncryptionActivityListResult {
    value: TransparentDataEncryptionActivity[];
}

// @public
export type TransparentDataEncryptionActivityStatus = string;

// @public
export type TransparentDataEncryptionName = string;

// @public
export interface TransparentDataEncryptions {
    createOrUpdate(resourceGroupName: string, serverName: string, databaseName: string, transparentDataEncryptionName: TransparentDataEncryptionName, parameters: TransparentDataEncryption, options?: coreHttp.OperationOptions): Promise<TransparentDataEncryptionsCreateOrUpdateResponse>;
    get(resourceGroupName: string, serverName: string, databaseName: string, transparentDataEncryptionName: TransparentDataEncryptionName, options?: coreHttp.OperationOptions): Promise<TransparentDataEncryptionsGetResponse>;
}

// @public
export type TransparentDataEncryptionsCreateOrUpdateResponse = TransparentDataEncryption & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: TransparentDataEncryption;
    };
};

// @public
export type TransparentDataEncryptionsGetResponse = TransparentDataEncryption & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: TransparentDataEncryption;
    };
};

// @public
export type TransparentDataEncryptionStatus = "Enabled" | "Disabled";

// @public
export type UnitDefinitionType = string;

// @public
export type UnitType = string;

// @public
export interface UnlinkParameters {
    forcedTermination?: boolean;
}

// @public
export interface Usage {
    readonly currentValue?: number;
    readonly id?: string;
    readonly limit?: number;
    readonly name?: Name;
    readonly requestedLimit?: number;
    readonly type?: string;
    readonly unit?: string;
}

// @public
export interface UsageListResult {
    readonly nextLink?: string;
    readonly value?: Usage[];
}

// @public
export interface Usages {
    listByInstancePool(resourceGroupName: string, instancePoolName: string, options?: UsagesListByInstancePoolOptionalParams): PagedAsyncIterableIterator<Usage>;
}

// @public
export interface UsagesListByInstancePoolNextOptionalParams extends coreHttp.OperationOptions {
    expandChildren?: boolean;
}

// @public
export type UsagesListByInstancePoolNextResponse = UsageListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: UsageListResult;
    };
};

// @public
export interface UsagesListByInstancePoolOptionalParams extends coreHttp.OperationOptions {
    expandChildren?: boolean;
}

// @public
export type UsagesListByInstancePoolResponse = UsageListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: UsageListResult;
    };
};

// @public
export type VirtualCluster = TrackedResource & {
    readonly subnetId?: string;
    family?: string;
    readonly childResources?: string[];
};

// @public
export interface VirtualClusterListResult {
    readonly nextLink?: string;
    readonly value?: VirtualCluster[];
}

// @public
export interface VirtualClusters {
    delete(resourceGroupName: string, virtualClusterName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    get(resourceGroupName: string, virtualClusterName: string, options?: coreHttp.OperationOptions): Promise<VirtualClustersGetResponse>;
    list(options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<VirtualCluster>;
    listByResourceGroup(resourceGroupName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<VirtualCluster>;
    update(resourceGroupName: string, virtualClusterName: string, parameters: VirtualClusterUpdate, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<VirtualClustersUpdateResponse>, VirtualClustersUpdateResponse>>;
}

// @public
export type VirtualClustersGetResponse = VirtualCluster & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: VirtualCluster;
    };
};

// @public
export type VirtualClustersListByResourceGroupNextResponse = VirtualClusterListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: VirtualClusterListResult;
    };
};

// @public
export type VirtualClustersListByResourceGroupResponse = VirtualClusterListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: VirtualClusterListResult;
    };
};

// @public
export type VirtualClustersListNextResponse = VirtualClusterListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: VirtualClusterListResult;
    };
};

// @public
export type VirtualClustersListResponse = VirtualClusterListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: VirtualClusterListResult;
    };
};

// @public
export type VirtualClustersUpdateResponse = VirtualCluster & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: VirtualCluster;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export interface VirtualClusterUpdate {
    readonly childResources?: string[];
    family?: string;
    readonly subnetId?: string;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export type VirtualNetworkRule = ProxyResource & {
    virtualNetworkSubnetId?: string;
    ignoreMissingVnetServiceEndpoint?: boolean;
    readonly state?: VirtualNetworkRuleState;
};

// @public
export interface VirtualNetworkRuleListResult {
    readonly nextLink?: string;
    readonly value?: VirtualNetworkRule[];
}

// @public
export interface VirtualNetworkRules {
    createOrUpdate(resourceGroupName: string, serverName: string, virtualNetworkRuleName: string, parameters: VirtualNetworkRule, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<VirtualNetworkRulesCreateOrUpdateResponse>, VirtualNetworkRulesCreateOrUpdateResponse>>;
    delete(resourceGroupName: string, serverName: string, virtualNetworkRuleName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    get(resourceGroupName: string, serverName: string, virtualNetworkRuleName: string, options?: coreHttp.OperationOptions): Promise<VirtualNetworkRulesGetResponse>;
    listByServer(resourceGroupName: string, serverName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<VirtualNetworkRule>;
}

// @public
export type VirtualNetworkRulesCreateOrUpdateResponse = VirtualNetworkRule & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: VirtualNetworkRule;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type VirtualNetworkRulesGetResponse = VirtualNetworkRule & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: VirtualNetworkRule;
    };
};

// @public
export type VirtualNetworkRulesListByServerNextResponse = VirtualNetworkRuleListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: VirtualNetworkRuleListResult;
    };
};

// @public
export type VirtualNetworkRulesListByServerResponse = VirtualNetworkRuleListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: VirtualNetworkRuleListResult;
    };
};

// @public
export type VirtualNetworkRuleState = string;

// @public
export type VulnerabilityAssessmentName = string;

// @public
export type VulnerabilityAssessmentPolicyBaselineName = "master" | "default";

// @public
export interface VulnerabilityAssessmentRecurringScansProperties {
    emails?: string[];
    emailSubscriptionAdmins?: boolean;
    isEnabled?: boolean;
}

// @public
export interface VulnerabilityAssessmentScanError {
    readonly code?: string;
    readonly message?: string;
}

// @public
export type VulnerabilityAssessmentScanRecord = ProxyResource & {
    readonly scanId?: string;
    readonly triggerType?: VulnerabilityAssessmentScanTriggerType;
    readonly state?: VulnerabilityAssessmentScanState;
    readonly startTime?: Date;
    readonly endTime?: Date;
    readonly errors?: VulnerabilityAssessmentScanError[];
    readonly storageContainerPath?: string;
    readonly numberOfFailedSecurityChecks?: number;
};

// @public
export interface VulnerabilityAssessmentScanRecordListResult {
    readonly nextLink?: string;
    readonly value?: VulnerabilityAssessmentScanRecord[];
}

// @public
export type VulnerabilityAssessmentScanState = string;

// @public
export type VulnerabilityAssessmentScanTriggerType = string;

// @public
export type WorkloadClassifier = ProxyResource & {
    memberName?: string;
    label?: string;
    context?: string;
    startTime?: string;
    endTime?: string;
    importance?: string;
};

// @public
export interface WorkloadClassifierListResult {
    readonly nextLink?: string;
    readonly value?: WorkloadClassifier[];
}

// @public
export interface WorkloadClassifiers {
    createOrUpdate(resourceGroupName: string, serverName: string, databaseName: string, workloadGroupName: string, workloadClassifierName: string, parameters: WorkloadClassifier, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<WorkloadClassifiersCreateOrUpdateResponse>, WorkloadClassifiersCreateOrUpdateResponse>>;
    delete(resourceGroupName: string, serverName: string, databaseName: string, workloadGroupName: string, workloadClassifierName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    get(resourceGroupName: string, serverName: string, databaseName: string, workloadGroupName: string, workloadClassifierName: string, options?: coreHttp.OperationOptions): Promise<WorkloadClassifiersGetResponse>;
    listByWorkloadGroup(resourceGroupName: string, serverName: string, databaseName: string, workloadGroupName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<WorkloadClassifier>;
}

// @public
export type WorkloadClassifiersCreateOrUpdateResponse = WorkloadClassifier & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: WorkloadClassifier;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type WorkloadClassifiersGetResponse = WorkloadClassifier & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: WorkloadClassifier;
    };
};

// @public
export type WorkloadClassifiersListByWorkloadGroupNextResponse = WorkloadClassifierListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: WorkloadClassifierListResult;
    };
};

// @public
export type WorkloadClassifiersListByWorkloadGroupResponse = WorkloadClassifierListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: WorkloadClassifierListResult;
    };
};

// @public
export type WorkloadGroup = ProxyResource & {
    minResourcePercent?: number;
    maxResourcePercent?: number;
    minResourcePercentPerRequest?: number;
    maxResourcePercentPerRequest?: number;
    importance?: string;
    queryExecutionTimeout?: number;
};

// @public
export interface WorkloadGroupListResult {
    readonly nextLink?: string;
    readonly value?: WorkloadGroup[];
}

// @public
export interface WorkloadGroups {
    createOrUpdate(resourceGroupName: string, serverName: string, databaseName: string, workloadGroupName: string, parameters: WorkloadGroup, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<WorkloadGroupsCreateOrUpdateResponse>, WorkloadGroupsCreateOrUpdateResponse>>;
    delete(resourceGroupName: string, serverName: string, databaseName: string, workloadGroupName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    get(resourceGroupName: string, serverName: string, databaseName: string, workloadGroupName: string, options?: coreHttp.OperationOptions): Promise<WorkloadGroupsGetResponse>;
    listByDatabase(resourceGroupName: string, serverName: string, databaseName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<WorkloadGroup>;
}

// @public
export type WorkloadGroupsCreateOrUpdateResponse = WorkloadGroup & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: WorkloadGroup;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type WorkloadGroupsGetResponse = WorkloadGroup & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: WorkloadGroup;
    };
};

// @public
export type WorkloadGroupsListByDatabaseNextResponse = WorkloadGroupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: WorkloadGroupListResult;
    };
};

// @public
export type WorkloadGroupsListByDatabaseResponse = WorkloadGroupListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: WorkloadGroupListResult;
    };
};


// Warnings were encountered during analysis:
//
// src/models/index.ts:10145:5 - (ae-forgotten-export) The symbol "LROResponseInfo" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
