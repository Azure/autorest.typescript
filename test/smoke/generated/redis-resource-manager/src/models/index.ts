/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as coreHttp from "@azure/core-http";

/**
 * Result of the request to list REST API operations. It contains a list of operations and a URL nextLink to get the next set of results.
 */
export interface OperationListResult {
  /**
   * List of operations supported by the resource provider.
   */
  value?: Operation[];
  /**
   * URL to get the next set of operation list results if there are any.
   */
  readonly nextLink?: string;
}

/**
 * REST API operation
 */
export interface Operation {
  /**
   * Operation name: {provider}/{resource}/{operation}
   */
  name?: string;
  /**
   * The object that describes the operation.
   */
  display?: OperationDisplay;
}

/**
 * The object that describes the operation.
 */
export interface OperationDisplay {
  /**
   * Friendly name of the resource provider
   */
  provider?: string;
  /**
   * Operation type: read, write, delete, listKeys/action, etc.
   */
  operation?: string;
  /**
   * Resource type on which the operation is performed.
   */
  resource?: string;
  /**
   * Friendly name of the operation
   */
  description?: string;
}

/**
 * Parameters body to pass for resource name availability check.
 */
export interface CheckNameAvailabilityParameters {
  /**
   * Resource name.
   */
  name: string;
  /**
   * Resource type. The only legal value of this property for checking redis cache name availability is 'Microsoft.Cache/redis'.
   */
  typeModel: string;
}

/**
 * The response of listUpgradeNotifications.
 */
export interface NotificationListResponse {
  /**
   * List of all notifications.
   */
  value?: UpgradeNotification[];
  /**
   * Link for next set of notifications.
   */
  readonly nextLink?: string;
}

/**
 * Properties of upgrade notification.
 */
export interface UpgradeNotification {
  /**
   * Name of upgrade notification.
   */
  readonly name?: string;
  /**
   * Timestamp when upgrade notification occurred.
   */
  readonly timestamp?: Date;
  /**
   * Details about this upgrade notification
   */
  readonly upsellNotification?: { [propertyName: string]: string };
}

/**
 * Parameters supplied to the Create Redis operation.
 */
export interface RedisCreateParameters {
  /**
   * A list of availability zones denoting where the resource needs to come from.
   */
  zones?: string[];
  /**
   * The geo-location where the resource lives
   */
  location: string;
  /**
   * Resource tags.
   */
  tags?: { [propertyName: string]: string };
  /**
   * All Redis Settings. Few possible keys: rdb-backup-enabled,rdb-storage-connection-string,rdb-backup-frequency,maxmemory-delta,maxmemory-policy,notify-keyspace-events,maxmemory-samples,slowlog-log-slower-than,slowlog-max-len,list-max-ziplist-entries,list-max-ziplist-value,hash-max-ziplist-entries,hash-max-ziplist-value,set-max-intset-entries,zset-max-ziplist-entries,zset-max-ziplist-value etc.
   */
  redisConfiguration?: { [propertyName: string]: string };
  /**
   * Specifies whether the non-ssl Redis server port (6379) is enabled.
   */
  enableNonSslPort?: boolean;
  /**
   * The number of replicas to be created per master.
   */
  replicasPerMaster?: number;
  /**
   * A dictionary of tenant settings
   */
  tenantSettings?: { [propertyName: string]: string };
  /**
   * The number of shards to be created on a Premium Cluster Cache.
   */
  shardCount?: number;
  /**
   * Optional: requires clients to use a specified TLS version (or higher) to connect (e,g, '1.0', '1.1', '1.2')
   */
  minimumTlsVersion?: TlsVersion;
  /**
   * The SKU of the Redis cache to deploy.
   */
  sku: Sku;
  /**
   * The full resource ID of a subnet in a virtual network to deploy the Redis cache in. Example format: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/Microsoft.{Network|ClassicNetwork}/VirtualNetworks/vnet1/subnets/subnet1
   */
  subnetId?: string;
  /**
   * Static IP address. Required when deploying a Redis cache inside an existing Azure Virtual Network.
   */
  staticIP?: string;
}

/**
 * Create/Update/Get common properties of the redis cache.
 */
export interface RedisCommonProperties {
  /**
   * All Redis Settings. Few possible keys: rdb-backup-enabled,rdb-storage-connection-string,rdb-backup-frequency,maxmemory-delta,maxmemory-policy,notify-keyspace-events,maxmemory-samples,slowlog-log-slower-than,slowlog-max-len,list-max-ziplist-entries,list-max-ziplist-value,hash-max-ziplist-entries,hash-max-ziplist-value,set-max-intset-entries,zset-max-ziplist-entries,zset-max-ziplist-value etc.
   */
  redisConfiguration?: { [propertyName: string]: string };
  /**
   * Specifies whether the non-ssl Redis server port (6379) is enabled.
   */
  enableNonSslPort?: boolean;
  /**
   * The number of replicas to be created per master.
   */
  replicasPerMaster?: number;
  /**
   * A dictionary of tenant settings
   */
  tenantSettings?: { [propertyName: string]: string };
  /**
   * The number of shards to be created on a Premium Cluster Cache.
   */
  shardCount?: number;
  /**
   * Optional: requires clients to use a specified TLS version (or higher) to connect (e,g, '1.0', '1.1', '1.2')
   */
  minimumTlsVersion?: TlsVersion;
}

/**
 * Properties supplied to Create Redis operation.
 */
export type RedisCreateProperties = RedisCommonProperties & {
  /**
   * The SKU of the Redis cache to deploy.
   */
  sku: Sku;
  /**
   * The full resource ID of a subnet in a virtual network to deploy the Redis cache in. Example format: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/Microsoft.{Network|ClassicNetwork}/VirtualNetworks/vnet1/subnets/subnet1
   */
  subnetId?: string;
  /**
   * Static IP address. Required when deploying a Redis cache inside an existing Azure Virtual Network.
   */
  staticIP?: string;
};

/**
 * SKU parameters supplied to the create Redis operation.
 */
export interface Sku {
  /**
   * The type of Redis cache to deploy. Valid values: (Basic, Standard, Premium)
   */
  name: SkuName;
  /**
   * The SKU family to use. Valid values: (C, P). (C = Basic/Standard, P = Premium).
   */
  family: SkuFamily;
  /**
   * The size of the Redis cache to deploy. Valid values: for C (Basic/Standard) family (0, 1, 2, 3, 4, 5, 6), for P (Premium) family (1, 2, 3, 4).
   */
  capacity: number;
}

/**
 * The Resource definition.
 */
export interface Resource {
  /**
   * Resource ID.
   */
  readonly id?: string;
  /**
   * Resource name.
   */
  readonly name?: string;
  /**
   * Resource type.
   */
  readonly typeModel?: string;
}

/**
 * The resource model definition for a ARM tracked top level resource
 */
export type TrackedResource = Resource & {
  /**
   * Resource tags.
   */
  tags?: { [propertyName: string]: string };
  /**
   * The geo-location where the resource lives
   */
  location: string;
};

/**
 * A single Redis item in List or Get Operation.
 */
export type RedisResource = TrackedResource & {
  /**
   * A list of availability zones denoting where the resource needs to come from.
   */
  zones?: string[];
  /**
   * All Redis Settings. Few possible keys: rdb-backup-enabled,rdb-storage-connection-string,rdb-backup-frequency,maxmemory-delta,maxmemory-policy,notify-keyspace-events,maxmemory-samples,slowlog-log-slower-than,slowlog-max-len,list-max-ziplist-entries,list-max-ziplist-value,hash-max-ziplist-entries,hash-max-ziplist-value,set-max-intset-entries,zset-max-ziplist-entries,zset-max-ziplist-value etc.
   */
  redisConfiguration?: { [propertyName: string]: string };
  /**
   * Specifies whether the non-ssl Redis server port (6379) is enabled.
   */
  enableNonSslPort?: boolean;
  /**
   * The number of replicas to be created per master.
   */
  replicasPerMaster?: number;
  /**
   * A dictionary of tenant settings
   */
  tenantSettings?: { [propertyName: string]: string };
  /**
   * The number of shards to be created on a Premium Cluster Cache.
   */
  shardCount?: number;
  /**
   * Optional: requires clients to use a specified TLS version (or higher) to connect (e,g, '1.0', '1.1', '1.2')
   */
  minimumTlsVersion?: TlsVersion;
  /**
   * The SKU of the Redis cache to deploy.
   */
  sku: Sku;
  /**
   * The full resource ID of a subnet in a virtual network to deploy the Redis cache in. Example format: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/Microsoft.{Network|ClassicNetwork}/VirtualNetworks/vnet1/subnets/subnet1
   */
  subnetId?: string;
  /**
   * Static IP address. Required when deploying a Redis cache inside an existing Azure Virtual Network.
   */
  staticIP?: string;
  /**
   * Redis version.
   */
  readonly redisVersion?: string;
  /**
   * Redis instance provisioning status.
   */
  readonly provisioningState?: ProvisioningState;
  /**
   * Redis host name.
   */
  readonly hostName?: string;
  /**
   * Redis non-SSL port.
   */
  readonly port?: number;
  /**
   * Redis SSL port.
   */
  readonly sslPort?: number;
  /**
   * The keys of the Redis cache - not set if this object is not the response to Create or Update redis cache
   */
  readonly accessKeys?: RedisAccessKeys;
  /**
   * List of the linked servers associated with the cache
   */
  readonly linkedServers?: RedisLinkedServer[];
  /**
   * List of the Redis instances associated with the cache
   */
  readonly instances?: RedisInstanceDetails[];
};

/**
 * Properties of the redis cache.
 */
export type RedisProperties = RedisCreateProperties & {
  /**
   * Redis version.
   */
  readonly redisVersion?: string;
  /**
   * Redis instance provisioning status.
   */
  readonly provisioningState?: ProvisioningState;
  /**
   * Redis host name.
   */
  readonly hostName?: string;
  /**
   * Redis non-SSL port.
   */
  readonly port?: number;
  /**
   * Redis SSL port.
   */
  readonly sslPort?: number;
  /**
   * The keys of the Redis cache - not set if this object is not the response to Create or Update redis cache
   */
  readonly accessKeys?: RedisAccessKeys;
  /**
   * List of the linked servers associated with the cache
   */
  readonly linkedServers?: RedisLinkedServer[];
  /**
   * List of the Redis instances associated with the cache
   */
  readonly instances?: RedisInstanceDetails[];
};

/**
 * Redis cache access keys.
 */
export interface RedisAccessKeys {
  /**
   * The current primary key that clients can use to authenticate with Redis cache.
   */
  readonly primaryKey?: string;
  /**
   * The current secondary key that clients can use to authenticate with Redis cache.
   */
  readonly secondaryKey?: string;
}

/**
 * Linked server Id
 */
export interface RedisLinkedServer {
  /**
   * Linked server Id.
   */
  readonly id?: string;
}

/**
 * Details of single instance of redis.
 */
export interface RedisInstanceDetails {
  /**
   * Redis instance SSL port.
   */
  readonly sslPort?: number;
  /**
   * If enableNonSslPort is true, provides Redis instance Non-SSL port.
   */
  readonly nonSslPort?: number;
  /**
   * If the Cache uses availability zones, specifies availability zone where this instance is located.
   */
  readonly zone?: string;
  /**
   * If clustering is enabled, the Shard ID of Redis Instance
   */
  readonly shardId?: number;
}

/**
 * Parameters supplied to the Update Redis operation.
 */
export interface RedisUpdateParameters {
  /**
   * Resource tags.
   */
  tags?: { [propertyName: string]: string };
  /**
   * All Redis Settings. Few possible keys: rdb-backup-enabled,rdb-storage-connection-string,rdb-backup-frequency,maxmemory-delta,maxmemory-policy,notify-keyspace-events,maxmemory-samples,slowlog-log-slower-than,slowlog-max-len,list-max-ziplist-entries,list-max-ziplist-value,hash-max-ziplist-entries,hash-max-ziplist-value,set-max-intset-entries,zset-max-ziplist-entries,zset-max-ziplist-value etc.
   */
  redisConfiguration?: { [propertyName: string]: string };
  /**
   * Specifies whether the non-ssl Redis server port (6379) is enabled.
   */
  enableNonSslPort?: boolean;
  /**
   * The number of replicas to be created per master.
   */
  replicasPerMaster?: number;
  /**
   * A dictionary of tenant settings
   */
  tenantSettings?: { [propertyName: string]: string };
  /**
   * The number of shards to be created on a Premium Cluster Cache.
   */
  shardCount?: number;
  /**
   * Optional: requires clients to use a specified TLS version (or higher) to connect (e,g, '1.0', '1.1', '1.2')
   */
  minimumTlsVersion?: TlsVersion;
  /**
   * The SKU of the Redis cache to deploy.
   */
  sku?: Sku;
}

/**
 * Patchable properties of the redis cache.
 */
export type RedisUpdateProperties = RedisCommonProperties & {
  /**
   * The SKU of the Redis cache to deploy.
   */
  sku?: Sku;
};

/**
 * The response of list Redis operation.
 */
export interface RedisListResult {
  /**
   * List of Redis cache instances.
   */
  value?: RedisResource[];
  /**
   * Link for next page of results.
   */
  readonly nextLink?: string;
}

/**
 * Specifies which Redis access keys to reset.
 */
export interface RedisRegenerateKeyParameters {
  /**
   * The Redis access key to regenerate.
   */
  keyType: RedisKeyType;
}

/**
 * Specifies which Redis node(s) to reboot.
 */
export interface RedisRebootParameters {
  /**
   * Which Redis node(s) to reboot. Depending on this value data loss is possible.
   */
  rebootType: RebootType;
  /**
   * If clustering is enabled, the ID of the shard to be rebooted.
   */
  shardId?: number;
}

/**
 * Response to force reboot for Redis cache.
 */
export interface RedisForceRebootResponse {
  /**
   * Status message
   */
  readonly message?: string;
}

/**
 * Parameters for Redis import operation.
 */
export interface ImportRDBParameters {
  /**
   * File format.
   */
  format?: string;
  /**
   * files to import.
   */
  files: string[];
}

/**
 * Parameters for Redis export operation.
 */
export interface ExportRDBParameters {
  /**
   * File format.
   */
  format?: string;
  /**
   * Prefix to use for exported files.
   */
  prefix: string;
  /**
   * Container name to export to.
   */
  container: string;
}

/**
 * The response of list firewall rules Redis operation.
 */
export interface RedisFirewallRuleListResult {
  /**
   * Results of the list firewall rules operation.
   */
  value?: RedisFirewallRule[];
  /**
   * Link for next page of results.
   */
  readonly nextLink?: string;
}

/**
 * The resource model definition for a ARM proxy resource. It will have everything other than required location and tags
 */
export type ProxyResource = Resource & {};

/**
 * A firewall rule on a redis cache has a name, and describes a contiguous range of IP addresses permitted to connect
 */
export type RedisFirewallRule = ProxyResource & {
  /**
   * lowest IP address included in the range
   */
  startIP: string;
  /**
   * highest IP address included in the range
   */
  endIP: string;
};

/**
 * Parameters required for creating a firewall rule on redis cache.
 */
export interface RedisFirewallRuleCreateParameters {
  /**
   * lowest IP address included in the range
   */
  startIP: string;
  /**
   * highest IP address included in the range
   */
  endIP: string;
}

/**
 * The response of list patch schedules Redis operation.
 */
export interface RedisPatchScheduleListResult {
  /**
   * Results of the list patch schedules operation.
   */
  value?: RedisPatchSchedule[];
  /**
   * Link for next page of results.
   */
  readonly nextLink?: string;
}

/**
 * Response to put/get patch schedules for Redis cache.
 */
export type RedisPatchSchedule = ProxyResource & {
  /**
   * List of patch schedules for a Redis cache.
   */
  scheduleEntries: ScheduleEntry[];
};

/**
 * Patch schedule entry for a Premium Redis Cache.
 */
export interface ScheduleEntry {
  /**
   * Day of the week when a cache can be patched.
   */
  dayOfWeek: DayOfWeek;
  /**
   * Start hour after which cache patching can start.
   */
  startHourUtc: number;
  /**
   * ISO8601 timespan specifying how much time cache patching can take.
   */
  maintenanceWindow?: string;
}

/**
 * Parameter required for creating a linked server to redis cache.
 */
export interface RedisLinkedServerCreateParameters {
  /**
   * Fully qualified resourceId of the linked redis cache.
   */
  linkedRedisCacheId: string;
  /**
   * Location of the linked redis cache.
   */
  linkedRedisCacheLocation: string;
  /**
   * Role of the linked server.
   */
  serverRole: ReplicationRole;
}

/**
 * Create properties for a linked server
 */
export interface RedisLinkedServerCreateProperties {
  /**
   * Fully qualified resourceId of the linked redis cache.
   */
  linkedRedisCacheId: string;
  /**
   * Location of the linked redis cache.
   */
  linkedRedisCacheLocation: string;
  /**
   * Role of the linked server.
   */
  serverRole: ReplicationRole;
}

/**
 * Response to put/get linked server (with properties) for Redis cache.
 */
export type RedisLinkedServerWithProperties = ProxyResource & {
  /**
   * Fully qualified resourceId of the linked redis cache.
   */
  linkedRedisCacheId?: string;
  /**
   * Location of the linked redis cache.
   */
  linkedRedisCacheLocation?: string;
  /**
   * Role of the linked server.
   */
  serverRole?: ReplicationRole;
  /**
   * Terminal state of the link between primary and secondary redis cache.
   */
  readonly provisioningState?: string;
};

/**
 * Properties of a linked server to be returned in get/put response
 */
export type RedisLinkedServerProperties = RedisLinkedServerCreateProperties & {
  /**
   * Terminal state of the link between primary and secondary redis cache.
   */
  readonly provisioningState?: string;
};

/**
 * List of linked servers (with properties) of a Redis cache.
 */
export interface RedisLinkedServerWithPropertiesList {
  /**
   * List of linked servers (with properties) of a Redis cache.
   */
  value?: RedisLinkedServerWithProperties[];
  /**
   * Link for next set.
   */
  readonly nextLink?: string;
}

/**
 * Defines values for TlsVersion.
 */
export type TlsVersion = "1.0" | "1.1" | "1.2";
/**
 * Defines values for SkuName.
 */
export type SkuName = "Basic" | "Standard" | "Premium";
/**
 * Defines values for SkuFamily.
 */
export type SkuFamily = "C" | "P";
/**
 * Defines values for ProvisioningState.
 */
export type ProvisioningState =
  | "Creating"
  | "Deleting"
  | "Disabled"
  | "Failed"
  | "Linking"
  | "Provisioning"
  | "RecoveringScaleFailure"
  | "Scaling"
  | "Succeeded"
  | "Unlinking"
  | "Unprovisioning"
  | "Updating";
/**
 * Defines values for RebootType.
 */
export type RebootType = "PrimaryNode" | "SecondaryNode" | "AllNodes";
/**
 * Defines values for RedisKeyType.
 */
export type RedisKeyType = "Primary" | "Secondary";
/**
 * Defines values for DayOfWeek.
 */
export type DayOfWeek =
  | "Monday"
  | "Tuesday"
  | "Wednesday"
  | "Thursday"
  | "Friday"
  | "Saturday"
  | "Sunday"
  | "Everyday"
  | "Weekend";
/**
 * Defines values for ReplicationRole.
 */
export type ReplicationRole = "Primary" | "Secondary";

/**
 * Contains response data for the list operation.
 */
export type OperationsListResponse = OperationListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: OperationListResult;
  };
};

/**
 * Contains response data for the listNext operation.
 */
export type OperationsListNextResponse = OperationListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: OperationListResult;
  };
};

/**
 * Contains response data for the listUpgradeNotifications operation.
 */
export type RedisListUpgradeNotificationsResponse = NotificationListResponse & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: NotificationListResponse;
  };
};

/**
 * Contains response data for the create operation.
 */
export type RedisCreateResponse = RedisResource & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: RedisResource;
  };
};

/**
 * Contains response data for the update operation.
 */
export type RedisUpdateResponse = RedisResource & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: RedisResource;
  };
};

/**
 * Contains response data for the getModel operation.
 */
export type RedisGetResponse = RedisResource & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: RedisResource;
  };
};

/**
 * Contains response data for the listByResourceGroup operation.
 */
export type RedisListByResourceGroupResponse = RedisListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: RedisListResult;
  };
};

/**
 * Contains response data for the list operation.
 */
export type RedisListResponse = RedisListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: RedisListResult;
  };
};

/**
 * Contains response data for the listKeys operation.
 */
export type RedisListKeysResponse = RedisAccessKeys & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: RedisAccessKeys;
  };
};

/**
 * Contains response data for the regenerateKey operation.
 */
export type RedisRegenerateKeyResponse = RedisAccessKeys & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: RedisAccessKeys;
  };
};

/**
 * Contains response data for the forceReboot operation.
 */
export type RedisForceRebootResponse = RedisForceRebootResponse & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: RedisForceRebootResponse;
  };
};

/**
 * Contains response data for the listByResourceGroupNext operation.
 */
export type RedisListByResourceGroupNextResponse = RedisListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: RedisListResult;
  };
};

/**
 * Contains response data for the listNext operation.
 */
export type RedisListNextResponse = RedisListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: RedisListResult;
  };
};

/**
 * Contains response data for the listByRedisResource operation.
 */
export type FirewallRulesListByRedisResourceResponse = RedisFirewallRuleListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: RedisFirewallRuleListResult;
  };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type FirewallRulesCreateOrUpdateResponse = RedisFirewallRule & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: RedisFirewallRule;
  };
};

/**
 * Contains response data for the getModel operation.
 */
export type FirewallRulesGetResponse = RedisFirewallRule & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: RedisFirewallRule;
  };
};

/**
 * Contains response data for the listByRedisResourceNext operation.
 */
export type FirewallRulesListByRedisResourceNextResponse = RedisFirewallRuleListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: RedisFirewallRuleListResult;
  };
};

/**
 * Contains response data for the listByRedisResource operation.
 */
export type PatchSchedulesListByRedisResourceResponse = RedisPatchScheduleListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: RedisPatchScheduleListResult;
  };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type PatchSchedulesCreateOrUpdateResponse = RedisPatchSchedule & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: RedisPatchSchedule;
  };
};

/**
 * Contains response data for the getModel operation.
 */
export type PatchSchedulesGetResponse = RedisPatchSchedule & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: RedisPatchSchedule;
  };
};

/**
 * Contains response data for the listByRedisResourceNext operation.
 */
export type PatchSchedulesListByRedisResourceNextResponse = RedisPatchScheduleListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: RedisPatchScheduleListResult;
  };
};

/**
 * Contains response data for the create operation.
 */
export type LinkedServerCreateResponse = RedisLinkedServerWithProperties & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: RedisLinkedServerWithProperties;
  };
};

/**
 * Contains response data for the getModel operation.
 */
export type LinkedServerGetResponse = RedisLinkedServerWithProperties & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: RedisLinkedServerWithProperties;
  };
};

/**
 * Contains response data for the list operation.
 */
export type LinkedServerListResponse = RedisLinkedServerWithPropertiesList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: RedisLinkedServerWithPropertiesList;
  };
};

/**
 * Contains response data for the listNext operation.
 */
export type LinkedServerListNextResponse = RedisLinkedServerWithPropertiesList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: RedisLinkedServerWithPropertiesList;
  };
};

/**
 * Optional parameters.
 */
export interface RedisManagementClientOptionalParams
  extends coreHttp.ServiceClientOptions {
  /**
   * server parameter
   */
  $host?: string;
  /**
   * Api Version
   */
  apiVersion?: string;
  /**
   * Overrides client endpoint.
   */
  endpoint?: string;
}
