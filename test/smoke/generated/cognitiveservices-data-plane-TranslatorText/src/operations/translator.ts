/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as coreHttp from "@azure/core-http";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
import { TranslatorTextClient } from "../translatorTextClient";
import {
  BreakSentenceTextInput,
  TranslatorBreakSentenceOptionalParams,
  TranslatorBreakSentenceResponse,
  DetectTextInput,
  TranslatorDetectOptionalParams,
  TranslatorDetectResponse,
  DictionaryLookupTextInput,
  TranslatorDictionaryLookupOptionalParams,
  TranslatorDictionaryLookupResponse,
  DictionaryExampleTextInput,
  TranslatorDictionaryExamplesOptionalParams,
  TranslatorDictionaryExamplesResponse,
  TranslatorLanguagesOptionalParams,
  TranslatorLanguagesResponse,
  TranslateTextInput,
  TranslatorTranslateOptionalParams,
  TranslatorTranslateResponse,
  TransliterateTextInput,
  TranslatorTransliterateOptionalParams,
  TranslatorTransliterateResponse
} from "../models";

/**
 * Class representing a Translator.
 */
export class Translator {
  private readonly client: TranslatorTextClient;

  /**
   * Initialize a new instance of the class Translator class.
   * @param client Reference to the service client
   */
  constructor(client: TranslatorTextClient) {
    this.client = client;
  }

  /**
   * Identifies the position of sentence boundaries in a piece of text.
   *
   * @param text # Request Body
   *             The body of the request is a JSON array. Each array element is a JSON object with a string property
   *             named Text. Sentence boundaries are computed for the value of the Text property.
   *
   * The following limitations apply:
   *             * The array can have at most 100 elements.
   *             * The text value of an array element cannot exceed 10,000 characters including spaces.
   *             * The entire text included in the request cannot exceed 50,000 characters including spaces.
   *             * If the `language` query parameter is specified, then all array elements must be in the same
   *             language. Otherwise, language auto-detection is applied to each array element independently.
   *
   * # Response Body
   *             A successful response is a JSON array with one result for each string in the input array. A result
   *             object includes the following properties:
   *             * `sentLen`- An array of integers representing the lengths of the sentences in the text element. The
   *             length of the array is the number of sentences, and the values are the length of each sentence.
   *             * `detectedLanguage`- An object describing the detected language through the following properties
   *               * `language`- Code of the detected language.
   *               * `score`- A float value indicating the confidence in the result. The score is between zero and
   *             one and a low score indicates a low confidence.
   *             * Note that the `detectedLanguage` property is only present in the result object when language
   *             auto-detection is requested.
   *             # Response Header
   *             X-RequestId - Value generated by the service to identify the request. It is used for troubleshooting
   *             purposes.
   *
   * @param options The options parameters.
   */
  breakSentence(
    text: BreakSentenceTextInput[],
    options?: TranslatorBreakSentenceOptionalParams
  ): Promise<TranslatorBreakSentenceResponse> {
    const operationOptions: coreHttp.RequestOptionsBase = coreHttp.operationOptionsToRequestOptionsBase(
      options || {}
    );
    return this.client.sendOperationRequest(
      { text, options: operationOptions },
      breakSentenceOperationSpec
    ) as Promise<TranslatorBreakSentenceResponse>;
  }

  /**
   * Identifies the language of a string of text.
   *
   * @param text # Request Body
   *             The body of the request is a JSON array. Each array element is a JSON object with a string property
   *             named Text. Language detection is applied to the value of the Text property.
   *             The following limitations apply:
   *             * The array can have at most 100 elements.
   *             * The text value of an array element cannot exceed 10,000 characters including spaces.
   *             * The entire text included in the request cannot exceed 50,000 characters including spaces.
   *
   * # Response Body
   *             A successful response is a JSON array with one result for each string in the input array. A result
   *             object includes the following properties:
   *             * language- Code of the detected language.
   *             * score- A float value indicating the confidence in the result. The score is between zero and one
   *             and a low score indicates a low confidence.
   *             * isTranslationSupported- A boolean value which is true if the detected language is one of the
   *             languages supported for text translation. Not all detected languages can be translated by the API.
   *             * isTransliterationSupported- A boolean value which is true if the detected language is one of the
   *             languages supported for transliteration.
   *             * alternatives- An array of other possible languages. Each element of the array is another object
   *             with the same properties listed above- language, score, isTranslationSupported and
   *             isTransliterationSupported.
   *             # Response Header
   *             X-RequestId - Value generated by the service to identify the request. It is used for troubleshooting
   *             purposes.
   *
   * @param options The options parameters.
   */
  detect(
    text: DetectTextInput[],
    options?: TranslatorDetectOptionalParams
  ): Promise<TranslatorDetectResponse> {
    const operationOptions: coreHttp.RequestOptionsBase = coreHttp.operationOptionsToRequestOptionsBase(
      options || {}
    );
    return this.client.sendOperationRequest(
      { text, options: operationOptions },
      detectOperationSpec
    ) as Promise<TranslatorDetectResponse>;
  }

  /**
   * Provides alternative translations for a word and a small number of idiomatic phrases. Each
   * translation has a `part-of-speech` and a list of `back-translations`. The back-translations enable a
   * user to understand the translation in context. The Dictionary Example operation allows further drill
   * down to see example uses of each translation pair.
   *
   * @param text # Request Body
   *             The body of the request is a JSON array. Each array element is a JSON object with a string property
   *             named `Text`, which represents the term to lookup.
   *             The following limitations apply:
   *             * The array can have at most 10 elements.
   *             * The text value of an array element cannot exceed 100 characters including spaces.
   *
   * # Response Body
   *             A successful response is a JSON array with one result for each string in the input array. A result
   *             object includes the following properties:
   *             * `normalizedSource`- A string giving the normalized form of the source term. For example, if the
   *             request is "JOHN", the normalized form will be "john". The content of this field becomes the input
   *             to lookup examples.
   *             * `displaySource`- A string giving the source term in a form best suited for end-user display. For
   *             example, if the input is "JOHN", the display form will reflect the usual spelling of the name-
   *             "John".
   *             * `translations`- A list of translations for the source term. Each element of the list is an object
   *             with the following properties:
   *               * `normalizedTarget`- A string giving the normalized form of this term in the target language.
   *             This value should be used as input to lookup examples.
   *               * `displayTarget`- A string giving the term in the target language and in a form best suited for
   *             end-user display. Generally, this will only differ from the `normalizedTarget` in terms of
   *             capitalization. For example, a proper noun like "Juan" will have `normalizedTarget = "juan"` and
   *             `displayTarget = "Juan"`.
   *               * `posTag`- A string associating this term with a part-of-speech tag.
   *
   *               | Tag name  | Description       |
   *               | --------- | ----------------  |
   *               | ADJ       | Adjectives        |
   *               | ADV       | Adverbs           |
   *               | CONJ      | Conjunctions       |
   *               | DET       | Determiners       |
   *               | MODAL     | Verbs             |
   *               | NOUN      | Nouns             |
   *               | PREP      | Prepositions      |
   *               | PRON      | Pronouns          |
   *               | VERB      | Verbs             |
   *               | OTHER     | Other             |
   *
   *               As an implementation note, these tags were determined by part-of-speech tagging the English side,
   *             and then taking the most frequent tag for each source/target pair. So if people frequently translate
   *             a Spanish word to a different part-of-speech tag in English, tags may end up being wrong (with
   *             respect to the Spanish word).
   *                 * `confidence`- A value between 0.0 and 1.0 which represents the "confidence" (or perhaps more
   *             accurately, "probability in the training data") of that translation pair. The sum of confidence
   *             scores for one source word may or may not sum to 1.0.
   *                 * `prefixWord-` A string giving the word to display as a prefix of the translation. Currently,
   *             this is the gendered determiner of nouns, in languages that have gendered determiners. For example,
   *             the prefix of the Spanish word "mosca" is "la", since "mosca" is a feminine noun in Spanish. This is
   *             only dependent on the translation, and not on the source. If there is no prefix, it will be the
   *             empty string.
   *                 * `backTranslations-` A list of "back translations" of the target. For example, source words
   *             that the target can translate to. The list is guaranteed to contain the source word that was
   *             requested (e.g., if the source word being looked up is "fly", then it is guaranteed that "fly" will
   *             be in the `backTranslations` list). However, it is not guaranteed to be in the first position, and
   *             often will not be. Each element of the `backTranslations` list is an object described by the
   *             following properties-
   *                   * `normalizedText-` A string giving the normalized form of the source term that is a
   *             back-translation of the target. This value should be used as input to lookup examples.
   *                   * `displayText-` A string giving the source term that is a back-translation of the target in a
   *             form best suited for end-user display.
   *                   * `numExamples-` An integer representing the number of examples that are available for this
   *             translation pair. Actual examples must be retrieved with a separate call to lookup examples. The
   *             number is mostly intended to facilitate display in a UX. For example, a user interface may add a
   *             hyperlink to the back-translation if the number of examples is greater than zero and show the
   *             back-translation as plain text if there are no examples. Note that the actual number of examples
   *             returned by a call to lookup examples may be less than `numExamples`, because additional filtering
   *             may be applied on the fly to remove "bad" examples.
   *                   * `frequencyCount-` An integer representing the frequency of this translation pair in the
   *             data. The main purpose of this field is to provide a user interface with a means to sort
   *             back-translations so the most frequent terms are first.
   *
   *             Note - If the term being looked up does not exist in the dictionary, the response is 200 (OK) but
   *             the `translations` list is an empty list.
   *
   *             # Response Header
   *             X-RequestId - Value generated by the service to identify the request. It is used for troubleshooting
   *             purposes.
   *
   * @param from Specifies the language of the input text. The source language must be one of the
   *             supported languages included in the `dictionary` scope.
   * @param to Specifies the language of the output text. The target language must be one of the
   *           supported languages included in the `dictionary` scope of the Languages resource.
   * @param options The options parameters.
   */
  dictionaryLookup(
    text: DictionaryLookupTextInput[],
    from: string,
    to: string,
    options?: TranslatorDictionaryLookupOptionalParams
  ): Promise<TranslatorDictionaryLookupResponse> {
    const operationOptions: coreHttp.RequestOptionsBase = coreHttp.operationOptionsToRequestOptionsBase(
      options || {}
    );
    return this.client.sendOperationRequest(
      { text, from, to, options: operationOptions },
      dictionaryLookupOperationSpec
    ) as Promise<TranslatorDictionaryLookupResponse>;
  }

  /**
   * Provides examples that show how terms in the dictionary are used in context. This operation is used
   * in tandem with `Dictionary lookup`.
   *
   * @param from Specifies the language of the input text. The source language must be one of the
   *             supported languages included in the `dictionary` scope.
   * @param text # Request body
   *             The body of the request is a JSON array. Each array element is a JSON object with the following
   *             properties:
   *             * `Text-` A string specifying the term to lookup. This should be the value of a `normalizedText`
   *             field from the back-translations of a previous Dictionary lookup request. It can also be the value
   *             of the `normalizedSource` field.
   *             * `Translation-` A string specifying the translated text previously returned by the Dictionary
   *             lookup operation. This should be the value from the `normalizedTarget` field in the `translations`
   *             list of the Dictionary lookup response. The service will return examples for the specific
   *             source-target word-pair.
   *
   * The following limitations apply:
   *             * The array can have at most 10 elements.
   *             * The text value of an array element cannot exceed 100 characters including spaces.
   *
   * # Response body
   *             A successful response is a JSON array with one result for each string in the input array. A result
   *             object includes the following properties:
   *             * `normalizedSource-` A string giving the normalized form of the source term. Generally, this should
   *             be identical to the value of the `Text` field at the matching list index in the body of the request.
   *             * `normalizedTarget-` A string giving the normalized form of the target term. Generally, this should
   *             be identical to the value of the `Translation` field at the matching list index in the body of the
   *             request.
   *             * `examples-` A list of examples for the (source term, target term) pair. Each element of the list
   *             is an object with the following properties:
   *               * `sourcePrefix-` The string to concatenate before the value of `sourceTerm` to form a complete
   *             example. Do not add a space character, since it is already there when it should be. This value may
   *             be an empty string.
   *               * `sourceTerm-` A string equal to the actual term looked up. The string is added with
   *             `sourcePrefix` and `sourceSuffix` to form the complete example. Its value is separated so it can be
   *             marked in a user interface, e.g., by bolding it.
   *               * `sourceSuffix-` The string to concatenate after the value of `sourceTerm` to form a complete
   *             example. Do not add a space character, since it is already there when it should be. This value may
   *             be an empty string.
   *               * `targetPrefix-` A string similar to `sourcePrefix` but for the target.
   *               * `targetTerm-` A string similar to `sourceTerm` but for the target.
   *               * `targetSuffix-` A string similar to `sourceSuffix` but for the target.
   *
   * # Response Header
   *             X-RequestId - Value generated by the service to identify the request. It is used for troubleshooting
   *             purposes.
   *             NOTE - If there are no examples in the dictionary, the response is 200 (OK) but the `examples` list
   *             is an empty list.
   *
   * @param to Specifies the language of the output text. The target language must be one of the
   *           supported languages included in the `dictionary` scope.
   * @param options The options parameters.
   */
  dictionaryExamples(
    from: string,
    text: DictionaryExampleTextInput[],
    to: string,
    options?: TranslatorDictionaryExamplesOptionalParams
  ): Promise<TranslatorDictionaryExamplesResponse> {
    const operationOptions: coreHttp.RequestOptionsBase = coreHttp.operationOptionsToRequestOptionsBase(
      options || {}
    );
    return this.client.sendOperationRequest(
      { from, text, to, options: operationOptions },
      dictionaryExamplesOperationSpec
    ) as Promise<TranslatorDictionaryExamplesResponse>;
  }

  /**
   * Gets the set of languages currently supported by other operations of the Translator Text API.
   * **Authentication is not required to get language resources.**
   *
   * # Response Body
   * A client uses the `scope` query parameter to define which groups of languages it is interested in.
   * * `scope=translation` provides languages supported to translate text from one language to another
   * language.
   * * `scope=transliteration` provides capabilities for converting text in one language from one script
   * to another script.
   * * `scope=dictionary` provides language pairs for which `Dictionary` operations return data.
   *
   * A client may retrieve several groups simultaneously by specifying a comma-separated list of names.
   * For example, `scope=translation,transliteration,dictionary` would return supported languages for all
   * groups.
   *
   * A successful response is a JSON object with one property for each requested group.
   * The value for each property is as follows.
   *
   * * `translation` property
   *   The value of the `translation` property is a dictionary of (key, value) pairs. Each key is a BCP
   * 47 language tag. A key identifies a language for which text can be translated to or translated from.
   * The value associated with the key is a JSON object with properties that describe the language
   *   * `name-` Display name of the language in the locale requested via `Accept-Language` header.
   *   * `nativeName-` Display name of the language in the locale native for this language.
   *   * `dir-` Directionality, which is `rtl` for right-to-left languages or `ltr` for left-to-right
   * languages.
   * ```json
   * {
   *   "translation": {
   *   ...
   *   "fr": {
   *   "name": "French",
   *   "nativeName": "Français",
   *   "dir": "ltr"
   *   },
   * ...
   *  }
   * }
   * ```
   * * `transliteration` property
   *   The value of the `transliteration` property is a dictionary of (key, value) pairs. Each key is a
   * BCP 47 language tag. A key identifies a language for which text can be converted from one script to
   * another script. The value associated with the key is a JSON object with properties that describe the
   * language and its supported scripts
   *   * `name-` Display name of the language in the locale requested via `Accept-Language` header.
   *   * `nativeName-` Display name of the language in the locale native for this language.
   *   * `scripts-` List of scripts to convert from. Each element of the `scripts` list has properties-
   *     * `code-` Code identifying the script.
   *     * `name-` Display name of the script in the locale requested via `Accept-Language` header.
   *     * `nativeName-` Display name of the language in the locale native for the language.
   *     * `dir-` Directionality, which is `rtl` for right-to-left languages or `ltr` for left-to-right
   * languages.
   *     * `toScripts-` List of scripts available to convert text to. Each element of the `toScripts`
   * list has properties `code`, `name`, `nativeName`, and `dir` as described earlier.
   *
   * ```json
   * {
   *   "transliteration": {
   *     ...
   *     "ja": {
   *       "name": "Japanese",
   *       "nativeName": "日本語",
   *       "scripts": [
   *         {
   *           "code": "Jpan",
   *           "name": "Japanese",
   *           "nativeName": "日本語",
   *           "dir": "ltr",
   *           "toScripts": [
   *             {
   *               "code": "Latn",
   *               "name": "Latin",
   *               "nativeName": "ラテン語",
   *               "dir": "ltr"
   *             }
   *           ]
   *         },
   *         {
   *           "code": "Latn",
   *           "name": "Latin",
   *           "nativeName": "ラテン語",
   *           "dir": "ltr",
   *           "toScripts": [
   *           {
   *             "code": "Jpan",
   *             "name": "Japanese",
   *             "nativeName": "日本語",
   *             "dir": "ltr"
   *           }
   *           ]
   *         }
   *       ]
   *     },
   *   ...
   *   }
   * }
   *
   * ```
   * * `dictionary` property
   * The value of the `dictionary` property is a dictionary of (key, value) pairs. Each key is a BCP 47
   * language tag. The key identifies a language for which alternative translations and back-translations
   * are available. The value is a JSON object that describes the source language and the target
   * languages with available translations.
   *   * `name-` Display name of the source language in the locale requested via `Accept-Language`
   * header.
   *   * `nativeName-` Display name of the language in the locale native for this language.
   *   * `dir-` Directionality, which is `rtl` for right-to-left languages or `ltr` for left-to-right
   * languages.
   *   * `translations-` List of languages with alterative translations and examples for the query
   * expressed in the source language. Each element of the `translations` list has properties
   *     * `name-` Display name of the target language in the locale requested via `Accept-Language`
   * header.
   *     * `nativeName-` Display name of the target language in the locale native for the target
   * language.
   *     * `dir-` Directionality, which is `rtl` for right-to-left languages or `ltr` for left-to-right
   * languages.
   *     * `code-` Language code identifying the target language.
   *
   * ```json
   *
   * "es": {
   *   "name": "Spanish",
   *   "nativeName": "Español",
   *   "dir": "ltr",
   *   "translations": [
   *     {
   *       "name": "English",
   *       "nativeName": "English",
   *       "dir": "ltr",
   *       "code": "en"
   *     }
   *   ]
   * },
   *
   * ```
   *
   * The structure of the response object will not change without a change in the version of the API. For
   * the same version of the API, the list of available languages may change over time because Microsoft
   * Translator continually extends the list of languages supported by its services.
   *
   * The list of supported languages will not change frequently. To save network bandwidth and improve
   * responsiveness, a client application should consider caching language resources and the
   * corresponding entity tag (`ETag`). Then, the client application can periodically (for example, once
   * every 24 hours) query the service to fetch the latest set of supported languages. Passing the
   * current `ETag` value in an `If-None-Match` header field will allow the service to optimize the
   * response. If the resource has not been modified, the service will return status code 304 and an
   * empty response body.
   *
   * # Response Header
   * ETag - Current value of the entity tag for the requested groups of supported languages. To make
   * subsequent requests more efficient, the client may send the `ETag` value in an `If-None-Match`
   * header field.
   *
   * X-RequestId - Value generated by the service to identify the request. It is used for troubleshooting
   * purposes.
   *
   *
   *
   * @param options The options parameters.
   */
  languages(
    options?: TranslatorLanguagesOptionalParams
  ): Promise<TranslatorLanguagesResponse> {
    const operationOptions: coreHttp.RequestOptionsBase = coreHttp.operationOptionsToRequestOptionsBase(
      options || {}
    );
    return this.client.sendOperationRequest(
      { options: operationOptions },
      languagesOperationSpec
    ) as Promise<TranslatorLanguagesResponse>;
  }

  /**
   * Translates text into one or more languages.
   *
   * @param text # Request body
   *             The body of the request is a JSON array. Each array element is a JSON object with a string property
   *             named `Text`, which represents the string to translate.
   *             The following limitations apply:
   *             * The array can have at most 25 elements.
   *             * The entire text included in the request cannot exceed 5,000 characters including spaces.
   *             # Response body
   *             A successful response is a JSON array with one result for each string in the input array. A result
   *             object includes the following properties-
   *             * `detectedLanguage`- An object describing the detected language through the following properties.
   *               * `language`- A string representing the code of the detected language.
   *               * `score`- A float value indicating the confidence in the result. The score is between zero and
   *             one and a low score indicates a low confidence.
   *               The `detectedLanguage` property is only present in the result object when language auto-detection
   *             is requested.
   *             * `translations`- An array of translation results. The size of the array matches the number of
   *             target languages specified in the `to` query parameter. Each element in the array includes.
   *               * `to` A string representing the language code of the target language.
   *               * `text`- A string giving the translated text.
   *               * `transliteration`- An object giving the translated text in the script specified by the
   *             `toScript` parameter.
   *                 * `script`- A string specifying the target script.
   *                 * `text`- A string giving the translated text in the target script.
   *                 The `transliteration` object is not included if transliteration does not take place.
   *               *`alignment`- An object with a single string property named `proj`, which maps input text to
   *             translated text. The alignment information is only provided when the request parameter
   *             `includeAlignment` is `true`. Alignment is returned as a string value of the following format-
   *             `[[SourceTextStartIndex]-[SourceTextEndIndex]–[TgtTextStartIndex]-[TgtTextEndIndex]]`. The colon
   *             separates start and end index, the dash separates the languages, and space separates the words. One
   *             word may align with zero, one, or multiple words in the other language, and the aligned words may be
   *             non-contiguous. When no alignment information is available, the alignment element will be empty. See
   *             Obtain alignment information for an example and restrictions.
   *               * `sentLen`- An object returning sentence boundaries in the input and output texts.
   *                 * `srcSentLen`- An integer array representing the lengths of the sentences in the input text.
   *             The length of the array is the number of sentences, and the values are the length of each sentence.
   *                 * `transSentLen`- An integer array representing the lengths of the sentences in the translated
   *             text. The length of the array is the number of sentences, and the values are the length of each
   *             sentence.
   *                 Sentence boundaries are only included when the request parameter `includeSentenceLength` is
   *             `true`.
   *               * `sourceText`- An object with a single string property named `text`, which gives the input text
   *             in the default script of the source language. `sourceText` property is present only when the input
   *             is expressed in a script that's not the usual script for the language. For example, if the input
   *             were Arabic written in Latin script, then `sourceText.text` would be the same Arabic text converted
   *             into Arab script.
   *               Example of JSON responses are provided in the examples section.
   *
   *
   *
   * @param to Specifies the language of the output text. Find which languages are available to translate
   *           to by using the languages method. For example, use `to=de` to translate to German.
   *             It's possible to translate to multiple languages simultaneously by repeating the `to` parameter in
   *           the query string. For example, use `to=de&to=it` to translate to German and Italian in the same
   *           request.
   *
   * @param options The options parameters.
   */
  translate(
    text: TranslateTextInput[],
    to: string[],
    options?: TranslatorTranslateOptionalParams
  ): Promise<TranslatorTranslateResponse> {
    const operationOptions: coreHttp.RequestOptionsBase = coreHttp.operationOptionsToRequestOptionsBase(
      options || {}
    );
    return this.client.sendOperationRequest(
      { text, to, options: operationOptions },
      translateOperationSpec
    ) as Promise<TranslatorTranslateResponse>;
  }

  /**
   * Converts the text of a language in one script into another type of script. Example-
   * Japanese script "こんにちは"
   * Same word in Latin script "konnichiha"
   *
   * @param texts # Request body
   *                The body of the request is a JSON array. Each array element is a JSON object with a string
   *              property named `Text`, which represents the string to convert.
   *                The following limitations apply:
   *                * The array can have at most 10 elements.
   *                * The text value of an array element cannot exceed 1,000 characters including spaces.
   *                * The entire text included in the request cannot exceed 5,000 characters including spaces.
   *
   *              # Response body
   *                A successful response is a JSON array with one result for each element in the input array. A
   *              result object includes the following properties:
   *                * `text`- A string which is the result of converting the input string to the output script.
   *                * `script`- A string specifying the script used in the output.
   *
   *
   * @param language Specifies the language of the text to convert from one script to another. Possible
   *                 languages are listed in the `transliteration` scope obtained by querying the service for its
   *                 supported languages.
   *
   * @param fromScript Specifies the script used by the input text. Lookup supported languages using the
   *                   `transliteration` scope, to find input scripts available for the selected language.
   *
   * @param toScript Specifies the output script. Lookup supported languages using the `transliteration`
   *                 scope, to find output scripts available for the selected combination of input language and input
   *                 script.
   *
   * @param options The options parameters.
   */
  transliterate(
    texts: TransliterateTextInput[],
    language: string,
    fromScript: string,
    toScript: string,
    options?: TranslatorTransliterateOptionalParams
  ): Promise<TranslatorTransliterateResponse> {
    const operationOptions: coreHttp.RequestOptionsBase = coreHttp.operationOptionsToRequestOptionsBase(
      options || {}
    );
    return this.client.sendOperationRequest(
      { texts, language, fromScript, toScript, options: operationOptions },
      transliterateOperationSpec
    ) as Promise<TranslatorTransliterateResponse>;
  }
}
// Operation Specifications

const serializer = new coreHttp.Serializer(Mappers, /* isXml */ false);

const breakSentenceOperationSpec: coreHttp.OperationSpec = {
  path: "/BreakSentence",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: { name: "Composite", className: "BreakSentenceResultItem" }
          }
        },
        serializedName: "BreakSentenceResult"
      }
    },
    default: {
      bodyMapper: Mappers.ErrorMessage
    }
  },
  requestBody: Parameters.text,
  queryParameters: [
    Parameters.apiVersion,
    Parameters.language,
    Parameters.script
  ],
  urlParameters: [Parameters.endpoint],
  headerParameters: [Parameters.contentType, Parameters.xClientTraceId],
  serializer
};
const detectOperationSpec: coreHttp.OperationSpec = {
  path: "/Detect",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: { name: "Composite", className: "DetectResultItem" }
          }
        },
        serializedName: "DetectResult"
      }
    },
    default: {
      bodyMapper: Mappers.ErrorMessage
    }
  },
  requestBody: Parameters.text1,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint],
  headerParameters: [Parameters.contentType, Parameters.xClientTraceId],
  serializer
};
const dictionaryLookupOperationSpec: coreHttp.OperationSpec = {
  path: "/Dictionary/Lookup",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: { name: "Composite", className: "DictionaryLookupResultItem" }
          }
        },
        serializedName: "DictionaryLookupResult"
      }
    },
    default: {
      bodyMapper: Mappers.ErrorMessage
    }
  },
  requestBody: Parameters.text2,
  queryParameters: [Parameters.apiVersion, Parameters.from, Parameters.to],
  urlParameters: [Parameters.endpoint],
  headerParameters: [Parameters.contentType, Parameters.xClientTraceId],
  serializer
};
const dictionaryExamplesOperationSpec: coreHttp.OperationSpec = {
  path: "/Dictionary/Examples",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DictionaryExampleResultItem"
            }
          }
        },
        serializedName: "DictionaryExampleResult"
      }
    },
    default: {
      bodyMapper: Mappers.ErrorMessage
    }
  },
  requestBody: Parameters.text3,
  queryParameters: [Parameters.apiVersion, Parameters.from, Parameters.to1],
  urlParameters: [Parameters.endpoint],
  headerParameters: [Parameters.contentType, Parameters.xClientTraceId],
  serializer
};
const languagesOperationSpec: coreHttp.OperationSpec = {
  path: "/Languages",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.LanguagesResult
    },
    default: {
      bodyMapper: Mappers.ErrorMessage
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.scope],
  urlParameters: [Parameters.endpoint],
  headerParameters: [Parameters.xClientTraceId, Parameters.acceptLanguage],
  serializer
};
const translateOperationSpec: coreHttp.OperationSpec = {
  path: "/translate",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: { name: "Composite", className: "TranslateResultAllItem" }
          }
        },
        serializedName: "TranslateResultAll"
      }
    },
    default: {
      bodyMapper: Mappers.ErrorMessage
    }
  },
  requestBody: Parameters.text4,
  queryParameters: [
    Parameters.apiVersion,
    Parameters.from1,
    Parameters.to2,
    Parameters.textType,
    Parameters.category,
    Parameters.profanityAction,
    Parameters.profanityMarker,
    Parameters.includeAlignment,
    Parameters.includeSentenceLength,
    Parameters.suggestedFrom,
    Parameters.fromScript,
    Parameters.toScript
  ],
  urlParameters: [Parameters.endpoint],
  headerParameters: [Parameters.contentType, Parameters.xClientTraceId],
  serializer
};
const transliterateOperationSpec: coreHttp.OperationSpec = {
  path: "/transliterate",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: { name: "Composite", className: "TransliterateResultItem" }
          }
        },
        serializedName: "TransliterateResult"
      }
    },
    default: {
      bodyMapper: Mappers.ErrorMessage
    }
  },
  requestBody: Parameters.texts,
  queryParameters: [
    Parameters.apiVersion,
    Parameters.language1,
    Parameters.fromScript1,
    Parameters.toScript1
  ],
  urlParameters: [Parameters.endpoint],
  headerParameters: [Parameters.contentType, Parameters.xClientTraceId],
  serializer
};
