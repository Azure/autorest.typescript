/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as coreHttp from "@azure/core-http";
import "@azure/core-paging";
import { PagedAsyncIterableIterator } from "@azure/core-paging";
import { LROPoller, shouldDeserializeLRO } from "./lro";
import { PollerLike, PollOperationState } from "@azure/core-lro";
import {
  ApplicationGatewaysImpl,
  ApplicationSecurityGroupsImpl,
  AvailableDelegationsImpl,
  AvailableResourceGroupDelegationsImpl,
  AvailableServiceAliasesImpl,
  AzureFirewallsImpl,
  AzureFirewallFqdnTagsImpl,
  BastionHostsImpl,
  DdosCustomPoliciesImpl,
  DdosProtectionPlansImpl,
  AvailableEndpointServicesImpl,
  ExpressRouteCircuitAuthorizationsImpl,
  ExpressRouteCircuitPeeringsImpl,
  ExpressRouteCircuitConnectionsImpl,
  PeerExpressRouteCircuitConnectionsImpl,
  ExpressRouteCircuitsImpl,
  ExpressRouteServiceProvidersImpl,
  ExpressRouteCrossConnectionsImpl,
  ExpressRouteCrossConnectionPeeringsImpl,
  ExpressRoutePortsLocationsImpl,
  ExpressRoutePortsImpl,
  ExpressRouteLinksImpl,
  FirewallPoliciesImpl,
  FirewallPolicyRuleGroupsImpl,
  IpAllocationsImpl,
  IpGroupsImpl,
  LoadBalancersImpl,
  LoadBalancerBackendAddressPoolsImpl,
  LoadBalancerFrontendIPConfigurationsImpl,
  InboundNatRulesImpl,
  LoadBalancerLoadBalancingRulesImpl,
  LoadBalancerOutboundRulesImpl,
  LoadBalancerNetworkInterfacesImpl,
  LoadBalancerProbesImpl,
  NatGatewaysImpl,
  NetworkInterfacesImpl,
  NetworkInterfaceIPConfigurationsImpl,
  NetworkInterfaceLoadBalancersImpl,
  NetworkInterfaceTapConfigurationsImpl,
  NetworkProfilesImpl,
  NetworkSecurityGroupsImpl,
  SecurityRulesImpl,
  DefaultSecurityRulesImpl,
  NetworkVirtualAppliancesImpl,
  NetworkWatchersImpl,
  PacketCapturesImpl,
  ConnectionMonitorsImpl,
  FlowLogsImpl,
  OperationsImpl,
  PrivateEndpointsImpl,
  AvailablePrivateEndpointTypesImpl,
  PrivateDnsZoneGroupsImpl,
  PrivateLinkServicesImpl,
  PublicIPAddressesImpl,
  PublicIPPrefixesImpl,
  RouteFiltersImpl,
  RouteFilterRulesImpl,
  RouteTablesImpl,
  RoutesImpl,
  SecurityPartnerProvidersImpl,
  BgpServiceCommunitiesImpl,
  ServiceEndpointPoliciesImpl,
  ServiceEndpointPolicyDefinitionsImpl,
  ServiceTagsImpl,
  UsagesImpl,
  VirtualNetworksImpl,
  SubnetsImpl,
  ResourceNavigationLinksImpl,
  ServiceAssociationLinksImpl,
  VirtualNetworkPeeringsImpl,
  VirtualNetworkGatewaysImpl,
  VirtualNetworkGatewayConnectionsImpl,
  LocalNetworkGatewaysImpl,
  VirtualNetworkTapsImpl,
  VirtualRoutersImpl,
  VirtualRouterPeeringsImpl,
  VirtualWansImpl,
  VpnSitesImpl,
  VpnSiteLinksImpl,
  VpnSitesConfigurationImpl,
  VpnServerConfigurationsImpl,
  VirtualHubsImpl,
  HubVirtualNetworkConnectionsImpl,
  VpnGatewaysImpl,
  VpnConnectionsImpl,
  VpnSiteLinkConnectionsImpl,
  VpnLinkConnectionsImpl,
  P2SVpnGatewaysImpl,
  VpnServerConfigurationsAssociatedWithVirtualWanImpl,
  VirtualHubRouteTableV2SImpl,
  ExpressRouteGatewaysImpl,
  ExpressRouteConnectionsImpl,
  HubRouteTablesImpl,
  WebApplicationFirewallPoliciesImpl
} from "./operations";
import {
  ApplicationGateways,
  ApplicationSecurityGroups,
  AvailableDelegations,
  AvailableResourceGroupDelegations,
  AvailableServiceAliases,
  AzureFirewalls,
  AzureFirewallFqdnTags,
  BastionHosts,
  DdosCustomPolicies,
  DdosProtectionPlans,
  AvailableEndpointServices,
  ExpressRouteCircuitAuthorizations,
  ExpressRouteCircuitPeerings,
  ExpressRouteCircuitConnections,
  PeerExpressRouteCircuitConnections,
  ExpressRouteCircuits,
  ExpressRouteServiceProviders,
  ExpressRouteCrossConnections,
  ExpressRouteCrossConnectionPeerings,
  ExpressRoutePortsLocations,
  ExpressRoutePorts,
  ExpressRouteLinks,
  FirewallPolicies,
  FirewallPolicyRuleGroups,
  IpAllocations,
  IpGroups,
  LoadBalancers,
  LoadBalancerBackendAddressPools,
  LoadBalancerFrontendIPConfigurations,
  InboundNatRules,
  LoadBalancerLoadBalancingRules,
  LoadBalancerOutboundRules,
  LoadBalancerNetworkInterfaces,
  LoadBalancerProbes,
  NatGateways,
  NetworkInterfaces,
  NetworkInterfaceIPConfigurations,
  NetworkInterfaceLoadBalancers,
  NetworkInterfaceTapConfigurations,
  NetworkProfiles,
  NetworkSecurityGroups,
  SecurityRules,
  DefaultSecurityRules,
  NetworkVirtualAppliances,
  NetworkWatchers,
  PacketCaptures,
  ConnectionMonitors,
  FlowLogs,
  Operations,
  PrivateEndpoints,
  AvailablePrivateEndpointTypes,
  PrivateDnsZoneGroups,
  PrivateLinkServices,
  PublicIPAddresses,
  PublicIPPrefixes,
  RouteFilters,
  RouteFilterRules,
  RouteTables,
  Routes,
  SecurityPartnerProviders,
  BgpServiceCommunities,
  ServiceEndpointPolicies,
  ServiceEndpointPolicyDefinitions,
  ServiceTags,
  Usages,
  VirtualNetworks,
  Subnets,
  ResourceNavigationLinks,
  ServiceAssociationLinks,
  VirtualNetworkPeerings,
  VirtualNetworkGateways,
  VirtualNetworkGatewayConnections,
  LocalNetworkGateways,
  VirtualNetworkTaps,
  VirtualRouters,
  VirtualRouterPeerings,
  VirtualWans,
  VpnSites,
  VpnSiteLinks,
  VpnSitesConfiguration,
  VpnServerConfigurations,
  VirtualHubs,
  HubVirtualNetworkConnections,
  VpnGateways,
  VpnConnections,
  VpnSiteLinkConnections,
  VpnLinkConnections,
  P2SVpnGateways,
  VpnServerConfigurationsAssociatedWithVirtualWan,
  VirtualHubRouteTableV2S,
  ExpressRouteGateways,
  ExpressRouteConnections,
  HubRouteTables,
  WebApplicationFirewallPolicies
} from "./operationsInterfaces";
import * as Parameters from "./models/parameters";
import * as Mappers from "./models/mappers";
import { NetworkManagementClientContext } from "./networkManagementClientContext";
import {
  NetworkManagementClientOptionalParams,
  BastionShareableLink,
  BastionShareableLinkListRequest,
  BastionActiveSession,
  BastionSessionState,
  SessionIds,
  NetworkManagementClientPutBastionShareableLinkResponse,
  NetworkManagementClientGetBastionShareableLinkResponse,
  NetworkManagementClientGetActiveSessionsResponse,
  NetworkManagementClientDisconnectActiveSessionsResponse,
  NetworkManagementClientCheckDnsNameAvailabilityResponse,
  NetworkManagementClientSupportedSecurityProvidersResponse,
  VirtualWanVpnProfileParameters,
  NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofileResponse,
  NetworkManagementClientPutBastionShareableLinkNextResponse,
  NetworkManagementClientGetBastionShareableLinkNextResponse,
  NetworkManagementClientGetActiveSessionsNextResponse,
  NetworkManagementClientDisconnectActiveSessionsNextResponse
} from "./models";

/// <reference lib="esnext.asynciterable" />
export class NetworkManagementClient extends NetworkManagementClientContext {
  /**
   * Initializes a new instance of the NetworkManagementClient class.
   * @param credentials Subscription credentials which uniquely identify client subscription.
   * @param subscriptionId The subscription credentials which uniquely identify the Microsoft Azure
   *                       subscription. The subscription ID forms part of the URI for every service call.
   * @param options The parameter options
   */
  constructor(
    credentials: coreHttp.TokenCredential | coreHttp.ServiceClientCredentials,
    subscriptionId: string,
    options?: NetworkManagementClientOptionalParams
  ) {
    super(credentials, subscriptionId, options);
    this.applicationGateways = new ApplicationGatewaysImpl(this);
    this.applicationSecurityGroups = new ApplicationSecurityGroupsImpl(this);
    this.availableDelegations = new AvailableDelegationsImpl(this);
    this.availableResourceGroupDelegations = new AvailableResourceGroupDelegationsImpl(
      this
    );
    this.availableServiceAliases = new AvailableServiceAliasesImpl(this);
    this.azureFirewalls = new AzureFirewallsImpl(this);
    this.azureFirewallFqdnTags = new AzureFirewallFqdnTagsImpl(this);
    this.bastionHosts = new BastionHostsImpl(this);
    this.ddosCustomPolicies = new DdosCustomPoliciesImpl(this);
    this.ddosProtectionPlans = new DdosProtectionPlansImpl(this);
    this.availableEndpointServices = new AvailableEndpointServicesImpl(this);
    this.expressRouteCircuitAuthorizations = new ExpressRouteCircuitAuthorizationsImpl(
      this
    );
    this.expressRouteCircuitPeerings = new ExpressRouteCircuitPeeringsImpl(
      this
    );
    this.expressRouteCircuitConnections = new ExpressRouteCircuitConnectionsImpl(
      this
    );
    this.peerExpressRouteCircuitConnections = new PeerExpressRouteCircuitConnectionsImpl(
      this
    );
    this.expressRouteCircuits = new ExpressRouteCircuitsImpl(this);
    this.expressRouteServiceProviders = new ExpressRouteServiceProvidersImpl(
      this
    );
    this.expressRouteCrossConnections = new ExpressRouteCrossConnectionsImpl(
      this
    );
    this.expressRouteCrossConnectionPeerings = new ExpressRouteCrossConnectionPeeringsImpl(
      this
    );
    this.expressRoutePortsLocations = new ExpressRoutePortsLocationsImpl(this);
    this.expressRoutePorts = new ExpressRoutePortsImpl(this);
    this.expressRouteLinks = new ExpressRouteLinksImpl(this);
    this.firewallPolicies = new FirewallPoliciesImpl(this);
    this.firewallPolicyRuleGroups = new FirewallPolicyRuleGroupsImpl(this);
    this.ipAllocations = new IpAllocationsImpl(this);
    this.ipGroups = new IpGroupsImpl(this);
    this.loadBalancers = new LoadBalancersImpl(this);
    this.loadBalancerBackendAddressPools = new LoadBalancerBackendAddressPoolsImpl(
      this
    );
    this.loadBalancerFrontendIPConfigurations = new LoadBalancerFrontendIPConfigurationsImpl(
      this
    );
    this.inboundNatRules = new InboundNatRulesImpl(this);
    this.loadBalancerLoadBalancingRules = new LoadBalancerLoadBalancingRulesImpl(
      this
    );
    this.loadBalancerOutboundRules = new LoadBalancerOutboundRulesImpl(this);
    this.loadBalancerNetworkInterfaces = new LoadBalancerNetworkInterfacesImpl(
      this
    );
    this.loadBalancerProbes = new LoadBalancerProbesImpl(this);
    this.natGateways = new NatGatewaysImpl(this);
    this.networkInterfaces = new NetworkInterfacesImpl(this);
    this.networkInterfaceIPConfigurations = new NetworkInterfaceIPConfigurationsImpl(
      this
    );
    this.networkInterfaceLoadBalancers = new NetworkInterfaceLoadBalancersImpl(
      this
    );
    this.networkInterfaceTapConfigurations = new NetworkInterfaceTapConfigurationsImpl(
      this
    );
    this.networkProfiles = new NetworkProfilesImpl(this);
    this.networkSecurityGroups = new NetworkSecurityGroupsImpl(this);
    this.securityRules = new SecurityRulesImpl(this);
    this.defaultSecurityRules = new DefaultSecurityRulesImpl(this);
    this.networkVirtualAppliances = new NetworkVirtualAppliancesImpl(this);
    this.networkWatchers = new NetworkWatchersImpl(this);
    this.packetCaptures = new PacketCapturesImpl(this);
    this.connectionMonitors = new ConnectionMonitorsImpl(this);
    this.flowLogs = new FlowLogsImpl(this);
    this.operations = new OperationsImpl(this);
    this.privateEndpoints = new PrivateEndpointsImpl(this);
    this.availablePrivateEndpointTypes = new AvailablePrivateEndpointTypesImpl(
      this
    );
    this.privateDnsZoneGroups = new PrivateDnsZoneGroupsImpl(this);
    this.privateLinkServices = new PrivateLinkServicesImpl(this);
    this.publicIPAddresses = new PublicIPAddressesImpl(this);
    this.publicIPPrefixes = new PublicIPPrefixesImpl(this);
    this.routeFilters = new RouteFiltersImpl(this);
    this.routeFilterRules = new RouteFilterRulesImpl(this);
    this.routeTables = new RouteTablesImpl(this);
    this.routes = new RoutesImpl(this);
    this.securityPartnerProviders = new SecurityPartnerProvidersImpl(this);
    this.bgpServiceCommunities = new BgpServiceCommunitiesImpl(this);
    this.serviceEndpointPolicies = new ServiceEndpointPoliciesImpl(this);
    this.serviceEndpointPolicyDefinitions = new ServiceEndpointPolicyDefinitionsImpl(
      this
    );
    this.serviceTags = new ServiceTagsImpl(this);
    this.usages = new UsagesImpl(this);
    this.virtualNetworks = new VirtualNetworksImpl(this);
    this.subnets = new SubnetsImpl(this);
    this.resourceNavigationLinks = new ResourceNavigationLinksImpl(this);
    this.serviceAssociationLinks = new ServiceAssociationLinksImpl(this);
    this.virtualNetworkPeerings = new VirtualNetworkPeeringsImpl(this);
    this.virtualNetworkGateways = new VirtualNetworkGatewaysImpl(this);
    this.virtualNetworkGatewayConnections = new VirtualNetworkGatewayConnectionsImpl(
      this
    );
    this.localNetworkGateways = new LocalNetworkGatewaysImpl(this);
    this.virtualNetworkTaps = new VirtualNetworkTapsImpl(this);
    this.virtualRouters = new VirtualRoutersImpl(this);
    this.virtualRouterPeerings = new VirtualRouterPeeringsImpl(this);
    this.virtualWans = new VirtualWansImpl(this);
    this.vpnSites = new VpnSitesImpl(this);
    this.vpnSiteLinks = new VpnSiteLinksImpl(this);
    this.vpnSitesConfiguration = new VpnSitesConfigurationImpl(this);
    this.vpnServerConfigurations = new VpnServerConfigurationsImpl(this);
    this.virtualHubs = new VirtualHubsImpl(this);
    this.hubVirtualNetworkConnections = new HubVirtualNetworkConnectionsImpl(
      this
    );
    this.vpnGateways = new VpnGatewaysImpl(this);
    this.vpnConnections = new VpnConnectionsImpl(this);
    this.vpnSiteLinkConnections = new VpnSiteLinkConnectionsImpl(this);
    this.vpnLinkConnections = new VpnLinkConnectionsImpl(this);
    this.p2SVpnGateways = new P2SVpnGatewaysImpl(this);
    this.vpnServerConfigurationsAssociatedWithVirtualWan = new VpnServerConfigurationsAssociatedWithVirtualWanImpl(
      this
    );
    this.virtualHubRouteTableV2S = new VirtualHubRouteTableV2SImpl(this);
    this.expressRouteGateways = new ExpressRouteGatewaysImpl(this);
    this.expressRouteConnections = new ExpressRouteConnectionsImpl(this);
    this.hubRouteTables = new HubRouteTablesImpl(this);
    this.webApplicationFirewallPolicies = new WebApplicationFirewallPoliciesImpl(
      this
    );
  }

  private getOperationOptions<TOptions extends coreHttp.OperationOptions>(
    options: TOptions | undefined,
    finalStateVia?: string
  ): coreHttp.RequestOptionsBase {
    const operationOptions: coreHttp.OperationOptions = options || {};
    operationOptions.requestOptions = {
      ...operationOptions.requestOptions,
      shouldDeserialize: shouldDeserializeLRO(finalStateVia)
    };
    return coreHttp.operationOptionsToRequestOptionsBase(operationOptions);
  }

  /**
   * Creates a Bastion Shareable Links for all the VMs specified in the request.
   * @param resourceGroupName The name of the resource group.
   * @param bastionHostName The name of the Bastion Host.
   * @param bslRequest Post request for all the Bastion Shareable Link endpoints.
   * @param options The options parameters.
   */
  public listPutBastionShareableLink(
    resourceGroupName: string,
    bastionHostName: string,
    bslRequest: BastionShareableLinkListRequest,
    options?: coreHttp.OperationOptions
  ): PagedAsyncIterableIterator<BastionShareableLink> {
    const iter = this.putBastionShareableLinkPagingAll(
      resourceGroupName,
      bastionHostName,
      bslRequest,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.putBastionShareableLinkPagingPage(
          resourceGroupName,
          bastionHostName,
          bslRequest,
          options
        );
      }
    };
  }

  private async *putBastionShareableLinkPagingPage(
    resourceGroupName: string,
    bastionHostName: string,
    bslRequest: BastionShareableLinkListRequest,
    options?: coreHttp.OperationOptions
  ): AsyncIterableIterator<BastionShareableLink[]> {
    const poller = await this._putBastionShareableLink(
      resourceGroupName,
      bastionHostName,
      bslRequest,
      options
    );
    let result: any = await poller.pollUntilDone();
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._putBastionShareableLinkNext(
        resourceGroupName,
        bastionHostName,
        bslRequest,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *putBastionShareableLinkPagingAll(
    resourceGroupName: string,
    bastionHostName: string,
    bslRequest: BastionShareableLinkListRequest,
    options?: coreHttp.OperationOptions
  ): AsyncIterableIterator<BastionShareableLink> {
    for await (const page of this.putBastionShareableLinkPagingPage(
      resourceGroupName,
      bastionHostName,
      bslRequest,
      options
    )) {
      yield* page;
    }
  }

  /**
   * Return the Bastion Shareable Links for all the VMs specified in the request.
   * @param resourceGroupName The name of the resource group.
   * @param bastionHostName The name of the Bastion Host.
   * @param bslRequest Post request for all the Bastion Shareable Link endpoints.
   * @param options The options parameters.
   */
  public listBastionShareableLink(
    resourceGroupName: string,
    bastionHostName: string,
    bslRequest: BastionShareableLinkListRequest,
    options?: coreHttp.OperationOptions
  ): PagedAsyncIterableIterator<BastionShareableLink> {
    const iter = this.getBastionShareableLinkPagingAll(
      resourceGroupName,
      bastionHostName,
      bslRequest,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.getBastionShareableLinkPagingPage(
          resourceGroupName,
          bastionHostName,
          bslRequest,
          options
        );
      }
    };
  }

  private async *getBastionShareableLinkPagingPage(
    resourceGroupName: string,
    bastionHostName: string,
    bslRequest: BastionShareableLinkListRequest,
    options?: coreHttp.OperationOptions
  ): AsyncIterableIterator<BastionShareableLink[]> {
    let result = await this._getBastionShareableLink(
      resourceGroupName,
      bastionHostName,
      bslRequest,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._getBastionShareableLinkNext(
        resourceGroupName,
        bastionHostName,
        bslRequest,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *getBastionShareableLinkPagingAll(
    resourceGroupName: string,
    bastionHostName: string,
    bslRequest: BastionShareableLinkListRequest,
    options?: coreHttp.OperationOptions
  ): AsyncIterableIterator<BastionShareableLink> {
    for await (const page of this.getBastionShareableLinkPagingPage(
      resourceGroupName,
      bastionHostName,
      bslRequest,
      options
    )) {
      yield* page;
    }
  }

  /**
   * Returns the list of currently active sessions on the Bastion.
   * @param resourceGroupName The name of the resource group.
   * @param bastionHostName The name of the Bastion Host.
   * @param options The options parameters.
   */
  public listActiveSessions(
    resourceGroupName: string,
    bastionHostName: string,
    options?: coreHttp.OperationOptions
  ): PagedAsyncIterableIterator<BastionActiveSession> {
    const iter = this.getActiveSessionsPagingAll(
      resourceGroupName,
      bastionHostName,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.getActiveSessionsPagingPage(
          resourceGroupName,
          bastionHostName,
          options
        );
      }
    };
  }

  private async *getActiveSessionsPagingPage(
    resourceGroupName: string,
    bastionHostName: string,
    options?: coreHttp.OperationOptions
  ): AsyncIterableIterator<BastionActiveSession[]> {
    const poller = await this._getActiveSessions(
      resourceGroupName,
      bastionHostName,
      options
    );
    let result: any = await poller.pollUntilDone();
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._getActiveSessionsNext(
        resourceGroupName,
        bastionHostName,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *getActiveSessionsPagingAll(
    resourceGroupName: string,
    bastionHostName: string,
    options?: coreHttp.OperationOptions
  ): AsyncIterableIterator<BastionActiveSession> {
    for await (const page of this.getActiveSessionsPagingPage(
      resourceGroupName,
      bastionHostName,
      options
    )) {
      yield* page;
    }
  }

  /**
   * Returns the list of currently active sessions on the Bastion.
   * @param resourceGroupName The name of the resource group.
   * @param bastionHostName The name of the Bastion Host.
   * @param sessionIds The list of sessionids to disconnect.
   * @param options The options parameters.
   */
  public listDisconnectActiveSessions(
    resourceGroupName: string,
    bastionHostName: string,
    sessionIds: SessionIds,
    options?: coreHttp.OperationOptions
  ): PagedAsyncIterableIterator<BastionSessionState> {
    const iter = this.disconnectActiveSessionsPagingAll(
      resourceGroupName,
      bastionHostName,
      sessionIds,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.disconnectActiveSessionsPagingPage(
          resourceGroupName,
          bastionHostName,
          sessionIds,
          options
        );
      }
    };
  }

  private async *disconnectActiveSessionsPagingPage(
    resourceGroupName: string,
    bastionHostName: string,
    sessionIds: SessionIds,
    options?: coreHttp.OperationOptions
  ): AsyncIterableIterator<BastionSessionState[]> {
    let result = await this._disconnectActiveSessions(
      resourceGroupName,
      bastionHostName,
      sessionIds,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._disconnectActiveSessionsNext(
        resourceGroupName,
        bastionHostName,
        sessionIds,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *disconnectActiveSessionsPagingAll(
    resourceGroupName: string,
    bastionHostName: string,
    sessionIds: SessionIds,
    options?: coreHttp.OperationOptions
  ): AsyncIterableIterator<BastionSessionState> {
    for await (const page of this.disconnectActiveSessionsPagingPage(
      resourceGroupName,
      bastionHostName,
      sessionIds,
      options
    )) {
      yield* page;
    }
  }

  /**
   * Creates a Bastion Shareable Links for all the VMs specified in the request.
   * @param resourceGroupName The name of the resource group.
   * @param bastionHostName The name of the Bastion Host.
   * @param bslRequest Post request for all the Bastion Shareable Link endpoints.
   * @param options The options parameters.
   */
  private async _putBastionShareableLink(
    resourceGroupName: string,
    bastionHostName: string,
    bslRequest: BastionShareableLinkListRequest,
    options?: coreHttp.OperationOptions
  ): Promise<
    PollerLike<
      PollOperationState<
        NetworkManagementClientPutBastionShareableLinkResponse
      >,
      NetworkManagementClientPutBastionShareableLinkResponse
    >
  > {
    const operationArguments: coreHttp.OperationArguments = {
      resourceGroupName,
      bastionHostName,
      bslRequest,
      options: this.getOperationOptions(options, "location")
    };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) => {
      return this.sendOperationRequest(args, spec) as Promise<
        NetworkManagementClientPutBastionShareableLinkResponse
      >;
    };

    const initialOperationResult = await sendOperation(
      operationArguments,
      putBastionShareableLinkOperationSpec
    );
    return new LROPoller({
      initialOperationArguments: operationArguments,
      initialOperationSpec: putBastionShareableLinkOperationSpec,
      initialOperationResult,
      sendOperation,
      finalStateVia: "location"
    });
  }

  /**
   * Deletes the Bastion Shareable Links for all the VMs specified in the request.
   * @param resourceGroupName The name of the resource group.
   * @param bastionHostName The name of the Bastion Host.
   * @param bslRequest Post request for all the Bastion Shareable Link endpoints.
   * @param options The options parameters.
   */
  async deleteBastionShareableLink(
    resourceGroupName: string,
    bastionHostName: string,
    bslRequest: BastionShareableLinkListRequest,
    options?: coreHttp.OperationOptions
  ): Promise<
    PollerLike<PollOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>
  > {
    const operationArguments: coreHttp.OperationArguments = {
      resourceGroupName,
      bastionHostName,
      bslRequest,
      options: this.getOperationOptions(options, "location")
    };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) => {
      return this.sendOperationRequest(args, spec) as Promise<
        coreHttp.RestResponse
      >;
    };

    const initialOperationResult = await sendOperation(
      operationArguments,
      deleteBastionShareableLinkOperationSpec
    );
    return new LROPoller({
      initialOperationArguments: operationArguments,
      initialOperationSpec: deleteBastionShareableLinkOperationSpec,
      initialOperationResult,
      sendOperation,
      finalStateVia: "location"
    });
  }

  /**
   * Return the Bastion Shareable Links for all the VMs specified in the request.
   * @param resourceGroupName The name of the resource group.
   * @param bastionHostName The name of the Bastion Host.
   * @param bslRequest Post request for all the Bastion Shareable Link endpoints.
   * @param options The options parameters.
   */
  private _getBastionShareableLink(
    resourceGroupName: string,
    bastionHostName: string,
    bslRequest: BastionShareableLinkListRequest,
    options?: coreHttp.OperationOptions
  ): Promise<NetworkManagementClientGetBastionShareableLinkResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      resourceGroupName,
      bastionHostName,
      bslRequest,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      getBastionShareableLinkOperationSpec
    ) as Promise<NetworkManagementClientGetBastionShareableLinkResponse>;
  }

  /**
   * Returns the list of currently active sessions on the Bastion.
   * @param resourceGroupName The name of the resource group.
   * @param bastionHostName The name of the Bastion Host.
   * @param options The options parameters.
   */
  private async _getActiveSessions(
    resourceGroupName: string,
    bastionHostName: string,
    options?: coreHttp.OperationOptions
  ): Promise<
    PollerLike<
      PollOperationState<NetworkManagementClientGetActiveSessionsResponse>,
      NetworkManagementClientGetActiveSessionsResponse
    >
  > {
    const operationArguments: coreHttp.OperationArguments = {
      resourceGroupName,
      bastionHostName,
      options: this.getOperationOptions(options, "location")
    };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) => {
      return this.sendOperationRequest(args, spec) as Promise<
        NetworkManagementClientGetActiveSessionsResponse
      >;
    };

    const initialOperationResult = await sendOperation(
      operationArguments,
      getActiveSessionsOperationSpec
    );
    return new LROPoller({
      initialOperationArguments: operationArguments,
      initialOperationSpec: getActiveSessionsOperationSpec,
      initialOperationResult,
      sendOperation,
      finalStateVia: "location"
    });
  }

  /**
   * Returns the list of currently active sessions on the Bastion.
   * @param resourceGroupName The name of the resource group.
   * @param bastionHostName The name of the Bastion Host.
   * @param sessionIds The list of sessionids to disconnect.
   * @param options The options parameters.
   */
  private _disconnectActiveSessions(
    resourceGroupName: string,
    bastionHostName: string,
    sessionIds: SessionIds,
    options?: coreHttp.OperationOptions
  ): Promise<NetworkManagementClientDisconnectActiveSessionsResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      resourceGroupName,
      bastionHostName,
      sessionIds,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      disconnectActiveSessionsOperationSpec
    ) as Promise<NetworkManagementClientDisconnectActiveSessionsResponse>;
  }

  /**
   * Checks whether a domain name in the cloudapp.azure.com zone is available for use.
   * @param location The location of the domain name.
   * @param domainNameLabel The domain name to be verified. It must conform to the following regular
   *                        expression: ^[a-z][a-z0-9-]{1,61}[a-z0-9]$.
   * @param options The options parameters.
   */
  checkDnsNameAvailability(
    location: string,
    domainNameLabel: string,
    options?: coreHttp.OperationOptions
  ): Promise<NetworkManagementClientCheckDnsNameAvailabilityResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      location,
      domainNameLabel,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      checkDnsNameAvailabilityOperationSpec
    ) as Promise<NetworkManagementClientCheckDnsNameAvailabilityResponse>;
  }

  /**
   * Gives the supported security providers for the virtual wan.
   * @param resourceGroupName The resource group name.
   * @param virtualWANName The name of the VirtualWAN for which supported security providers are needed.
   * @param options The options parameters.
   */
  supportedSecurityProviders(
    resourceGroupName: string,
    virtualWANName: string,
    options?: coreHttp.OperationOptions
  ): Promise<NetworkManagementClientSupportedSecurityProvidersResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      resourceGroupName,
      virtualWANName,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      supportedSecurityProvidersOperationSpec
    ) as Promise<NetworkManagementClientSupportedSecurityProvidersResponse>;
  }

  /**
   * Generates a unique VPN profile for P2S clients for VirtualWan and associated VpnServerConfiguration
   * combination in the specified resource group.
   * @param resourceGroupName The resource group name.
   * @param virtualWANName The name of the VirtualWAN whose associated VpnServerConfigurations is needed.
   * @param vpnClientParams Parameters supplied to the generate VirtualWan VPN profile generation
   *                        operation.
   * @param options The options parameters.
   */
  async generatevirtualwanvpnserverconfigurationvpnprofile(
    resourceGroupName: string,
    virtualWANName: string,
    vpnClientParams: VirtualWanVpnProfileParameters,
    options?: coreHttp.OperationOptions
  ): Promise<
    PollerLike<
      PollOperationState<
        NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofileResponse
      >,
      NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofileResponse
    >
  > {
    const operationArguments: coreHttp.OperationArguments = {
      resourceGroupName,
      virtualWANName,
      vpnClientParams,
      options: this.getOperationOptions(options, "location")
    };
    const sendOperation = (
      args: coreHttp.OperationArguments,
      spec: coreHttp.OperationSpec
    ) => {
      return this.sendOperationRequest(args, spec) as Promise<
        NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofileResponse
      >;
    };

    const initialOperationResult = await sendOperation(
      operationArguments,
      generatevirtualwanvpnserverconfigurationvpnprofileOperationSpec
    );
    return new LROPoller({
      initialOperationArguments: operationArguments,
      initialOperationSpec: generatevirtualwanvpnserverconfigurationvpnprofileOperationSpec,
      initialOperationResult,
      sendOperation,
      finalStateVia: "location"
    });
  }

  /**
   * PutBastionShareableLinkNext
   * @param resourceGroupName The name of the resource group.
   * @param bastionHostName The name of the Bastion Host.
   * @param bslRequest Post request for all the Bastion Shareable Link endpoints.
   * @param nextLink The nextLink from the previous successful call to the PutBastionShareableLink
   *                 method.
   * @param options The options parameters.
   */
  private _putBastionShareableLinkNext(
    resourceGroupName: string,
    bastionHostName: string,
    bslRequest: BastionShareableLinkListRequest,
    nextLink: string,
    options?: coreHttp.OperationOptions
  ): Promise<NetworkManagementClientPutBastionShareableLinkNextResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      resourceGroupName,
      bastionHostName,
      bslRequest,
      nextLink,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      putBastionShareableLinkNextOperationSpec
    ) as Promise<NetworkManagementClientPutBastionShareableLinkNextResponse>;
  }

  /**
   * GetBastionShareableLinkNext
   * @param resourceGroupName The name of the resource group.
   * @param bastionHostName The name of the Bastion Host.
   * @param bslRequest Post request for all the Bastion Shareable Link endpoints.
   * @param nextLink The nextLink from the previous successful call to the GetBastionShareableLink
   *                 method.
   * @param options The options parameters.
   */
  private _getBastionShareableLinkNext(
    resourceGroupName: string,
    bastionHostName: string,
    bslRequest: BastionShareableLinkListRequest,
    nextLink: string,
    options?: coreHttp.OperationOptions
  ): Promise<NetworkManagementClientGetBastionShareableLinkNextResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      resourceGroupName,
      bastionHostName,
      bslRequest,
      nextLink,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      getBastionShareableLinkNextOperationSpec
    ) as Promise<NetworkManagementClientGetBastionShareableLinkNextResponse>;
  }

  /**
   * GetActiveSessionsNext
   * @param resourceGroupName The name of the resource group.
   * @param bastionHostName The name of the Bastion Host.
   * @param nextLink The nextLink from the previous successful call to the GetActiveSessions method.
   * @param options The options parameters.
   */
  private _getActiveSessionsNext(
    resourceGroupName: string,
    bastionHostName: string,
    nextLink: string,
    options?: coreHttp.OperationOptions
  ): Promise<NetworkManagementClientGetActiveSessionsNextResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      resourceGroupName,
      bastionHostName,
      nextLink,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      getActiveSessionsNextOperationSpec
    ) as Promise<NetworkManagementClientGetActiveSessionsNextResponse>;
  }

  /**
   * DisconnectActiveSessionsNext
   * @param resourceGroupName The name of the resource group.
   * @param bastionHostName The name of the Bastion Host.
   * @param sessionIds The list of sessionids to disconnect.
   * @param nextLink The nextLink from the previous successful call to the DisconnectActiveSessions
   *                 method.
   * @param options The options parameters.
   */
  private _disconnectActiveSessionsNext(
    resourceGroupName: string,
    bastionHostName: string,
    sessionIds: SessionIds,
    nextLink: string,
    options?: coreHttp.OperationOptions
  ): Promise<NetworkManagementClientDisconnectActiveSessionsNextResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      resourceGroupName,
      bastionHostName,
      sessionIds,
      nextLink,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      disconnectActiveSessionsNextOperationSpec
    ) as Promise<NetworkManagementClientDisconnectActiveSessionsNextResponse>;
  }

  applicationGateways: ApplicationGateways;
  applicationSecurityGroups: ApplicationSecurityGroups;
  availableDelegations: AvailableDelegations;
  availableResourceGroupDelegations: AvailableResourceGroupDelegations;
  availableServiceAliases: AvailableServiceAliases;
  azureFirewalls: AzureFirewalls;
  azureFirewallFqdnTags: AzureFirewallFqdnTags;
  bastionHosts: BastionHosts;
  ddosCustomPolicies: DdosCustomPolicies;
  ddosProtectionPlans: DdosProtectionPlans;
  availableEndpointServices: AvailableEndpointServices;
  expressRouteCircuitAuthorizations: ExpressRouteCircuitAuthorizations;
  expressRouteCircuitPeerings: ExpressRouteCircuitPeerings;
  expressRouteCircuitConnections: ExpressRouteCircuitConnections;
  peerExpressRouteCircuitConnections: PeerExpressRouteCircuitConnections;
  expressRouteCircuits: ExpressRouteCircuits;
  expressRouteServiceProviders: ExpressRouteServiceProviders;
  expressRouteCrossConnections: ExpressRouteCrossConnections;
  expressRouteCrossConnectionPeerings: ExpressRouteCrossConnectionPeerings;
  expressRoutePortsLocations: ExpressRoutePortsLocations;
  expressRoutePorts: ExpressRoutePorts;
  expressRouteLinks: ExpressRouteLinks;
  firewallPolicies: FirewallPolicies;
  firewallPolicyRuleGroups: FirewallPolicyRuleGroups;
  ipAllocations: IpAllocations;
  ipGroups: IpGroups;
  loadBalancers: LoadBalancers;
  loadBalancerBackendAddressPools: LoadBalancerBackendAddressPools;
  loadBalancerFrontendIPConfigurations: LoadBalancerFrontendIPConfigurations;
  inboundNatRules: InboundNatRules;
  loadBalancerLoadBalancingRules: LoadBalancerLoadBalancingRules;
  loadBalancerOutboundRules: LoadBalancerOutboundRules;
  loadBalancerNetworkInterfaces: LoadBalancerNetworkInterfaces;
  loadBalancerProbes: LoadBalancerProbes;
  natGateways: NatGateways;
  networkInterfaces: NetworkInterfaces;
  networkInterfaceIPConfigurations: NetworkInterfaceIPConfigurations;
  networkInterfaceLoadBalancers: NetworkInterfaceLoadBalancers;
  networkInterfaceTapConfigurations: NetworkInterfaceTapConfigurations;
  networkProfiles: NetworkProfiles;
  networkSecurityGroups: NetworkSecurityGroups;
  securityRules: SecurityRules;
  defaultSecurityRules: DefaultSecurityRules;
  networkVirtualAppliances: NetworkVirtualAppliances;
  networkWatchers: NetworkWatchers;
  packetCaptures: PacketCaptures;
  connectionMonitors: ConnectionMonitors;
  flowLogs: FlowLogs;
  operations: Operations;
  privateEndpoints: PrivateEndpoints;
  availablePrivateEndpointTypes: AvailablePrivateEndpointTypes;
  privateDnsZoneGroups: PrivateDnsZoneGroups;
  privateLinkServices: PrivateLinkServices;
  publicIPAddresses: PublicIPAddresses;
  publicIPPrefixes: PublicIPPrefixes;
  routeFilters: RouteFilters;
  routeFilterRules: RouteFilterRules;
  routeTables: RouteTables;
  routes: Routes;
  securityPartnerProviders: SecurityPartnerProviders;
  bgpServiceCommunities: BgpServiceCommunities;
  serviceEndpointPolicies: ServiceEndpointPolicies;
  serviceEndpointPolicyDefinitions: ServiceEndpointPolicyDefinitions;
  serviceTags: ServiceTags;
  usages: Usages;
  virtualNetworks: VirtualNetworks;
  subnets: Subnets;
  resourceNavigationLinks: ResourceNavigationLinks;
  serviceAssociationLinks: ServiceAssociationLinks;
  virtualNetworkPeerings: VirtualNetworkPeerings;
  virtualNetworkGateways: VirtualNetworkGateways;
  virtualNetworkGatewayConnections: VirtualNetworkGatewayConnections;
  localNetworkGateways: LocalNetworkGateways;
  virtualNetworkTaps: VirtualNetworkTaps;
  virtualRouters: VirtualRouters;
  virtualRouterPeerings: VirtualRouterPeerings;
  virtualWans: VirtualWans;
  vpnSites: VpnSites;
  vpnSiteLinks: VpnSiteLinks;
  vpnSitesConfiguration: VpnSitesConfiguration;
  vpnServerConfigurations: VpnServerConfigurations;
  virtualHubs: VirtualHubs;
  hubVirtualNetworkConnections: HubVirtualNetworkConnections;
  vpnGateways: VpnGateways;
  vpnConnections: VpnConnections;
  vpnSiteLinkConnections: VpnSiteLinkConnections;
  vpnLinkConnections: VpnLinkConnections;
  p2SVpnGateways: P2SVpnGateways;
  vpnServerConfigurationsAssociatedWithVirtualWan: VpnServerConfigurationsAssociatedWithVirtualWan;
  virtualHubRouteTableV2S: VirtualHubRouteTableV2S;
  expressRouteGateways: ExpressRouteGateways;
  expressRouteConnections: ExpressRouteConnections;
  hubRouteTables: HubRouteTables;
  webApplicationFirewallPolicies: WebApplicationFirewallPolicies;
}
// Operation Specifications
const serializer = new coreHttp.Serializer(Mappers, /* isXml */ false);

const putBastionShareableLinkOperationSpec: coreHttp.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/createShareableLinks",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.BastionShareableLinkListResult
    },
    201: {
      bodyMapper: Mappers.BastionShareableLinkListResult
    },
    202: {
      bodyMapper: Mappers.BastionShareableLinkListResult
    },
    204: {
      bodyMapper: Mappers.BastionShareableLinkListResult
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.bslRequest,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.bastionHostName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const deleteBastionShareableLinkOperationSpec: coreHttp.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/deleteShareableLinks",
  httpMethod: "POST",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.bslRequest,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.bastionHostName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const getBastionShareableLinkOperationSpec: coreHttp.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/getShareableLinks",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.BastionShareableLinkListResult
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.bslRequest,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.bastionHostName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const getActiveSessionsOperationSpec: coreHttp.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/getActiveSessions",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.BastionActiveSessionListResult
    },
    201: {
      bodyMapper: Mappers.BastionActiveSessionListResult
    },
    202: {
      bodyMapper: Mappers.BastionActiveSessionListResult
    },
    204: {
      bodyMapper: Mappers.BastionActiveSessionListResult
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.bastionHostName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const disconnectActiveSessionsOperationSpec: coreHttp.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/disconnectActiveSessions",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.BastionSessionDeleteResult
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.sessionIds,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.bastionHostName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const checkDnsNameAvailabilityOperationSpec: coreHttp.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/providers/Microsoft.Network/locations/{location}/CheckDnsNameAvailability",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.DnsNameAvailabilityResult
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.domainNameLabel],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.location
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const supportedSecurityProvidersOperationSpec: coreHttp.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans/{virtualWANName}/supportedSecurityProviders",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.VirtualWanSecurityProviders
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.virtualWANName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const generatevirtualwanvpnserverconfigurationvpnprofileOperationSpec: coreHttp.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans/{virtualWANName}/GenerateVpnProfile",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.VpnProfileResponse
    },
    201: {
      bodyMapper: Mappers.VpnProfileResponse
    },
    202: {
      bodyMapper: Mappers.VpnProfileResponse
    },
    204: {
      bodyMapper: Mappers.VpnProfileResponse
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.vpnClientParams,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.virtualWANName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const putBastionShareableLinkNextOperationSpec: coreHttp.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.BastionShareableLinkListResult
    },
    202: {},
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.nextLink,
    Parameters.bastionHostName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const getBastionShareableLinkNextOperationSpec: coreHttp.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.BastionShareableLinkListResult
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.nextLink,
    Parameters.bastionHostName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const getActiveSessionsNextOperationSpec: coreHttp.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.BastionActiveSessionListResult
    },
    202: {},
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.nextLink,
    Parameters.bastionHostName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const disconnectActiveSessionsNextOperationSpec: coreHttp.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.BastionSessionDeleteResult
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.nextLink,
    Parameters.bastionHostName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
