/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as coreHttp from "@azure/core-http";

/**
 * List of StorSimple Managers under a particular resourceGroup
 */
export interface ManagerList {
  /**
   * List of Managers
   */
  value: Manager[];
}

/**
 * The Azure Resource.
 */
export interface Resource {
  /**
   * The Resource Id
   */
  readonly id?: string;
  /**
   * The Resource Name
   */
  readonly name?: string;
  /**
   * The Resource type
   */
  readonly type?: string;
  /**
   * The Geo location of the Manager
   */
  location: string;
  /**
   * Tags attached to the Manager
   */
  tags?: { [propertyName: string]: string };
}

/**
 * The StorSimple Manager
 */
export type Manager = Resource & {
  /**
   * ETag of the Manager
   */
  etag?: string;
  /**
   * Specifies if the Manager is Garda or Helsinki
   */
  cisIntrinsicSettings?: ManagerIntrinsicSettings;
  /**
   * Specifies the Sku
   */
  sku?: ManagerSku;
  /**
   * Specifies the state of the resource as it is getting provisioned. Value of "Succeeded" means the Manager was successfully created
   */
  readonly provisioningState?: string;
};

/**
 * Intrinsic settings which refers to the type of the StorSimple manager
 */
export interface ManagerIntrinsicSettings {
  /**
   * Refers to the type of the StorSimple Manager
   */
  type: ManagerType;
}

/**
 * The Sku.
 */
export interface ManagerSku {
  /**
   * Refers to the sku name which should be "Standard"
   */
  name: "Standard";
}

export interface ErrorModel {
  errorCode: string;
  message: Message;
  values?: Item[];
}

export interface Message {
  language?: string;
  value?: string;
}

export interface Item {
  key: string;
  value: string;
}

/**
 * Class for set of operations used for discovery of available provider operations.
 */
export interface AvailableProviderOperations {
  /**
   * The value.
   */
  value: AvailableProviderOperation[];
  /**
   * The NextLink.
   */
  nextLink?: string;
}

/**
 * Class represents provider operation
 */
export interface AvailableProviderOperation {
  /**
   * Gets or sets the name of the operation being performed on this particular object
   * Return value format: "{resourceProviderNamespace}/{resourceType}/{read|write|deletion|action}"
   * Eg: Microsoft.StorSimple/managers/devices/fileServers/read
   *     Microsoft.StorSimple/managers/devices/alerts/clearAlerts/action
   */
  name?: string;
  /**
   * Gets or sets Display information
   * Contains the localized display information for this particular operation/action
   */
  display?: AvailableProviderOperationDisplay;
  /**
   * Gets or sets Origin
   * The intended executor of the operation; governs the display of the operation in the RBAC UX and the audit logs UX.
   * Default value is “user,system”
   */
  origin?: string;
  /**
   * Gets or sets Properties
   * Reserved for future use
   */
  properties?: any;
}

/**
 * Contains the localized display information for this particular operation / action.
 * These value will be used by several clients for
 * (1) custom role definitions for RBAC;
 * (2) complex query filters for the event service; and (3) audit history / records for management operations.
 */
export interface AvailableProviderOperationDisplay {
  /**
   * Gets or sets Provider
   * The localized friendly form of the resource provider name – it is expected to also include the publisher/company responsible.
   * It should use Title Casing and begin with “Microsoft” for 1st party services.
   */
  provider?: string;
  /**
   * Gets or sets Resource
   * The localized friendly form of the resource type related to this action/operation – it should match the public documentation for the resource provider.
   * It should use Title Casing – for examples, please refer to the “name” section.
   */
  resource?: string;
  /**
   * Gets or sets Operation
   * The localized friendly name for the operation, as it should be shown to the user.
   * It should be concise (to fit in drop downs) but clear (i.e. self-documenting). It should use Title Casing and include the entity/resource to which it applies.
   */
  operation?: string;
  /**
   * Gets or sets Description
   * The localized friendly description for the operation, as it should be shown to the user.
   * It should be thorough, yet concise – it will be used in tool tips and detailed views.
   */
  description?: string;
}

/**
 * The StorSimple Manager patch.
 */
export interface ManagerPatch {
  /**
   * The tags attached to the StorSimple Manager.
   */
  tags?: { [propertyName: string]: string };
}

/**
 * Collection of AccessControlRecords
 */
export interface AccessControlRecordList {
  /**
   * The value.
   */
  value: AccessControlRecord[];
}

/**
 * Base class for models
 */
export interface BaseModel {
  /**
   * The identifier.
   */
  readonly id?: string;
  /**
   * The name.
   */
  readonly name?: string;
  /**
   * The type.
   */
  readonly type?: string;
}

/**
 * The access control record
 */
export type AccessControlRecord = BaseModel & {
  /**
   * The Iscsi initiator name (IQN)
   */
  initiatorName: string;
};

/**
 * Collection of Alerts
 */
export interface AlertList {
  /**
   * The value.
   */
  value: Alert[];
  /**
   * Id of the next page of alerts
   */
  nextLink?: string;
}

/**
 * Alert class
 */
export type Alert = BaseModel & {
  /**
   * Title of the alert
   */
  title: string;
  /**
   * Device or Resource alert
   */
  scope: AlertScope;
  /**
   * Type of the alert
   */
  alertType: string;
  /**
   * UTC time at which the alert appeared
   */
  appearedAtTime: Date;
  /**
   * UTC time at which the alert appeared on the source
   */
  appearedAtSourceTime: Date;
  /**
   * UTC time at which the alert got cleared
   */
  clearedAtTime?: Date;
  /**
   * UTC time at which the alert was cleared on the source
   */
  clearedAtSourceTime?: Date;
  /**
   * Source at which the alert was cleared
   */
  source: AlertSource;
  /**
   * Recommendation for acting on the alert
   */
  recommendation?: string;
  /**
   * Reason for resolving the alert
   */
  resolutionReason?: string;
  /**
   * Severity of the alert
   */
  severity: AlertSeverity;
  /**
   * Current status of the alert
   */
  status: AlertStatus;
  /**
   * ErrorDetails of the alert
   */
  errorDetails?: AlertErrorDetails;
  /**
   * Other information about the alert
   */
  detailedInformation?: { [propertyName: string]: string };
};

/**
 * source at which the alert can be raised
 */
export interface AlertSource {
  /**
   * Name of the source.
   */
  name?: string;
  /**
   * The time zone.
   */
  timeZone?: string;
  /**
   * Source type of the alert.
   */
  alertSourceType?: AlertSourceType;
}

/**
 * Error details for the alert
 */
export interface AlertErrorDetails {
  /**
   * Error code.
   */
  errorCode?: string;
  /**
   * Error Message
   */
  errorMessage?: string;
  /**
   * Number of occurrences.
   */
  occurences?: number;
}

/**
 * Collection of backups
 */
export interface BackupList {
  /**
   * The value.
   */
  value: Backup[];
  /**
   * The NextLink.
   */
  nextLink?: string;
}

/**
 * The backup.
 */
export type Backup = BaseModel & {
  /**
   * The path id of the target FileServer or IscsiServer for which the backup was taken.
   */
  targetId?: string;
  /**
   * Type of target, FileServer or IscsiServer
   */
  targetType?: string;
  /**
   * The backup size in bytes.
   */
  sizeInBytes: number;
  /**
   * The time when the backup was created.
   */
  createdTime?: Date;
  /**
   * The time when the backup will expire.
   */
  expirationTime?: Date;
  /**
   * Indicates how the backup was initiated "Manual | Scheduled".
   */
  initiatedBy: InitiatedBy;
  /**
   * The Device Identifier.
   */
  deviceId: string;
  /**
   * The backup elements.
   */
  elements: BackupElement[];
};

/**
 * Class represents BackupElement
 */
export type BackupElement = BaseModel & {
  /**
   * The size in bytes.
   */
  sizeInBytes: number;
  /**
   * The name of the endpoint.
   */
  endpointName: string;
  /**
   * The data policy of backed up endpoint.
   */
  dataPolicy: DataPolicy;
};

/**
 * Upload Certificate Request to IDM
 */
export interface UploadCertificateRequest {
  /**
   * Gets ContractVersion
   */
  readonly contractVersion?: ContractVersions;
  /**
   * Specify the Authentication type
   */
  authType?: AuthType;
  /**
   * Gets or sets the base64 encoded certificate raw data string
   */
  certificate: string;
}

/**
 * Upload Certificate Response from IDM
 */
export type UploadCertificateResponse = BaseModel & {
  /**
   * Specify the Authentication type
   */
  authType?: AuthType;
  /**
   * Gets or sets the base64 encoded certificate raw data string
   */
  certificate: string;
  /**
   * Gets or Sets the ResourceId
   */
  resourceId: number;
  /**
   * AAD tenant authority
   */
  aadAuthority: string;
  /**
   * AAD tenant Id
   */
  aadTenantId: string;
  /**
   * AAD service principal clientId
   */
  servicePrincipalClientId: string;
  /**
   * AAD service principal ObjectId
   */
  servicePrincipalObjectId: string;
  /**
   * Azure Management Endpoint Audience
   */
  azureManagementEndpointAudience: string;
  /**
   * Certificate Subject Name
   */
  subject: string;
  /**
   * Certificate Validity start Date time
   */
  validFrom: Date;
  /**
   * Certificate Validity End Date time
   */
  validTo: Date;
  /**
   * Certificate thumbprint
   */
  thumbprint: string;
  /**
   * Certificate friendly name
   */
  friendlyName: string;
  /**
   * Certificate issuer
   */
  issuer: string;
};

/**
 * Request for clearing the alert
 */
export interface ClearAlertRequest {
  /**
   * Resolution message while clearing the request
   */
  resolutionMessage?: string;
  /**
   * List of alert Ids to be cleared
   */
  alerts: string[];
}

/**
 * Collection of Devices
 */
export interface DeviceList {
  /**
   * The value.
   */
  value: Device[];
}

/**
 * Represents a StorSimple device object along with its properties
 */
export type Device = BaseModel & {
  /**
   * The UTC time at which the device was activated
   */
  activationTime?: Date;
  /**
   * Operations that are allowed on the device based on its current state
   */
  allowedDeviceOperations?: DeviceOperation[];
  /**
   * Language culture setting on the device. For eg: "en-US"
   */
  culture?: string;
  /**
   * Device can be configured either as FileServer or IscsiServer
   */
  deviceCapabilities?: SupportedDeviceCapabilities[];
  /**
   * Short description given for the device
   */
  deviceDescription?: string;
  /**
   * Fully qualified name of the domain to which the device is attached
   */
  domainName?: string;
  /**
   * Version number of the software running on the device
   */
  deviceSoftwareVersion?: string;
  /**
   * Friendly name for the software version
   */
  friendlySoftwareName?: string;
  /**
   * "Complete" if the device has been successfully registered as File/IscsiServer and the creation of share/volume is complete, "Pending" if the device is only registered but the creation of share/volume is complete is still pending
   */
  deviceConfigurationStatus?: DeviceConfigurationStatus;
  /**
   * Name of the device model
   */
  modelDescription?: string;
  /**
   * Current status of the device
   */
  status?: DeviceStatus;
  /**
   * Type of the device
   */
  typePropertiesType?: DeviceType;
  /**
   * subclass containing more storage-related information about the device. This field will be populated only if the get call is made with $expand = details.
   */
  details?: DeviceDetails;
};

/**
 * Class containing more granular details about the device
 */
export interface DeviceDetails {
  /**
   * Total number of endpoints that are currently on the device ( i.e. number of shares on FileServer or number of volumes on IscsiServer)
   */
  endpointCount?: number;
  /**
   * Total storage available on the device in bytes.
   */
  totalStorageInBytes?: number;
  /**
   * Total local storage capacity in device in bytes.
   */
  totalLocalStorageInBytes?: number;
  /**
   * Storage in bytes that has been provisioned on the device including both local and cloud
   */
  provisionedStorageInBytes?: number;
  /**
   * Storage in bytes that has been provisioned locally on the device
   */
  provisionedLocalStorageInBytes?: number;
  /**
   * Storage that is being currently used in bytes including both local and cloud
   */
  usingStorageInBytes?: number;
  /**
   * Local Storage that is being currently used in bytes
   */
  usingLocalStorageInBytes?: number;
  /**
   * Total size taken up by backups in bytes
   */
  totalBackupSizeInBytes?: number;
  /**
   * Total pending available storage on the device in bytes
   */
  availableStorageInBytes?: number;
  /**
   * Local pending storage available on the device in bytes
   */
  availableLocalStorageInBytes?: number;
}

/**
 * Class that represents the Input for the PATCH call on Device. Currently the only patchable property on device is "DeviceDescription"
 */
export interface DevicePatch {
  /**
   * Short description given for the device
   */
  deviceDescription?: string;
}

/**
 * AlertSettings on the device which represents how alerts will be processed
 */
export type AlertSettings = BaseModel & {
  /**
   * Value indicating whether user/admins will receive emails when an alert condition occurs on the system
   */
  emailNotification: AlertEmailNotificationStatus;
  /**
   * Value indicating whether service owners will receive emails when an alert condition occurs on the system. Applicable only if emailNotification flag is Enabled.
   */
  notificationToServiceOwners: ServiceOwnersAlertNotificationStatus;
  /**
   * Culture setting to be used while building alert emails. For eg: "en-US"
   */
  alertNotificationCulture: string;
  /**
   * List of email addresses (apart from admin/co-admin of subscription) to whom the alert emails need to be sent
   */
  additionalRecipientEmailList?: string[];
};

/**
 * Clone Job Request Model.
 */
export interface CloneRequest {
  /**
   * DeviceId of the device which will act as the Clone target
   */
  targetDeviceId: string;
  /**
   * Access point Id on which clone job will performed.
   */
  targetAccessPointId: string;
  /**
   * Name of new endpoint which will created as part of clone job.
   */
  newEndpointName: string;
  /**
   * Share Object.
   */
  share?: FileShare;
  /**
   * Disk Object
   */
  disk?: IscsiDisk;
}

/**
 * The File Share.
 */
export type FileShare = BaseModel & {
  /**
   * Description for file share
   */
  description?: string;
  /**
   * The Share Status
   */
  shareStatus: ShareStatus;
  /**
   * The data policy
   */
  dataPolicy: DataPolicy;
  /**
   * The user/group who will have full permission in this share. Active directory email address. Example: xyz@contoso.com or Contoso\xyz.
   */
  adminUser: string;
  /**
   * The total provisioned capacity in Bytes
   */
  provisionedCapacityInBytes: number;
  /**
   * The used capacity in Bytes.
   */
  readonly usedCapacityInBytes?: number;
  /**
   * The local used capacity in Bytes.
   */
  readonly localUsedCapacityInBytes?: number;
  /**
   * The monitoring status
   */
  monitoringStatus: MonitoringStatus;
};

/**
 * The iSCSI disk.
 */
export type IscsiDisk = BaseModel & {
  /**
   * The description.
   */
  description?: string;
  /**
   * The disk status.
   */
  diskStatus: DiskStatus;
  /**
   * The access control records.
   */
  accessControlRecords: string[];
  /**
   * The data policy.
   */
  dataPolicy: DataPolicy;
  /**
   * The provisioned capacity in bytes.
   */
  provisionedCapacityInBytes: number;
  /**
   * The used capacity in bytes.
   */
  readonly usedCapacityInBytes?: number;
  /**
   * The local used capacity in bytes.
   */
  readonly localUsedCapacityInBytes?: number;
  /**
   * The monitoring.
   */
  monitoringStatus: MonitoringStatus;
};

/**
 * The list response of backup schedule groups
 */
export interface BackupScheduleGroupList {
  /**
   * The value.
   */
  value: BackupScheduleGroup[];
}

/**
 * The Backup Schedule Group
 */
export type BackupScheduleGroup = BaseModel & {
  /**
   * The start time. When this field is specified we will generate Default GrandFather Father Son Backup Schedules.
   */
  startTime: Time;
};

/**
 * The Time.
 */
export interface Time {
  /**
   * The hour.
   */
  hour: number;
  /**
   * The minute.
   */
  minute: number;
}

/**
 * Collection of Chap setting entities
 */
export interface ChapSettingsList {
  /**
   * The chap settings entity collection
   */
  value: ChapSettings[];
}

/**
 * Challenge-Handshake Authentication Protocol (CHAP) setting
 */
export type ChapSettings = BaseModel & {
  /**
   * The chap password.
   */
  password: AsymmetricEncryptedSecret;
};

/**
 * This class can be used as the Type for any secret entity represented as Password, CertThumbprint, Algorithm. This class is intended to be used when the secret is encrypted with an asymmetric key pair. The encryptionAlgorithm field is mainly for future usage to potentially allow different entities encrypted using different algorithms.
 */
export interface AsymmetricEncryptedSecret {
  /**
   * The value of the secret itself. If the secret is in plaintext then EncryptionAlgorithm will be none and EncryptionCertThumbprint will be null.
   */
  value: string;
  /**
   * Thumbprint certificate that was used to encrypt "Value"
   */
  encryptionCertificateThumbprint?: string;
  /**
   * Algorithm used to encrypt "Value"
   */
  encryptionAlgorithm: EncryptionAlgorithm;
}

/**
 * Collection of Iscsi disk
 */
export interface IscsiDiskList {
  /**
   * The value.
   */
  value: IscsiDisk[];
}

/**
 * The Failover request object.
 */
export interface FailoverRequest {
  accesspointIds?: string[];
  targetDeviceId?: string;
  skipValidation?: boolean;
  keepSourceDevice?: boolean;
}

/**
 * Collection of file servers
 */
export interface FileServerList {
  /**
   * The value.
   */
  value: FileServer[];
}

/**
 * The file server.
 */
export type FileServer = BaseModel & {
  /**
   * Domain of the file server
   */
  domainName: string;
  /**
   * The storage domain id.
   */
  storageDomainId: string;
  /**
   * The backup policy id.
   */
  backupScheduleGroupId: string;
  /**
   * The description of the file server
   */
  description?: string;
};

/**
 * Collection of metrics
 */
export interface MetricList {
  /**
   * The value.
   */
  value: Metrics[];
}

/**
 * Monitoring metric
 */
export interface Metrics {
  /**
   * The id of metric source
   */
  resourceId: string;
  /**
   * The metric start time
   */
  startTime: Date;
  /**
   * The metric end time
   */
  endTime: Date;
  /**
   * The time grain, time grain indicates frequency of the metric data
   */
  timeGrain: string;
  /**
   * The metric aggregation type
   */
  primaryAggregation: MetricAggregationType;
  /**
   * The name of the metrics
   */
  name: MetricName;
  /**
   * The Metric dimension which indicates the source of the metric
   */
  dimensions: MetricDimension[];
  /**
   * The unit of the metric data
   */
  unit: MetricUnit;
  /**
   * The Type of the metric data
   */
  type: string;
  /**
   * The metric data
   */
  values: MetricData[];
}

/**
 * The name of the metric
 */
export interface MetricName {
  /**
   * Name of the metric
   */
  value: string;
  /**
   * Localized name of the metric
   */
  localizedValue: string;
}

/**
 * Metric dimension
 */
export interface MetricDimension {
  /**
   * Metric dimension name
   */
  name: string;
  /**
   * Metric dimension values
   */
  value: string;
}

/**
 * The metric data.
 */
export interface MetricData {
  /**
   * The time when the metric data is fetched
   */
  timeStamp: Date;
  /**
   * The sum of all the samples available in the given instance of time for the specific metric data
   */
  sum: number;
  /**
   * The count of samples of the metric data available for the given instance
   */
  count: number;
  /**
   * The average of all sample for the given instance
   */
  average: number;
  /**
   * The minimum of all samples available
   */
  minimum: number;
  /**
   * The maximum of all samples available
   */
  maximum: number;
}

/**
 * List of metric definition
 */
export interface MetricDefinitionList {
  /**
   * The list of metric definition
   */
  value: MetricDefinition[];
}

/**
 * Monitoring metric definition represents the metadata of the metrics.
 */
export interface MetricDefinition {
  /**
   * The metric name
   */
  name: MetricName;
  /**
   * The metric unit
   */
  unit: MetricUnit;
  /**
   * The metric aggregation type
   */
  primaryAggregationType: MetricAggregationType;
  /**
   * The metric source id
   */
  resourceId: string;
  /**
   * The available metric granularities
   */
  metricAvailabilities: MetricAvailablity[];
  /**
   * The supported dimensions
   */
  dimensions: MetricDimension[];
  /**
   * The metric definition type
   */
  type: string;
}

/**
 * Metric availability specifies the time grain (aggregation interval or frequency) and the retention period for that time grain
 */
export interface MetricAvailablity {
  /**
   * The time grain, specifies the aggregation interval for the metric.
   */
  timeGrain: string;
  /**
   * The retention period for the metric at the specified timegrain
   */
  retention: string;
}

/**
 * Collection of file shares
 */
export interface FileShareList {
  /**
   * The value.
   */
  value: FileShare[];
}

/**
 * Collection of Iscsi servers
 */
export interface IscsiServerList {
  /**
   * The value.
   */
  value: IscsiServer[];
}

/**
 * The iSCSI server.
 */
export type IscsiServer = BaseModel & {
  /**
   * The storage domain id.
   */
  storageDomainId: string;
  /**
   * The backup policy id.
   */
  backupScheduleGroupId: string;
  /**
   * The description.
   */
  description?: string;
  /**
   * The chap id.
   */
  chapId?: string;
  /**
   * The reverse chap id.
   */
  reverseChapId?: string;
};

/**
 * Collection of jobs
 */
export interface JobList {
  /**
   * The value.
   */
  value: Job[];
  /**
   * The NextLink.
   */
  nextLink?: string;
}

/**
 * The Job.
 */
export type Job = BaseModel & {
  /**
   * Current status of the job
   */
  status: JobStatus;
  /**
   * The UTC time at which the job was started
   */
  startTime?: Date;
  /**
   * The UTC time at which the job completed
   */
  endTime?: Date;
  /**
   * The percentage of the job that is already complete
   */
  percentComplete: number;
  /**
   * The Error details.
   */
  error?: JobErrorDetails;
  /**
   * Type of the job
   */
  jobType?: JobType;
  /**
   * Id of the object that is created by the job
   */
  targetId?: string;
  /**
   * The entity identifier for which the job ran.
   */
  entityId?: string;
  /**
   * The entity type for which the job ran.
   */
  entityType?: string;
  /**
   * The job stages.
   */
  jobStages?: JobStage[];
  /**
   * The device id in which the job is currently running
   */
  deviceId?: string;
  /**
   * Represents whether the job is cancellable or not
   */
  isCancellable?: boolean;
  /**
   * stats properties for the job
   */
  stats?: JobStats;
  /**
   * The target type of the backup.
   */
  targetType?: TargetType;
  /**
   * The source device identifier of the failover job.
   */
  sourceDeviceId?: string;
  /**
   * The time of the backup used for the failover.
   */
  backupPointInTime?: Date;
  /**
   * The download progress.
   */
  downloadProgress?: UpdateDownloadProgress;
  /**
   * The install progress.
   */
  installProgress?: UpdateInstallProgress;
};

/**
 * The job error information containing List of JobErrorItem.
 */
export interface JobErrorDetails {
  /**
   * The error details.
   */
  errorDetails?: JobErrorItem[];
  /**
   * The code intended for programmatic access
   */
  code: string;
  /**
   * The message intended to describe the error in detail
   */
  message: string;
}

/**
 * The job error items.
 */
export interface JobErrorItem {
  /**
   * The recommended actions.
   */
  recommendations?: string[];
  /**
   * The code intended for programmatic access
   */
  code: string;
  /**
   * The message intended to describe the error in detail
   */
  message: string;
}

/**
 * Contains details about the multiple job stages of a job
 */
export interface JobStage {
  /**
   * The message of the job stage.
   */
  message?: string;
  /**
   * The stage status.
   */
  stageStatus: JobStatus;
  /**
   * The details of the stage.
   */
  detail?: string;
  /**
   * The error code of the stage if any.
   */
  errorCode?: string;
}

/**
 * Stats that are available for all jobs in common
 */
export interface JobStats {
  /**
   * Completed work item count.
   */
  completedWorkItemCount?: number;
  /**
   * Total work item count.
   */
  totalWorkItemCount?: number;
  /**
   * The estimated time remaining.
   */
  estimatedTimeRemaining?: number;
}

/**
 * details available during the download
 */
export interface UpdateDownloadProgress {
  /**
   * The download phase.
   */
  downloadPhase?: DownloadPhase;
  /**
   * Percentage of completion.
   */
  percentComplete?: number;
  /**
   * Total bytes to download.
   */
  totalBytesToDownload?: number;
  /**
   * Total bytes downloaded.
   */
  totalBytesDownloaded?: number;
  /**
   * Number of updates to download.
   */
  numberOfUpdatesToDownload?: number;
  /**
   * Number of updates downloaded.
   */
  numberOfUpdatesDownloaded?: number;
}

/**
 * Class representing the progress during installation of updates
 */
export interface UpdateInstallProgress {
  /**
   * Percentage of completion.
   */
  percentComplete?: number;
  /**
   * Number of updates to install.
   */
  numberOfUpdatesToInstall?: number;
  /**
   * Number of updates installed.
   */
  numberOfUpdatesInstalled?: number;
}

/**
 * The NetworkSettings of a device
 */
export type NetworkSettings = BaseModel & {
  /**
   * The Primary DNS server for the device
   */
  primaryDnsServer: string;
  /**
   * The secondary DNS server for the device
   */
  secondaryDnsServer?: string;
  /**
   * The NetworkAdapters under each node of the device.
   */
  nodeNetworks: NodeNetwork[];
};

/**
 * Represents a single node in a device.
 */
export interface NodeNetwork {
  /**
   * The array of network adapters in the node.
   */
  networkAdapters: NetworkAdapter[];
}

/**
 * Represents a networkAdapter in a particular node.
 */
export interface NetworkAdapter {
  /**
   * The name of the network adapter.
   */
  networkAdapterName: string;
  /**
   * The ipv4 configuration of the network adapter.
   */
  iPv4Info?: IPConfig;
  /**
   * The ipv6 configuration of the network adapter.
   */
  iPv6Info?: IPConfig;
  /**
   * Represents state of DHCP.
   */
  dhcpStatus: DhcpStatus;
  /**
   * The speed of the network adapter.
   */
  linkSpeed?: number;
}

/**
 * Details related to the IP address configuration
 */
export interface IPConfig {
  /**
   * The IP address of the network adapter, either ipv4 or ipv6.
   */
  ipAddress: string;
  /**
   * The prefix length of the network adapter.
   */
  prefixLength?: number;
  /**
   * The gateway of the network adapter.
   */
  gateway: string;
}

/**
 * The SecuritySettings of a device
 */
export type SecuritySettings = BaseModel & {
  /**
   * Device administrator password as an encrypted string (encrypted using RSA PKCS #1) is used to log into the  local web UI of the device. Actual password could have at least 8 characters that are a combination of  uppercase, lowercase, numeric, and special characters
   */
  deviceAdminPassword: AsymmetricEncryptedSecret;
};

/**
 * Request for sending test alert email
 */
export interface SendTestAlertEmailRequest {
  /**
   * List of emails to send the test alerts
   */
  emailList: string[];
}

/**
 * The TimeSettings of a device
 */
export type TimeSettings = BaseModel & {
  /**
   * The timezone of device, like '(UTC -06:00) Central America'
   */
  timeZone: string;
  /**
   * The primary Network Time Protocol (NTP) server name, like 'time.windows.com'.
   */
  primaryTimeServer: string;
  /**
   * The secondary Network Time Protocol (NTP) server name, like 'time.contoso.com'. It's optional.
   */
  secondaryTimeServer?: string;
};

/**
 * The updates profile
 */
export type Updates = BaseModel & {
  /**
   * The current Device version.
   */
  deviceVersion?: string;
  /**
   * The last time when the device did an update scan.
   */
  deviceLastScannedTime?: Date;
  /**
   * Set to true if regular updates were detected for the current version of the device.
   */
  regularUpdatesAvailable?: boolean;
  /**
   * Set to true if RegularUpdatesAvailable is true and if at least one of the updateItems detected has needs a reboot to install.
   */
  rebootRequiredForInstall?: boolean;
  /**
   * The total number of items pending for download.
   */
  totalItemsPendingForDownload?: number;
  /**
   * The total number of items pending for install.
   */
  totalItemsPendingForInstall?: number;
  /**
   * The current update operation.
   */
  status?: UpdateOperation;
  /**
   * The time when the last scan job was completed (success|cancelled|failed) on the device.
   */
  lastCompletedScanTime?: Date;
  /**
   * The time when the last Download job was completed (success|cancelled|failed) on the device.
   */
  lastCompletedDownloadJobTime?: Date;
  /**
   * The time when the last Install job was completed (success|cancelled|failed) on the device.
   */
  lastCompletedInstallJobTime?: Date;
  /**
   * If a download is in progress, this field contains the JobId of that particular download job
   */
  inProgressDownloadJobId?: string;
  /**
   * If an install is in progress, this field contains the JobId of that particular install job
   */
  inProgressInstallJobId?: string;
  /**
   * The time when the currently running scan (if any) started
   */
  inProgressScanStartedTime?: Date;
  /**
   * The time when the currently running download (if any) started
   */
  inProgressDownloadJobStartedTime?: Date;
  /**
   * The time when the currently running install (if any) started
   */
  inProgressInstallJobStartedTime?: Date;
};

/**
 * The EncryptionSettings
 */
export type EncryptionSettings = BaseModel & {
  /**
   * The encryption status which indicates if encryption is enabled or not.
   */
  encryptionStatus: EncryptionStatus;
  /**
   * The key rollover status which indicates if key rollover is required or not. If secrets encryption has been upgraded, then it requires key rollover.
   */
  keyRolloverStatus: KeyRolloverStatus;
};

/**
 * The extended info of the manager.
 */
export type ManagerExtendedInfo = BaseModel & {
  /**
   * ETag of the Resource
   */
  etag?: string;
  /**
   * Represents the version of the ExtendedInfo object being persisted
   */
  version?: string;
  /**
   * Represents the CIK of the resource
   */
  integrityKey: string;
  /**
   * Represents the CEK of the resource
   */
  encryptionKey?: string;
  /**
   * Represents the Cert thumbprint that was used to encrypt the CEK
   */
  encryptionKeyThumbprint?: string;
  /**
   * Represents the portal thumbprint which can be used optionally to encrypt the entire data before storing it.
   */
  portalCertificateThumbprint?: string;
  /**
   * Represents the encryption algorithm used to encrypt the other keys. None - if EncryptionKey is saved in plain text format. AlgorithmName - if encryption is used
   */
  algorithm: string;
};

/**
 * This class can be used as the Type for any secret entity represented as Value, ValueCertificateThumbprint, EncryptionAlgorithm. In this case, "Value" is a secret and the "valueThumbprint" represents the certificate thumbprint of the value. The algorithm field is mainly for future usage to potentially allow different entities encrypted using different algorithms.
 */
export interface SymmetricEncryptedSecret {
  /**
   * The value of the secret itself. If the secret is in plaintext or null then EncryptionAlgorithm will be none
   */
  value: string;
  /**
   * Thumbprint cert that was used to encrypt "Value"
   */
  valueCertificateThumbprint?: string;
  /**
   * Algorithm used to encrypt "Value"
   */
  encryptionAlgorithm: EncryptionAlgorithm;
}

/**
 * Collection of Storage account credential entities
 */
export interface StorageAccountCredentialList {
  /**
   * The value.
   */
  value: StorageAccountCredential[];
}

/**
 * The storage account credential
 */
export type StorageAccountCredential = BaseModel & {
  /**
   * The cloud service provider
   */
  cloudType: CloudType;
  /**
   * The storage endpoint
   */
  endPoint: string;
  /**
   * The storage account login
   */
  login: string;
  /**
   * The storage account's geo location
   */
  location?: string;
  /**
   * SSL needs to be enabled or not
   */
  enableSSL: SslStatus;
  /**
   * The details of the storage account password
   */
  accessKey?: AsymmetricEncryptedSecret;
};

/**
 * Collection of storage domains
 */
export interface StorageDomainList {
  /**
   * The value.
   */
  value: StorageDomain[];
}

/**
 * The storage domain.
 */
export type StorageDomain = BaseModel & {
  /**
   * The storage account credentials.
   */
  storageAccountCredentialIds: string[];
  /**
   * The encryption key used to encrypt the data. This is a user secret.
   */
  encryptionKey?: AsymmetricEncryptedSecret;
  /**
   * The encryption status "Enabled | Disabled".
   */
  encryptionStatus: EncryptionStatus;
};

/**
 * Filters that can be specified on the alert
 */
export interface AlertFilter {
  /**
   * Status of the alert
   */
  status?: AlertStatus;
  /**
   * Severity of the alert
   */
  severity?: AlertSeverity;
  /**
   * Source of the alert
   */
  sourceType?: AlertSourceType;
  /**
   * Source name of the alert
   */
  sourceName?: string;
  /**
   * UTC time on which the alert appeared
   */
  appearedOnTime?: Date;
}

/**
 * Backup OData filter class
 */
export interface BackupFilter {
  /**
   * Gets or sets InitiatedBy
   */
  initiatedBy?: InitiatedBy;
  /**
   * Gets or sets CreatedTime
   */
  createdTime?: Date;
}

/**
 * Filters that can be specified for the job
 */
export interface JobFilter {
  /**
   * The job type.
   */
  jobType: JobType;
  /**
   * The job status.
   */
  status: JobStatus;
  /**
   * The start time of the job.
   */
  startTime?: Date;
}

/**
 * class representing the filters to be passed while fetching metrics
 */
export interface MetricFilter {
  /**
   * filter for name property
   */
  name?: MetricNameFilter;
  /**
   * starttime for fetching metrics
   */
  startTime?: Date;
  /**
   * endtime for fetching metrics
   */
  endTime?: Date;
  /**
   * timegrain of the metrics
   */
  timeGrain?: string;
}

/**
 * Class representing the name filter to be passed while fetching metrics
 */
export interface MetricNameFilter {
  /**
   * The value.
   */
  value?: string;
}

/**
 * Defines values for ManagerType.
 */
export type ManagerType = "GardaV1" | "HelsinkiV1";
/**
 * Defines values for AlertScope.
 */
export type AlertScope = "Resource" | "Device";
/**
 * Defines values for AlertSourceType.
 */
export type AlertSourceType = "Resource" | "Device";
/**
 * Defines values for AlertSeverity.
 */
export type AlertSeverity = "Informational" | "Warning" | "Critical";
/**
 * Defines values for AlertStatus.
 */
export type AlertStatus = "Active" | "Cleared";
/**
 * Defines values for InitiatedBy.
 */
export type InitiatedBy = "Manual" | "Scheduled";
/**
 * Defines values for DataPolicy.
 */
export type DataPolicy = "Invalid" | "Local" | "Tiered" | "Cloud";
/**
 * Defines values for AuthType.
 */
export type AuthType =
  | "Invalid"
  | "AccessControlService"
  | "AzureActiveDirectory";
/**
 * Defines values for ContractVersions.
 */
export type ContractVersions =
  | "InvalidVersion"
  | "V2011_09"
  | "V2012_02"
  | "V2012_05"
  | "V2012_12"
  | "V2013_04"
  | "V2013_10"
  | "V2013_11"
  | "V2014_04"
  | "V2014_06"
  | "V2014_07"
  | "V2014_09"
  | "V2014_10"
  | "V2014_12"
  | "V2015_01"
  | "V2015_02"
  | "V2015_04"
  | "V2015_05"
  | "V2015_06"
  | "V2015_07"
  | "V2015_08"
  | "V2015_10"
  | "V2015_12"
  | "V2016_01"
  | "V2016_02"
  | "V2016_04"
  | "V2016_05"
  | "V2016_07"
  | "V2016_08";
/**
 * Defines values for DeviceOperation.
 */
export type DeviceOperation =
  | "None"
  | "Delete"
  | "DeleteWithWarning"
  | "DRSource"
  | "DRTarget"
  | "Browsable"
  | "ReadOnlyForDR"
  | "Deactivate";
/**
 * Defines values for SupportedDeviceCapabilities.
 */
export type SupportedDeviceCapabilities =
  | "Invalid"
  | "FileServer"
  | "IscsiServer";
/**
 * Defines values for DeviceConfigurationStatus.
 */
export type DeviceConfigurationStatus = "Complete" | "Pending";
/**
 * Defines values for DeviceStatus.
 */
export type DeviceStatus =
  | "Unknown"
  | "Online"
  | "Offline"
  | "RequiresAttention"
  | "MaintenanceMode"
  | "Creating"
  | "Provisioning"
  | "Deleted"
  | "ReadyToSetup"
  | "Deactivated"
  | "Deactivating";
/**
 * Defines values for DeviceType.
 */
export type DeviceType =
  | "Invalid"
  | "Appliance"
  | "VirtualAppliance"
  | "Series9000OnPremVirtualAppliance"
  | "Series9000VirtualAppliance"
  | "Series9000PhysicalAppliance";
/**
 * Defines values for AlertEmailNotificationStatus.
 */
export type AlertEmailNotificationStatus = "Enabled" | "Disabled";
/**
 * Defines values for ServiceOwnersAlertNotificationStatus.
 */
export type ServiceOwnersAlertNotificationStatus = "Enabled" | "Disabled";
/**
 * Defines values for ShareStatus.
 */
export type ShareStatus = "Online" | "Offline";
/**
 * Defines values for MonitoringStatus.
 */
export type MonitoringStatus = "Enabled" | "Disabled";
/**
 * Defines values for DiskStatus.
 */
export type DiskStatus = "Online" | "Offline";
/**
 * Defines values for EncryptionAlgorithm.
 */
export type EncryptionAlgorithm = "None" | "AES256" | "RSAES_PKCS1_v_1_5";
/**
 * Defines values for MetricAggregationType.
 */
export type MetricAggregationType =
  | "Average"
  | "Last"
  | "Maximum"
  | "Minimum"
  | "None"
  | "Total";
/**
 * Defines values for MetricUnit.
 */
export type MetricUnit =
  | "Bytes"
  | "BytesPerSecond"
  | "Count"
  | "CountPerSecond"
  | "Percent"
  | "Seconds";
/**
 * Defines values for JobStatus.
 */
export type JobStatus =
  | "Invalid"
  | "Running"
  | "Succeeded"
  | "Failed"
  | "Canceled"
  | "Paused"
  | "Scheduled";
/**
 * Defines values for JobType.
 */
export type JobType =
  | "Backup"
  | "Clone"
  | "Failover"
  | "DownloadUpdates"
  | "InstallUpdates";
/**
 * Defines values for TargetType.
 */
export type TargetType = "FileServer" | "DiskServer";
/**
 * Defines values for DownloadPhase.
 */
export type DownloadPhase =
  | "Unknown"
  | "Initializing"
  | "Downloading"
  | "Verifying";
/**
 * Defines values for DhcpStatus.
 */
export type DhcpStatus = "Enabled" | "Disabled";
/**
 * Defines values for UpdateOperation.
 */
export type UpdateOperation =
  | "Idle"
  | "Scanning"
  | "Downloading"
  | "Installing";
/**
 * Defines values for EncryptionStatus.
 */
export type EncryptionStatus = "Enabled" | "Disabled";
/**
 * Defines values for KeyRolloverStatus.
 */
export type KeyRolloverStatus = "Required" | "NotRequired";
/**
 * Defines values for CloudType.
 */
export type CloudType = "Azure" | "S3" | "S3_RRS" | "OpenStack" | "HP";
/**
 * Defines values for SslStatus.
 */
export type SslStatus = "Enabled" | "Disabled";

/**
 * Contains response data for the list operation.
 */
export type ManagersListResponse = ManagerList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: ManagerList;
  };
};

/**
 * Contains response data for the listByResourceGroup operation.
 */
export type ManagersListByResourceGroupResponse = ManagerList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: ManagerList;
  };
};

/**
 * Contains response data for the get operation.
 */
export type ManagersGetResponse = Manager & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: Manager;
  };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type ManagersCreateOrUpdateResponse = Manager & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: Manager;
  };
};

/**
 * Contains response data for the update operation.
 */
export type ManagersUpdateResponse = Manager & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: Manager;
  };
};

/**
 * Contains response data for the uploadRegistrationCertificate operation.
 */
export type ManagersUploadRegistrationCertificateResponse = UploadCertificateResponse & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: UploadCertificateResponse;
  };
};

/**
 * Contains response data for the getEncryptionSettings operation.
 */
export type ManagersGetEncryptionSettingsResponse = EncryptionSettings & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: EncryptionSettings;
  };
};

/**
 * Contains response data for the getExtendedInfo operation.
 */
export type ManagersGetExtendedInfoResponse = ManagerExtendedInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: ManagerExtendedInfo;
  };
};

/**
 * Contains response data for the createExtendedInfo operation.
 */
export type ManagersCreateExtendedInfoResponse = ManagerExtendedInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: ManagerExtendedInfo;
  };
};

/**
 * Contains response data for the updateExtendedInfo operation.
 */
export type ManagersUpdateExtendedInfoResponse = ManagerExtendedInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: ManagerExtendedInfo;
  };
};

/**
 * Contains response data for the getEncryptionKey operation.
 */
export type ManagersGetEncryptionKeyResponse = SymmetricEncryptedSecret & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: SymmetricEncryptedSecret;
  };
};

/**
 * Optional parameters.
 */
export interface ManagersListMetricsOptionalParams
  extends coreHttp.OperationOptions {
  /**
   * OData Filter options
   */
  filter?: string;
}

/**
 * Contains response data for the listMetrics operation.
 */
export type ManagersListMetricsResponse = MetricList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: MetricList;
  };
};

/**
 * Contains response data for the listMetricDefinition operation.
 */
export type ManagersListMetricDefinitionResponse = MetricDefinitionList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: MetricDefinitionList;
  };
};

/**
 * Contains response data for the list operation.
 */
export type AvailableProviderOperationsListResponse = AvailableProviderOperations & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: AvailableProviderOperations;
  };
};

/**
 * Contains response data for the listNext operation.
 */
export type AvailableProviderOperationsListNextResponse = AvailableProviderOperations & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: AvailableProviderOperations;
  };
};

/**
 * Contains response data for the listByManager operation.
 */
export type AccessControlRecordsListByManagerResponse = AccessControlRecordList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: AccessControlRecordList;
  };
};

/**
 * Contains response data for the get operation.
 */
export type AccessControlRecordsGetResponse = AccessControlRecord & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: AccessControlRecord;
  };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type AccessControlRecordsCreateOrUpdateResponse = AccessControlRecord & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: AccessControlRecord;
  };
};

/**
 * Optional parameters.
 */
export interface AlertsListByManagerOptionalParams
  extends coreHttp.OperationOptions {
  /**
   * OData Filter options
   */
  filter?: string;
}

/**
 * Contains response data for the listByManager operation.
 */
export type AlertsListByManagerResponse = AlertList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: AlertList;
  };
};

/**
 * Optional parameters.
 */
export interface AlertsListByManagerNextOptionalParams
  extends coreHttp.OperationOptions {
  /**
   * OData Filter options
   */
  filter?: string;
}

/**
 * Contains response data for the listByManagerNext operation.
 */
export type AlertsListByManagerNextResponse = AlertList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: AlertList;
  };
};

/**
 * Optional parameters.
 */
export interface BackupsListByManagerOptionalParams
  extends coreHttp.OperationOptions {
  /**
   * OData Filter options
   */
  filter?: string;
}

/**
 * Contains response data for the listByManager operation.
 */
export type BackupsListByManagerResponse = BackupList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: BackupList;
  };
};

/**
 * Optional parameters.
 */
export interface BackupsListByDeviceOptionalParams
  extends coreHttp.OperationOptions {
  /**
   * OData Filter options
   */
  filter?: string;
  /**
   * Set to true if you need backups which can be used for failover.
   */
  forFailover?: boolean;
}

/**
 * Contains response data for the listByDevice operation.
 */
export type BackupsListByDeviceResponse = BackupList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: BackupList;
  };
};

/**
 * Optional parameters.
 */
export interface BackupsListByManagerNextOptionalParams
  extends coreHttp.OperationOptions {
  /**
   * OData Filter options
   */
  filter?: string;
}

/**
 * Contains response data for the listByManagerNext operation.
 */
export type BackupsListByManagerNextResponse = BackupList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: BackupList;
  };
};

/**
 * Optional parameters.
 */
export interface BackupsListByDeviceNextOptionalParams
  extends coreHttp.OperationOptions {
  /**
   * OData Filter options
   */
  filter?: string;
  /**
   * Set to true if you need backups which can be used for failover.
   */
  forFailover?: boolean;
}

/**
 * Contains response data for the listByDeviceNext operation.
 */
export type BackupsListByDeviceNextResponse = BackupList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: BackupList;
  };
};

/**
 * Optional parameters.
 */
export interface DevicesListByManagerOptionalParams
  extends coreHttp.OperationOptions {
  /**
   * Specify $expand=details to populate additional fields related to the device.
   */
  expand?: string;
}

/**
 * Contains response data for the listByManager operation.
 */
export type DevicesListByManagerResponse = DeviceList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: DeviceList;
  };
};

/**
 * Optional parameters.
 */
export interface DevicesGetOptionalParams extends coreHttp.OperationOptions {
  /**
   * Specify $expand=details to populate additional fields related to the device.
   */
  expand?: string;
}

/**
 * Contains response data for the get operation.
 */
export type DevicesGetResponse = Device & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: Device;
  };
};

/**
 * Contains response data for the patch operation.
 */
export type DevicesPatchResponse = Device & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: Device;
  };
};

/**
 * Contains response data for the getAlertSettings operation.
 */
export type DevicesGetAlertSettingsResponse = AlertSettings & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: AlertSettings;
  };
};

/**
 * Contains response data for the createOrUpdateAlertSettings operation.
 */
export type DevicesCreateOrUpdateAlertSettingsResponse = AlertSettings & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: AlertSettings;
  };
};

/**
 * Optional parameters.
 */
export interface DevicesListFailoverTargetOptionalParams
  extends coreHttp.OperationOptions {
  /**
   * Specify $expand=details to populate additional fields related to the device.
   */
  expand?: string;
}

/**
 * Contains response data for the listFailoverTarget operation.
 */
export type DevicesListFailoverTargetResponse = DeviceList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: DeviceList;
  };
};

/**
 * Optional parameters.
 */
export interface DevicesListMetricsOptionalParams
  extends coreHttp.OperationOptions {
  /**
   * OData Filter options
   */
  filter?: string;
}

/**
 * Contains response data for the listMetrics operation.
 */
export type DevicesListMetricsResponse = MetricList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: MetricList;
  };
};

/**
 * Contains response data for the listMetricDefinition operation.
 */
export type DevicesListMetricDefinitionResponse = MetricDefinitionList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: MetricDefinitionList;
  };
};

/**
 * Contains response data for the getNetworkSettings operation.
 */
export type DevicesGetNetworkSettingsResponse = NetworkSettings & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: NetworkSettings;
  };
};

/**
 * Contains response data for the getTimeSettings operation.
 */
export type DevicesGetTimeSettingsResponse = TimeSettings & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: TimeSettings;
  };
};

/**
 * Contains response data for the getUpdateSummary operation.
 */
export type DevicesGetUpdateSummaryResponse = Updates & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: Updates;
  };
};

/**
 * Contains response data for the listByDevice operation.
 */
export type BackupScheduleGroupsListByDeviceResponse = BackupScheduleGroupList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: BackupScheduleGroupList;
  };
};

/**
 * Contains response data for the get operation.
 */
export type BackupScheduleGroupsGetResponse = BackupScheduleGroup & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: BackupScheduleGroup;
  };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type BackupScheduleGroupsCreateOrUpdateResponse = BackupScheduleGroup & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: BackupScheduleGroup;
  };
};

/**
 * Contains response data for the listByDevice operation.
 */
export type ChapSettingsListByDeviceResponse = ChapSettingsList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: ChapSettingsList;
  };
};

/**
 * Contains response data for the get operation.
 */
export type ChapSettingsGetResponse = ChapSettings & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: ChapSettings;
  };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type ChapSettingsCreateOrUpdateResponse = ChapSettings & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: ChapSettings;
  };
};

/**
 * Contains response data for the listByDevice operation.
 */
export type IscsiDisksListByDeviceResponse = IscsiDiskList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: IscsiDiskList;
  };
};

/**
 * Contains response data for the listByIscsiServer operation.
 */
export type IscsiDisksListByIscsiServerResponse = IscsiDiskList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: IscsiDiskList;
  };
};

/**
 * Contains response data for the get operation.
 */
export type IscsiDisksGetResponse = IscsiDisk & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: IscsiDisk;
  };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type IscsiDisksCreateOrUpdateResponse = IscsiDisk & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: IscsiDisk;
  };
};

/**
 * Optional parameters.
 */
export interface IscsiDisksListMetricsOptionalParams
  extends coreHttp.OperationOptions {
  /**
   * OData Filter options
   */
  filter?: string;
}

/**
 * Contains response data for the listMetrics operation.
 */
export type IscsiDisksListMetricsResponse = MetricList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: MetricList;
  };
};

/**
 * Contains response data for the listMetricDefinition operation.
 */
export type IscsiDisksListMetricDefinitionResponse = MetricDefinitionList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: MetricDefinitionList;
  };
};

/**
 * Contains response data for the listByDevice operation.
 */
export type FileServersListByDeviceResponse = FileServerList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: FileServerList;
  };
};

/**
 * Contains response data for the get operation.
 */
export type FileServersGetResponse = FileServer & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: FileServer;
  };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type FileServersCreateOrUpdateResponse = FileServer & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: FileServer;
  };
};

/**
 * Optional parameters.
 */
export interface FileServersListMetricsOptionalParams
  extends coreHttp.OperationOptions {
  /**
   * OData Filter options
   */
  filter?: string;
}

/**
 * Contains response data for the listMetrics operation.
 */
export type FileServersListMetricsResponse = MetricList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: MetricList;
  };
};

/**
 * Contains response data for the listMetricDefinition operation.
 */
export type FileServersListMetricDefinitionResponse = MetricDefinitionList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: MetricDefinitionList;
  };
};

/**
 * Contains response data for the listByManager operation.
 */
export type FileServersListByManagerResponse = FileServerList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: FileServerList;
  };
};

/**
 * Contains response data for the listByFileServer operation.
 */
export type FileSharesListByFileServerResponse = FileShareList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: FileShareList;
  };
};

/**
 * Contains response data for the get operation.
 */
export type FileSharesGetResponse = FileShare & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: FileShare;
  };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type FileSharesCreateOrUpdateResponse = FileShare & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: FileShare;
  };
};

/**
 * Optional parameters.
 */
export interface FileSharesListMetricsOptionalParams
  extends coreHttp.OperationOptions {
  /**
   * OData Filter options
   */
  filter?: string;
}

/**
 * Contains response data for the listMetrics operation.
 */
export type FileSharesListMetricsResponse = MetricList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: MetricList;
  };
};

/**
 * Contains response data for the listMetricDefinition operation.
 */
export type FileSharesListMetricDefinitionResponse = MetricDefinitionList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: MetricDefinitionList;
  };
};

/**
 * Contains response data for the listByDevice operation.
 */
export type FileSharesListByDeviceResponse = FileShareList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: FileShareList;
  };
};

/**
 * Contains response data for the listByDevice operation.
 */
export type IscsiServersListByDeviceResponse = IscsiServerList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: IscsiServerList;
  };
};

/**
 * Contains response data for the get operation.
 */
export type IscsiServersGetResponse = IscsiServer & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: IscsiServer;
  };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type IscsiServersCreateOrUpdateResponse = IscsiServer & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: IscsiServer;
  };
};

/**
 * Optional parameters.
 */
export interface IscsiServersListMetricsOptionalParams
  extends coreHttp.OperationOptions {
  /**
   * OData Filter options
   */
  filter?: string;
}

/**
 * Contains response data for the listMetrics operation.
 */
export type IscsiServersListMetricsResponse = MetricList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: MetricList;
  };
};

/**
 * Contains response data for the listMetricDefinition operation.
 */
export type IscsiServersListMetricDefinitionResponse = MetricDefinitionList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: MetricDefinitionList;
  };
};

/**
 * Contains response data for the listByManager operation.
 */
export type IscsiServersListByManagerResponse = IscsiServerList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: IscsiServerList;
  };
};

/**
 * Optional parameters.
 */
export interface JobsListByDeviceOptionalParams
  extends coreHttp.OperationOptions {
  /**
   * OData Filter options
   */
  filter?: string;
}

/**
 * Contains response data for the listByDevice operation.
 */
export type JobsListByDeviceResponse = JobList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: JobList;
  };
};

/**
 * Contains response data for the get operation.
 */
export type JobsGetResponse = Job & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: Job;
  };
};

/**
 * Optional parameters.
 */
export interface JobsListByManagerOptionalParams
  extends coreHttp.OperationOptions {
  /**
   * OData Filter options
   */
  filter?: string;
}

/**
 * Contains response data for the listByManager operation.
 */
export type JobsListByManagerResponse = JobList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: JobList;
  };
};

/**
 * Optional parameters.
 */
export interface JobsListByDeviceNextOptionalParams
  extends coreHttp.OperationOptions {
  /**
   * OData Filter options
   */
  filter?: string;
}

/**
 * Contains response data for the listByDeviceNext operation.
 */
export type JobsListByDeviceNextResponse = JobList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: JobList;
  };
};

/**
 * Optional parameters.
 */
export interface JobsListByManagerNextOptionalParams
  extends coreHttp.OperationOptions {
  /**
   * OData Filter options
   */
  filter?: string;
}

/**
 * Contains response data for the listByManagerNext operation.
 */
export type JobsListByManagerNextResponse = JobList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: JobList;
  };
};

/**
 * Contains response data for the listByManager operation.
 */
export type StorageAccountCredentialsListByManagerResponse = StorageAccountCredentialList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: StorageAccountCredentialList;
  };
};

/**
 * Contains response data for the get operation.
 */
export type StorageAccountCredentialsGetResponse = StorageAccountCredential & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: StorageAccountCredential;
  };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type StorageAccountCredentialsCreateOrUpdateResponse = StorageAccountCredential & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: StorageAccountCredential;
  };
};

/**
 * Contains response data for the listByManager operation.
 */
export type StorageDomainsListByManagerResponse = StorageDomainList & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: StorageDomainList;
  };
};

/**
 * Contains response data for the get operation.
 */
export type StorageDomainsGetResponse = StorageDomain & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: StorageDomain;
  };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type StorageDomainsCreateOrUpdateResponse = StorageDomain & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: StorageDomain;
  };
};

/**
 * Optional parameters.
 */
export interface StorSimpleManagementClientOptionalParams
  extends coreHttp.ServiceClientOptions {
  /**
   * server parameter
   */
  $host?: string;
  /**
   * Api Version
   */
  apiVersion?: string;
  /**
   * Overrides client endpoint.
   */
  endpoint?: string;
}
