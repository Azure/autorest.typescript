## API Report File for "storage-resource-manager"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as coreHttp from '@azure/core-http';
import { HttpMethods } from '@azure/core-http';
import { HttpOperationResponse } from '@azure/core-http';
import { OperationArguments } from '@azure/core-http';
import { OperationSpec } from '@azure/core-http';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { PollerLike } from '@azure/core-lro';
import { PollOperationState } from '@azure/core-lro';
import { RestResponse } from '@azure/core-http';

// @public
export type AccessTier = "Hot" | "Cool";

// @public
export interface AccountSasParameters {
    iPAddressOrRange?: string;
    keyToSign?: string;
    permissions: Permissions_2;
    protocols?: HttpProtocol;
    resourceTypes: SignedResourceTypes;
    services: Services;
    sharedAccessExpiryTime: Date;
    sharedAccessStartTime?: Date;
}

// @public
export type AccountStatus = "available" | "unavailable";

// @public
export interface ActiveDirectoryProperties {
    azureStorageSid: string;
    domainGuid: string;
    domainName: string;
    domainSid: string;
    forestName: string;
    netBiosDomainName: string;
}

// @public
export type AzureEntityResource = Resource & {
    readonly etag?: string;
};

// @public
export interface AzureFilesIdentityBasedAuthentication {
    activeDirectoryProperties?: ActiveDirectoryProperties;
    directoryServiceOptions: DirectoryServiceOptions;
}

// @public
export type BlobContainer = AzureEntityResource & {
    defaultEncryptionScope?: string;
    denyEncryptionScopeOverride?: boolean;
    publicAccess?: PublicAccess;
    readonly lastModifiedTime?: Date;
    readonly leaseStatus?: LeaseStatus;
    readonly leaseState?: LeaseState;
    readonly leaseDuration?: LeaseDuration;
    metadata?: {
        [propertyName: string]: string;
    };
    readonly immutabilityPolicy?: ImmutabilityPolicyProperties;
    readonly legalHold?: LegalHoldProperties;
    readonly hasLegalHold?: boolean;
    readonly hasImmutabilityPolicy?: boolean;
};

// @public
export interface BlobContainers {
    clearLegalHold(resourceGroupName: string, accountName: string, containerName: string, legalHold: LegalHold, options?: coreHttp.OperationOptions): Promise<BlobContainersClearLegalHoldResponse>;
    create(resourceGroupName: string, accountName: string, containerName: string, blobContainer: BlobContainer, options?: coreHttp.OperationOptions): Promise<BlobContainersCreateResponse>;
    createOrUpdateImmutabilityPolicy(resourceGroupName: string, accountName: string, containerName: string, options?: BlobContainersCreateOrUpdateImmutabilityPolicyOptionalParams): Promise<BlobContainersCreateOrUpdateImmutabilityPolicyResponse>;
    delete(resourceGroupName: string, accountName: string, containerName: string, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    deleteImmutabilityPolicy(resourceGroupName: string, accountName: string, containerName: string, ifMatch: string, options?: coreHttp.OperationOptions): Promise<BlobContainersDeleteImmutabilityPolicyResponse>;
    extendImmutabilityPolicy(resourceGroupName: string, accountName: string, containerName: string, ifMatch: string, options?: BlobContainersExtendImmutabilityPolicyOptionalParams): Promise<BlobContainersExtendImmutabilityPolicyResponse>;
    get(resourceGroupName: string, accountName: string, containerName: string, options?: coreHttp.OperationOptions): Promise<BlobContainersGetResponse>;
    getImmutabilityPolicy(resourceGroupName: string, accountName: string, containerName: string, options?: BlobContainersGetImmutabilityPolicyOptionalParams): Promise<BlobContainersGetImmutabilityPolicyResponse>;
    lease(resourceGroupName: string, accountName: string, containerName: string, options?: BlobContainersLeaseOptionalParams): Promise<BlobContainersLeaseResponse>;
    list(resourceGroupName: string, accountName: string, options?: BlobContainersListOptionalParams): PagedAsyncIterableIterator<ListContainerItem>;
    lockImmutabilityPolicy(resourceGroupName: string, accountName: string, containerName: string, ifMatch: string, options?: coreHttp.OperationOptions): Promise<BlobContainersLockImmutabilityPolicyResponse>;
    setLegalHold(resourceGroupName: string, accountName: string, containerName: string, legalHold: LegalHold, options?: coreHttp.OperationOptions): Promise<BlobContainersSetLegalHoldResponse>;
    update(resourceGroupName: string, accountName: string, containerName: string, blobContainer: BlobContainer, options?: coreHttp.OperationOptions): Promise<BlobContainersUpdateResponse>;
}

// @public
export type BlobContainersClearLegalHoldResponse = LegalHold & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: LegalHold;
    };
};

// @public
export interface BlobContainersCreateOrUpdateImmutabilityPolicyHeaders {
    eTag?: string;
}

// @public
export interface BlobContainersCreateOrUpdateImmutabilityPolicyOptionalParams extends coreHttp.OperationOptions {
    ifMatch?: string;
    parameters?: ImmutabilityPolicy;
}

// @public
export type BlobContainersCreateOrUpdateImmutabilityPolicyResponse = BlobContainersCreateOrUpdateImmutabilityPolicyHeaders & ImmutabilityPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ImmutabilityPolicy;
        parsedHeaders: BlobContainersCreateOrUpdateImmutabilityPolicyHeaders;
    };
};

// @public
export type BlobContainersCreateResponse = BlobContainer & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: BlobContainer;
    };
};

// @public
export interface BlobContainersDeleteImmutabilityPolicyHeaders {
    eTag?: string;
}

// @public
export type BlobContainersDeleteImmutabilityPolicyResponse = BlobContainersDeleteImmutabilityPolicyHeaders & ImmutabilityPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ImmutabilityPolicy;
        parsedHeaders: BlobContainersDeleteImmutabilityPolicyHeaders;
    };
};

// @public
export interface BlobContainersExtendImmutabilityPolicyHeaders {
    eTag?: string;
}

// @public
export interface BlobContainersExtendImmutabilityPolicyOptionalParams extends coreHttp.OperationOptions {
    parameters?: ImmutabilityPolicy;
}

// @public
export type BlobContainersExtendImmutabilityPolicyResponse = BlobContainersExtendImmutabilityPolicyHeaders & ImmutabilityPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ImmutabilityPolicy;
        parsedHeaders: BlobContainersExtendImmutabilityPolicyHeaders;
    };
};

// @public
export interface BlobContainersGetImmutabilityPolicyHeaders {
    eTag?: string;
}

// @public
export interface BlobContainersGetImmutabilityPolicyOptionalParams extends coreHttp.OperationOptions {
    ifMatch?: string;
}

// @public
export type BlobContainersGetImmutabilityPolicyResponse = BlobContainersGetImmutabilityPolicyHeaders & ImmutabilityPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ImmutabilityPolicy;
        parsedHeaders: BlobContainersGetImmutabilityPolicyHeaders;
    };
};

// @public
export type BlobContainersGetResponse = BlobContainer & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: BlobContainer;
    };
};

// @public
export interface BlobContainersLeaseOptionalParams extends coreHttp.OperationOptions {
    parameters?: LeaseContainerRequest;
}

// @public
export type BlobContainersLeaseResponse = LeaseContainerResponse & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: LeaseContainerResponse;
    };
};

// @public
export interface BlobContainersListNextOptionalParams extends coreHttp.OperationOptions {
    filter?: string;
    maxpagesize?: string;
}

// @public
export type BlobContainersListNextResponse = ListContainerItems & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ListContainerItems;
    };
};

// @public
export interface BlobContainersListOptionalParams extends coreHttp.OperationOptions {
    filter?: string;
    maxpagesize?: string;
}

// @public
export type BlobContainersListResponse = ListContainerItems & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ListContainerItems;
    };
};

// @public
export interface BlobContainersLockImmutabilityPolicyHeaders {
    eTag?: string;
}

// @public
export type BlobContainersLockImmutabilityPolicyResponse = BlobContainersLockImmutabilityPolicyHeaders & ImmutabilityPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ImmutabilityPolicy;
        parsedHeaders: BlobContainersLockImmutabilityPolicyHeaders;
    };
};

// @public
export type BlobContainersSetLegalHoldResponse = LegalHold & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: LegalHold;
    };
};

// @public
export type BlobContainersUpdateResponse = BlobContainer & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: BlobContainer;
    };
};

// @public
export interface BlobRestoreParameters {
    blobRanges: BlobRestoreRange[];
    timeToRestore: Date;
}

// @public
export type BlobRestoreProgressStatus = string;

// @public
export interface BlobRestoreRange {
    endRange: string;
    startRange: string;
}

// @public
export interface BlobRestoreStatus {
    readonly failureReason?: string;
    readonly parameters?: BlobRestoreParameters;
    readonly restoreId?: string;
    readonly status?: BlobRestoreProgressStatus;
}

// @public (undocumented)
export interface BlobServiceItems {
    readonly value?: BlobServiceProperties[];
}

// @public
export type BlobServiceProperties = Resource & {
    readonly sku?: Sku;
    cors?: CorsRules;
    defaultServiceVersion?: string;
    deleteRetentionPolicy?: DeleteRetentionPolicy;
    isVersioningEnabled?: boolean;
    automaticSnapshotPolicyEnabled?: boolean;
    changeFeed?: ChangeFeed;
    restorePolicy?: RestorePolicyProperties;
    containerDeleteRetentionPolicy?: DeleteRetentionPolicy;
};

// @public
export interface BlobServices {
    getServiceProperties(resourceGroupName: string, accountName: string, options?: coreHttp.OperationOptions): Promise<BlobServicesGetServicePropertiesResponse>;
    list(resourceGroupName: string, accountName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<BlobServiceProperties>;
    setServiceProperties(resourceGroupName: string, accountName: string, parameters: BlobServiceProperties, options?: coreHttp.OperationOptions): Promise<BlobServicesSetServicePropertiesResponse>;
}

// @public
export type BlobServicesGetServicePropertiesResponse = BlobServiceProperties & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: BlobServiceProperties;
    };
};

// @public
export type BlobServicesListResponse = BlobServiceItems & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: BlobServiceItems;
    };
};

// @public
export type BlobServicesSetServicePropertiesResponse = BlobServiceProperties & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: BlobServiceProperties;
    };
};

// @public
export type Bypass = string;

// @public
export interface ChangeFeed {
    enabled?: boolean;
}

// @public
export interface CheckNameAvailabilityResult {
    readonly message?: string;
    readonly nameAvailable?: boolean;
    readonly reason?: Reason;
}

// @public
export interface CloudError {
    error?: CloudErrorBody;
}

// @public
export interface CloudErrorBody {
    code?: string;
    details?: CloudErrorBody[];
    message?: string;
    target?: string;
}

// @public
export interface CorsRule {
    allowedHeaders: string[];
    allowedMethods: CorsRuleAllowedMethodsItem[];
    allowedOrigins: string[];
    exposedHeaders: string[];
    maxAgeInSeconds: number;
}

// @public
export type CorsRuleAllowedMethodsItem = string;

// @public
export interface CorsRules {
    corsRules?: CorsRule[];
}

// @public
export interface CustomDomain {
    name: string;
    useSubDomainName?: boolean;
}

// @public
export interface DateAfterCreation {
    daysAfterCreationGreaterThan: number;
}

// @public
export interface DateAfterModification {
    daysAfterModificationGreaterThan: number;
}

// @public
export type DefaultAction = "Allow" | "Deny";

// @public
export interface DeletedShare {
    deletedShareName: string;
    deletedShareVersion: string;
}

// @public
export interface DeleteRetentionPolicy {
    days?: number;
    enabled?: boolean;
}

// @public
export interface Dimension {
    displayName?: string;
    name?: string;
}

// @public
export type DirectoryServiceOptions = string;

// @public
export type EnabledProtocols = string;

// @public
export interface Encryption {
    keySource: KeySource;
    keyVaultProperties?: KeyVaultProperties;
    services?: EncryptionServices;
}

// @public
export type EncryptionScope = Resource & {
    source?: EncryptionScopeSource;
    state?: EncryptionScopeState;
    readonly creationTime?: Date;
    readonly lastModifiedTime?: Date;
    keyVaultProperties?: EncryptionScopeKeyVaultProperties;
};

// @public
export interface EncryptionScopeKeyVaultProperties {
    keyUri?: string;
}

// @public
export interface EncryptionScopeListResult {
    readonly nextLink?: string;
    readonly value?: EncryptionScope[];
}

// @public
export interface EncryptionScopes {
    get(resourceGroupName: string, accountName: string, encryptionScopeName: string, options?: coreHttp.OperationOptions): Promise<EncryptionScopesGetResponse>;
    list(resourceGroupName: string, accountName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<EncryptionScope>;
    patch(resourceGroupName: string, accountName: string, encryptionScopeName: string, encryptionScope: EncryptionScope, options?: coreHttp.OperationOptions): Promise<EncryptionScopesPatchResponse>;
    put(resourceGroupName: string, accountName: string, encryptionScopeName: string, encryptionScope: EncryptionScope, options?: coreHttp.OperationOptions): Promise<EncryptionScopesPutResponse>;
}

// @public
export type EncryptionScopesGetResponse = EncryptionScope & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: EncryptionScope;
    };
};

// @public
export type EncryptionScopesListNextResponse = EncryptionScopeListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: EncryptionScopeListResult;
    };
};

// @public
export type EncryptionScopesListResponse = EncryptionScopeListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: EncryptionScopeListResult;
    };
};

// @public
export type EncryptionScopeSource = string;

// @public
export type EncryptionScopesPatchResponse = EncryptionScope & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: EncryptionScope;
    };
};

// @public
export type EncryptionScopesPutResponse = EncryptionScope & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: EncryptionScope;
    };
};

// @public
export type EncryptionScopeState = string;

// @public
export interface EncryptionService {
    enabled?: boolean;
    keyType?: KeyType_2;
    readonly lastEnabledTime?: Date;
}

// @public
export interface EncryptionServices {
    blob?: EncryptionService;
    file?: EncryptionService;
    queue?: EncryptionService;
    table?: EncryptionService;
}

// @public
export interface Endpoints {
    readonly blob?: string;
    readonly dfs?: string;
    readonly file?: string;
    internetEndpoints?: StorageAccountInternetEndpoints;
    microsoftEndpoints?: StorageAccountMicrosoftEndpoints;
    readonly queue?: string;
    readonly table?: string;
    readonly web?: string;
}

// @public
export interface ErrorResponse {
    code?: string;
    message?: string;
}

// @public (undocumented)
export interface FileServiceItems {
    readonly value?: FileServiceProperties[];
}

// @public
export type FileServiceProperties = Resource & {
    readonly sku?: Sku;
    cors?: CorsRules;
    shareDeleteRetentionPolicy?: DeleteRetentionPolicy;
};

// @public
export interface FileServices {
    getServiceProperties(resourceGroupName: string, accountName: string, options?: coreHttp.OperationOptions): Promise<FileServicesGetServicePropertiesResponse>;
    list(resourceGroupName: string, accountName: string, options?: coreHttp.OperationOptions): Promise<FileServicesListResponse>;
    setServiceProperties(resourceGroupName: string, accountName: string, parameters: FileServiceProperties, options?: coreHttp.OperationOptions): Promise<FileServicesSetServicePropertiesResponse>;
}

// @public
export type FileServicesGetServicePropertiesResponse = FileServiceProperties & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: FileServiceProperties;
    };
};

// @public
export type FileServicesListResponse = FileServiceItems & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: FileServiceItems;
    };
};

// @public
export type FileServicesSetServicePropertiesResponse = FileServiceProperties & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: FileServiceProperties;
    };
};

// @public
export type FileShare = AzureEntityResource & {
    readonly lastModifiedTime?: Date;
    metadata?: {
        [propertyName: string]: string;
    };
    shareQuota?: number;
    enabledProtocols?: EnabledProtocols;
    rootSquash?: RootSquashType;
    readonly version?: string;
    readonly deleted?: boolean;
    readonly deletedTime?: Date;
    readonly remainingRetentionDays?: number;
    accessTier?: ShareAccessTier;
    readonly accessTierChangeTime?: Date;
    readonly accessTierStatus?: string;
    readonly shareUsageBytes?: number;
};

// @public
export type FileShareItem = AzureEntityResource & {
    readonly lastModifiedTime?: Date;
    metadata?: {
        [propertyName: string]: string;
    };
    shareQuota?: number;
    enabledProtocols?: EnabledProtocols;
    rootSquash?: RootSquashType;
    readonly version?: string;
    readonly deleted?: boolean;
    readonly deletedTime?: Date;
    readonly remainingRetentionDays?: number;
    accessTier?: ShareAccessTier;
    readonly accessTierChangeTime?: Date;
    readonly accessTierStatus?: string;
    readonly shareUsageBytes?: number;
};

// @public
export interface FileShareItems {
    readonly nextLink?: string;
    readonly value?: FileShareItem[];
}

// @public
export interface FileShares {
    create(resourceGroupName: string, accountName: string, shareName: string, fileShare: FileShare, options?: coreHttp.OperationOptions): Promise<FileSharesCreateResponse>;
    delete(resourceGroupName: string, accountName: string, shareName: string, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    get(resourceGroupName: string, accountName: string, shareName: string, options?: coreHttp.OperationOptions): Promise<FileSharesGetResponse>;
    list(resourceGroupName: string, accountName: string, options?: FileSharesListOptionalParams): PagedAsyncIterableIterator<FileShareItem>;
    restore(resourceGroupName: string, accountName: string, shareName: string, deletedShare: DeletedShare, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    update(resourceGroupName: string, accountName: string, shareName: string, fileShare: FileShare, options?: coreHttp.OperationOptions): Promise<FileSharesUpdateResponse>;
}

// @public
export type FileSharesCreateResponse = FileShare & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: FileShare;
    };
};

// @public
export type FileSharesGetResponse = FileShare & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: FileShare;
    };
};

// @public
export interface FileSharesListNextOptionalParams extends coreHttp.OperationOptions {
    filter?: string;
    maxpagesize?: string;
}

// @public
export type FileSharesListNextResponse = FileShareItems & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: FileShareItems;
    };
};

// @public
export interface FileSharesListOptionalParams extends coreHttp.OperationOptions {
    filter?: string;
    maxpagesize?: string;
}

// @public
export type FileSharesListResponse = FileShareItems & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: FileShareItems;
    };
};

// @public
export type FileSharesUpdateResponse = FileShare & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: FileShare;
    };
};

// @public
export interface GeoReplicationStats {
    readonly canFailover?: boolean;
    readonly lastSyncTime?: Date;
    readonly status?: GeoReplicationStatus;
}

// @public
export type GeoReplicationStatus = string;

// @public
export type HttpProtocol = "https,http" | "https";

// @public
export interface Identity {
    readonly principalId?: string;
    readonly tenantId?: string;
    type: "SystemAssigned";
}

// @public
export type ImmutabilityPolicy = AzureEntityResource & {
    immutabilityPeriodSinceCreationInDays?: number;
    readonly state?: ImmutabilityPolicyState;
    allowProtectedAppendWrites?: boolean;
};

// @public
export interface ImmutabilityPolicyProperties {
    allowProtectedAppendWrites?: boolean;
    readonly etag?: string;
    immutabilityPeriodSinceCreationInDays?: number;
    readonly state?: ImmutabilityPolicyState;
    readonly updateHistory?: UpdateHistoryProperty[];
}

// @public
export type ImmutabilityPolicyState = string;

// @public
export type ImmutabilityPolicyUpdateType = string;

// @public
export interface IPRule {
    action?: "Allow";
    iPAddressOrRange: string;
}

// @public
export type KeyPermission = "Read" | "Full";

// @public
export type KeySource = string;

// @public
type KeyType_2 = string;

export { KeyType_2 as KeyType }

// @public
export interface KeyVaultProperties {
    readonly currentVersionedKeyIdentifier?: string;
    keyName?: string;
    keyVaultUri?: string;
    keyVersion?: string;
    readonly lastKeyRotationTimestamp?: Date;
}

// @public
export type Kind = string;

// @public
export const enum KnownBlobRestoreProgressStatus {
    // (undocumented)
    Complete = "Complete",
    // (undocumented)
    Failed = "Failed",
    // (undocumented)
    InProgress = "InProgress"
}

// @public
export const enum KnownBypass {
    // (undocumented)
    AzureServices = "AzureServices",
    // (undocumented)
    Logging = "Logging",
    // (undocumented)
    Metrics = "Metrics",
    // (undocumented)
    None = "None"
}

// @public
export const enum KnownCorsRuleAllowedMethodsItem {
    // (undocumented)
    Delete = "DELETE",
    // (undocumented)
    GET = "GET",
    // (undocumented)
    Head = "HEAD",
    // (undocumented)
    Merge = "MERGE",
    // (undocumented)
    Options = "OPTIONS",
    // (undocumented)
    Post = "POST",
    // (undocumented)
    PUT = "PUT"
}

// @public
export const enum KnownDirectoryServiceOptions {
    // (undocumented)
    Aadds = "AADDS",
    // (undocumented)
    AD = "AD",
    // (undocumented)
    None = "None"
}

// @public
export const enum KnownEnabledProtocols {
    // (undocumented)
    NFS = "NFS",
    // (undocumented)
    SMB = "SMB"
}

// @public
export const enum KnownEncryptionScopeSource {
    // (undocumented)
    MicrosoftKeyVault = "Microsoft.KeyVault",
    // (undocumented)
    MicrosoftStorage = "Microsoft.Storage"
}

// @public
export const enum KnownEncryptionScopeState {
    // (undocumented)
    Disabled = "Disabled",
    // (undocumented)
    Enabled = "Enabled"
}

// @public
export const enum KnownGeoReplicationStatus {
    // (undocumented)
    Bootstrap = "Bootstrap",
    // (undocumented)
    Live = "Live",
    // (undocumented)
    Unavailable = "Unavailable"
}

// @public
export const enum KnownImmutabilityPolicyState {
    // (undocumented)
    Locked = "Locked",
    // (undocumented)
    Unlocked = "Unlocked"
}

// @public
export const enum KnownImmutabilityPolicyUpdateType {
    // (undocumented)
    Extend = "extend",
    // (undocumented)
    Lock = "lock",
    // (undocumented)
    Put = "put"
}

// @public
export const enum KnownKeySource {
    // (undocumented)
    MicrosoftKeyvault = "Microsoft.Keyvault",
    // (undocumented)
    MicrosoftStorage = "Microsoft.Storage"
}

// @public
export const enum KnownKeyType {
    // (undocumented)
    Account = "Account",
    // (undocumented)
    Service = "Service"
}

// @public
export const enum KnownKind {
    // (undocumented)
    BlobStorage = "BlobStorage",
    // (undocumented)
    BlockBlobStorage = "BlockBlobStorage",
    // (undocumented)
    FileStorage = "FileStorage",
    // (undocumented)
    Storage = "Storage",
    // (undocumented)
    StorageV2 = "StorageV2"
}

// @public
export const enum KnownLargeFileSharesState {
    // (undocumented)
    Disabled = "Disabled",
    // (undocumented)
    Enabled = "Enabled"
}

// @public
export const enum KnownLeaseContainerRequestAction {
    // (undocumented)
    Acquire = "Acquire",
    // (undocumented)
    Break = "Break",
    // (undocumented)
    Change = "Change",
    // (undocumented)
    Release = "Release",
    // (undocumented)
    Renew = "Renew"
}

// @public
export const enum KnownLeaseDuration {
    // (undocumented)
    Fixed = "Fixed",
    // (undocumented)
    Infinite = "Infinite"
}

// @public
export const enum KnownLeaseState {
    // (undocumented)
    Available = "Available",
    // (undocumented)
    Breaking = "Breaking",
    // (undocumented)
    Broken = "Broken",
    // (undocumented)
    Expired = "Expired",
    // (undocumented)
    Leased = "Leased"
}

// @public
export const enum KnownLeaseStatus {
    // (undocumented)
    Locked = "Locked",
    // (undocumented)
    Unlocked = "Unlocked"
}

// @public
export const enum KnownManagementPolicyName {
    // (undocumented)
    Default = "default"
}

// @public
export const enum KnownPermissions {
    // (undocumented)
    A = "a",
    // (undocumented)
    C = "c",
    // (undocumented)
    D = "d",
    // (undocumented)
    L = "l",
    // (undocumented)
    P = "p",
    // (undocumented)
    R = "r",
    // (undocumented)
    U = "u",
    // (undocumented)
    W = "w"
}

// @public
export const enum KnownPrivateEndpointConnectionProvisioningState {
    // (undocumented)
    Creating = "Creating",
    // (undocumented)
    Deleting = "Deleting",
    // (undocumented)
    Failed = "Failed",
    // (undocumented)
    Succeeded = "Succeeded"
}

// @public
export const enum KnownPrivateEndpointServiceConnectionStatus {
    // (undocumented)
    Approved = "Approved",
    // (undocumented)
    Pending = "Pending",
    // (undocumented)
    Rejected = "Rejected"
}

// @public
export const enum KnownReasonCode {
    // (undocumented)
    NotAvailableForSubscription = "NotAvailableForSubscription",
    // (undocumented)
    QuotaId = "QuotaId"
}

// @public
export const enum KnownRootSquashType {
    // (undocumented)
    AllSquash = "AllSquash",
    // (undocumented)
    NoRootSquash = "NoRootSquash",
    // (undocumented)
    RootSquash = "RootSquash"
}

// @public
export const enum KnownRoutingChoice {
    // (undocumented)
    InternetRouting = "InternetRouting",
    // (undocumented)
    MicrosoftRouting = "MicrosoftRouting"
}

// @public
export const enum KnownRuleType {
    // (undocumented)
    Lifecycle = "Lifecycle"
}

// @public
export const enum KnownServices {
    // (undocumented)
    B = "b",
    // (undocumented)
    F = "f",
    // (undocumented)
    Q = "q",
    // (undocumented)
    T = "t"
}

// @public
export const enum KnownShareAccessTier {
    // (undocumented)
    Cool = "Cool",
    // (undocumented)
    Hot = "Hot",
    // (undocumented)
    Premium = "Premium",
    // (undocumented)
    TransactionOptimized = "TransactionOptimized"
}

// @public
export const enum KnownSignedResource {
    // (undocumented)
    B = "b",
    // (undocumented)
    C = "c",
    // (undocumented)
    F = "f",
    // (undocumented)
    S = "s"
}

// @public
export const enum KnownSignedResourceTypes {
    // (undocumented)
    C = "c",
    // (undocumented)
    O = "o",
    // (undocumented)
    S = "s"
}

// @public
export const enum KnownSkuName {
    // (undocumented)
    PremiumLRS = "Premium_LRS",
    // (undocumented)
    PremiumZRS = "Premium_ZRS",
    // (undocumented)
    StandardGRS = "Standard_GRS",
    // (undocumented)
    StandardGzrs = "Standard_GZRS",
    // (undocumented)
    StandardLRS = "Standard_LRS",
    // (undocumented)
    StandardRagrs = "Standard_RAGRS",
    // (undocumented)
    StandardRagzrs = "Standard_RAGZRS",
    // (undocumented)
    StandardZRS = "Standard_ZRS"
}

// @public
export type LargeFileSharesState = string;

// @public
export interface LeaseContainerRequest {
    action: LeaseContainerRequestAction;
    breakPeriod?: number;
    leaseDuration?: number;
    leaseId?: string;
    proposedLeaseId?: string;
}

// @public
export type LeaseContainerRequestAction = string;

// @public
export interface LeaseContainerResponse {
    leaseId?: string;
    leaseTimeSeconds?: string;
}

// @public
export type LeaseDuration = string;

// @public
export type LeaseState = string;

// @public
export type LeaseStatus = string;

// @public
export interface LegalHold {
    readonly hasLegalHold?: boolean;
    tags: string[];
}

// @public
export interface LegalHoldProperties {
    readonly hasLegalHold?: boolean;
    tags?: TagProperty[];
}

// @public
export interface ListAccountSasResponse {
    readonly accountSasToken?: string;
}

// @public
export type ListContainerItem = AzureEntityResource & {
    defaultEncryptionScope?: string;
    denyEncryptionScopeOverride?: boolean;
    publicAccess?: PublicAccess;
    readonly lastModifiedTime?: Date;
    readonly leaseStatus?: LeaseStatus;
    readonly leaseState?: LeaseState;
    readonly leaseDuration?: LeaseDuration;
    metadata?: {
        [propertyName: string]: string;
    };
    readonly immutabilityPolicy?: ImmutabilityPolicyProperties;
    readonly legalHold?: LegalHoldProperties;
    readonly hasLegalHold?: boolean;
    readonly hasImmutabilityPolicy?: boolean;
};

// @public
export interface ListContainerItems {
    readonly nextLink?: string;
    readonly value?: ListContainerItem[];
}

// @public
export interface ListServiceSasResponse {
    readonly serviceSasToken?: string;
}

// Warning: (ae-forgotten-export) The symbol "BaseResult" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export interface LROOperationState<TResult extends BaseResult> extends PollOperationState<TResult> {
    // Warning: (ae-forgotten-export) The symbol "FinalStateVia" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    finalStateVia?: FinalStateVia;
    // (undocumented)
    initialOperation: LROOperationStep<TResult>;
    // Warning: (ae-forgotten-export) The symbol "LROOperationStep" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    lastOperation: LROOperationStep<TResult>;
    // Warning: (ae-forgotten-export) The symbol "LROStrategy" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    pollingStrategy: LROStrategy<TResult>;
}

// @public
export interface ManagementPolicies {
    createOrUpdate(resourceGroupName: string, accountName: string, managementPolicyName: ManagementPolicyName, properties: ManagementPolicy, options?: coreHttp.OperationOptions): Promise<ManagementPoliciesCreateOrUpdateResponse>;
    delete(resourceGroupName: string, accountName: string, managementPolicyName: ManagementPolicyName, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    get(resourceGroupName: string, accountName: string, managementPolicyName: ManagementPolicyName, options?: coreHttp.OperationOptions): Promise<ManagementPoliciesGetResponse>;
}

// @public
export type ManagementPoliciesCreateOrUpdateResponse = ManagementPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagementPolicy;
    };
};

// @public
export type ManagementPoliciesGetResponse = ManagementPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagementPolicy;
    };
};

// @public
export type ManagementPolicy = Resource & {
    readonly lastModifiedTime?: Date;
    policy?: ManagementPolicySchema;
};

// @public
export interface ManagementPolicyAction {
    baseBlob?: ManagementPolicyBaseBlob;
    snapshot?: ManagementPolicySnapShot;
}

// @public
export interface ManagementPolicyBaseBlob {
    delete?: DateAfterModification;
    tierToArchive?: DateAfterModification;
    tierToCool?: DateAfterModification;
}

// @public
export interface ManagementPolicyDefinition {
    actions: ManagementPolicyAction;
    filters?: ManagementPolicyFilter;
}

// @public
export interface ManagementPolicyFilter {
    blobIndexMatch?: TagFilter[];
    blobTypes: string[];
    prefixMatch?: string[];
}

// @public
export type ManagementPolicyName = string;

// @public
export interface ManagementPolicyRule {
    definition: ManagementPolicyDefinition;
    enabled?: boolean;
    name: string;
    type: RuleType;
}

// @public
export interface ManagementPolicySchema {
    rules: ManagementPolicyRule[];
}

// @public
export interface ManagementPolicySnapShot {
    delete?: DateAfterCreation;
}

// @public
export interface MetricSpecification {
    aggregationType?: string;
    category?: string;
    dimensions?: Dimension[];
    displayDescription?: string;
    displayName?: string;
    fillGapWithZero?: boolean;
    name?: string;
    resourceIdDimensionNameOverride?: string;
    unit?: string;
}

// @public
export interface NetworkRuleSet {
    bypass?: Bypass;
    defaultAction: DefaultAction;
    ipRules?: IPRule[];
    virtualNetworkRules?: VirtualNetworkRule[];
}

// @public
export interface ObjectReplicationPolicies {
    createOrUpdate(resourceGroupName: string, accountName: string, objectReplicationPolicyId: string, properties: ObjectReplicationPolicy, options?: coreHttp.OperationOptions): Promise<ObjectReplicationPoliciesCreateOrUpdateResponse>;
    delete(resourceGroupName: string, accountName: string, objectReplicationPolicyId: string, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    get(resourceGroupName: string, accountName: string, objectReplicationPolicyId: string, options?: coreHttp.OperationOptions): Promise<ObjectReplicationPoliciesGetResponse>;
    list(resourceGroupName: string, accountName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<ObjectReplicationPolicy>;
}

// @public
export type ObjectReplicationPoliciesCreateOrUpdateResponse = ObjectReplicationPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ObjectReplicationPolicy;
    };
};

// @public
export interface ObjectReplicationPoliciesDef {
    value?: ObjectReplicationPolicy[];
}

// @public
export type ObjectReplicationPoliciesGetResponse = ObjectReplicationPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ObjectReplicationPolicy;
    };
};

// @public
export type ObjectReplicationPoliciesListResponse = ObjectReplicationPoliciesDef & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ObjectReplicationPoliciesDef;
    };
};

// @public
export type ObjectReplicationPolicy = Resource & {
    readonly policyId?: string;
    readonly enabledTime?: Date;
    sourceAccount?: string;
    destinationAccount?: string;
    rules?: ObjectReplicationPolicyRule[];
};

// @public
export interface ObjectReplicationPolicyFilter {
    minCreationTime?: string;
    prefixMatch?: string[];
}

// @public
export interface ObjectReplicationPolicyRule {
    destinationContainer: string;
    filters?: ObjectReplicationPolicyFilter;
    ruleId?: string;
    sourceContainer: string;
}

// @public
export interface Operation {
    display?: OperationDisplay;
    name?: string;
    origin?: string;
    serviceSpecification?: ServiceSpecification;
}

// @public
export interface OperationDisplay {
    description?: string;
    operation?: string;
    provider?: string;
    resource?: string;
}

// @public
export interface OperationListResult {
    value?: Operation[];
}

// @public
export interface Operations {
    list(options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<Operation>;
}

// @public
export type OperationsListResponse = OperationListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: OperationListResult;
    };
};

// @public
type Permissions_2 = string;

export { Permissions_2 as Permissions }

// @public
export interface PrivateEndpoint {
    readonly id?: string;
}

// @public
export type PrivateEndpointConnection = Resource & {
    privateEndpoint?: PrivateEndpoint;
    privateLinkServiceConnectionState?: PrivateLinkServiceConnectionState;
    readonly provisioningState?: PrivateEndpointConnectionProvisioningState;
};

// @public
export interface PrivateEndpointConnectionListResult {
    value?: PrivateEndpointConnection[];
}

// @public
export type PrivateEndpointConnectionProvisioningState = string;

// @public
export interface PrivateEndpointConnections {
    delete(resourceGroupName: string, accountName: string, privateEndpointConnectionName: string, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    get(resourceGroupName: string, accountName: string, privateEndpointConnectionName: string, options?: coreHttp.OperationOptions): Promise<PrivateEndpointConnectionsGetResponse>;
    list(resourceGroupName: string, accountName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<PrivateEndpointConnection>;
    put(resourceGroupName: string, accountName: string, privateEndpointConnectionName: string, properties: PrivateEndpointConnection, options?: coreHttp.OperationOptions): Promise<PrivateEndpointConnectionsPutResponse>;
}

// @public
export type PrivateEndpointConnectionsGetResponse = PrivateEndpointConnection & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: PrivateEndpointConnection;
    };
};

// @public
export type PrivateEndpointConnectionsListResponse = PrivateEndpointConnectionListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: PrivateEndpointConnectionListResult;
    };
};

// @public
export type PrivateEndpointConnectionsPutResponse = PrivateEndpointConnection & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: PrivateEndpointConnection;
    };
};

// @public
export type PrivateEndpointServiceConnectionStatus = string;

// @public
export type PrivateLinkResource = Resource & {
    readonly groupId?: string;
    readonly requiredMembers?: string[];
    requiredZoneNames?: string[];
};

// @public
export interface PrivateLinkResourceListResult {
    value?: PrivateLinkResource[];
}

// @public
export interface PrivateLinkResources {
    listByStorageAccount(resourceGroupName: string, accountName: string, options?: coreHttp.OperationOptions): Promise<PrivateLinkResourcesListByStorageAccountResponse>;
}

// @public
export type PrivateLinkResourcesListByStorageAccountResponse = PrivateLinkResourceListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: PrivateLinkResourceListResult;
    };
};

// @public
export interface PrivateLinkServiceConnectionState {
    actionRequired?: string;
    description?: string;
    status?: PrivateEndpointServiceConnectionStatus;
}

// @public
export type ProvisioningState = "Creating" | "ResolvingDNS" | "Succeeded";

// @public
export type PublicAccess = "Container" | "Blob" | "None";

// @public
export type Reason = "AccountNameInvalid" | "AlreadyExists";

// @public
export type ReasonCode = string;

// @public (undocumented)
export interface Resource {
    readonly id?: string;
    readonly name?: string;
    readonly type?: string;
}

// @public
export interface RestorePolicyProperties {
    days?: number;
    enabled: boolean;
    readonly lastEnabledTime?: Date;
}

// @public
export interface Restriction {
    reasonCode?: ReasonCode;
    readonly type?: string;
    readonly values?: string[];
}

// @public
export type RootSquashType = string;

// @public
export type RoutingChoice = string;

// @public
export interface RoutingPreference {
    publishInternetEndpoints?: boolean;
    publishMicrosoftEndpoints?: boolean;
    routingChoice?: RoutingChoice;
}

// @public
export type RuleType = string;

// @public
export type Services = string;

// @public
export interface ServiceSasParameters {
    cacheControl?: string;
    canonicalizedResource: string;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentType?: string;
    identifier?: string;
    iPAddressOrRange?: string;
    keyToSign?: string;
    partitionKeyEnd?: string;
    partitionKeyStart?: string;
    permissions?: Permissions_2;
    protocols?: HttpProtocol;
    resource?: SignedResource;
    rowKeyEnd?: string;
    rowKeyStart?: string;
    sharedAccessExpiryTime?: Date;
    sharedAccessStartTime?: Date;
}

// @public
export interface ServiceSpecification {
    metricSpecifications?: MetricSpecification[];
}

// @public
export type ShareAccessTier = string;

// @public
export type SignedResource = string;

// @public
export type SignedResourceTypes = string;

// @public
export interface Sku {
    name: SkuName;
    readonly tier?: SkuTier;
}

// @public
export interface SKUCapability {
    readonly name?: string;
    readonly value?: string;
}

// @public
export interface SkuInformation {
    readonly capabilities?: SKUCapability[];
    readonly kind?: Kind;
    readonly locations?: string[];
    name: SkuName;
    readonly resourceType?: string;
    restrictions?: Restriction[];
    readonly tier?: SkuTier;
}

// @public
export type SkuName = string;

// @public
export interface Skus {
    list(options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<SkuInformation>;
}

// @public
export type SkusListResponse = StorageSkuListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: StorageSkuListResult;
    };
};

// @public
export type SkuTier = "Standard" | "Premium";

// @public
export type State = "provisioning" | "deprovisioning" | "succeeded" | "failed" | "networkSourceDeleted";

// @public
export type StorageAccount = TrackedResource & {
    readonly sku?: Sku;
    readonly kind?: Kind;
    identity?: Identity;
    readonly provisioningState?: ProvisioningState;
    readonly primaryEndpoints?: Endpoints;
    readonly primaryLocation?: string;
    readonly statusOfPrimary?: AccountStatus;
    readonly lastGeoFailoverTime?: Date;
    readonly secondaryLocation?: string;
    readonly statusOfSecondary?: AccountStatus;
    readonly creationTime?: Date;
    readonly customDomain?: CustomDomain;
    readonly secondaryEndpoints?: Endpoints;
    readonly encryption?: Encryption;
    readonly accessTier?: AccessTier;
    azureFilesIdentityBasedAuthentication?: AzureFilesIdentityBasedAuthentication;
    enableHttpsTrafficOnly?: boolean;
    readonly networkRuleSet?: NetworkRuleSet;
    isHnsEnabled?: boolean;
    readonly geoReplicationStats?: GeoReplicationStats;
    readonly failoverInProgress?: boolean;
    largeFileSharesState?: LargeFileSharesState;
    readonly privateEndpointConnections?: PrivateEndpointConnection[];
    routingPreference?: RoutingPreference;
    readonly blobRestoreStatus?: BlobRestoreStatus;
};

// @public
export interface StorageAccountCheckNameAvailabilityParameters {
    name: string;
    type: "Microsoft.Storage/storageAccounts";
}

// @public
export interface StorageAccountCreateParameters {
    accessTier?: AccessTier;
    azureFilesIdentityBasedAuthentication?: AzureFilesIdentityBasedAuthentication;
    customDomain?: CustomDomain;
    enableHttpsTrafficOnly?: boolean;
    encryption?: Encryption;
    identity?: Identity;
    isHnsEnabled?: boolean;
    kind: Kind;
    largeFileSharesState?: LargeFileSharesState;
    location: string;
    networkRuleSet?: NetworkRuleSet;
    routingPreference?: RoutingPreference;
    sku: Sku;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export type StorageAccountExpand = "geoReplicationStats" | "blobRestoreStatus";

// @public
export interface StorageAccountInternetEndpoints {
    readonly blob?: string;
    readonly dfs?: string;
    readonly file?: string;
    readonly web?: string;
}

// @public
export interface StorageAccountKey {
    readonly keyName?: string;
    readonly permissions?: KeyPermission;
    readonly value?: string;
}

// @public
export interface StorageAccountListKeysResult {
    readonly keys?: StorageAccountKey[];
}

// @public
export interface StorageAccountListResult {
    readonly nextLink?: string;
    readonly value?: StorageAccount[];
}

// @public
export interface StorageAccountMicrosoftEndpoints {
    readonly blob?: string;
    readonly dfs?: string;
    readonly file?: string;
    readonly queue?: string;
    readonly table?: string;
    readonly web?: string;
}

// @public
export interface StorageAccountRegenerateKeyParameters {
    keyName: string;
}

// @public
export interface StorageAccounts {
    checkNameAvailability(accountName: StorageAccountCheckNameAvailabilityParameters, options?: coreHttp.OperationOptions): Promise<StorageAccountsCheckNameAvailabilityResponse>;
    create(resourceGroupName: string, accountName: string, parameters: StorageAccountCreateParameters, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<StorageAccountsCreateResponse>, StorageAccountsCreateResponse>>;
    delete(resourceGroupName: string, accountName: string, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    failover(resourceGroupName: string, accountName: string, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<coreHttp.RestResponse>, coreHttp.RestResponse>>;
    getProperties(resourceGroupName: string, accountName: string, options?: StorageAccountsGetPropertiesOptionalParams): Promise<StorageAccountsGetPropertiesResponse>;
    list(options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<StorageAccount>;
    listAccountSAS(resourceGroupName: string, accountName: string, parameters: AccountSasParameters, options?: coreHttp.OperationOptions): Promise<StorageAccountsListAccountSASResponse>;
    listByResourceGroup(resourceGroupName: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<StorageAccount>;
    listKeys(resourceGroupName: string, accountName: string, options?: coreHttp.OperationOptions): Promise<StorageAccountsListKeysResponse>;
    listServiceSAS(resourceGroupName: string, accountName: string, parameters: ServiceSasParameters, options?: coreHttp.OperationOptions): Promise<StorageAccountsListServiceSASResponse>;
    regenerateKey(resourceGroupName: string, accountName: string, regenerateKey: StorageAccountRegenerateKeyParameters, options?: coreHttp.OperationOptions): Promise<StorageAccountsRegenerateKeyResponse>;
    restoreBlobRanges(resourceGroupName: string, accountName: string, parameters: BlobRestoreParameters, options?: coreHttp.OperationOptions): Promise<PollerLike<LROOperationState<StorageAccountsRestoreBlobRangesResponse>, StorageAccountsRestoreBlobRangesResponse>>;
    revokeUserDelegationKeys(resourceGroupName: string, accountName: string, options?: coreHttp.OperationOptions): Promise<coreHttp.RestResponse>;
    update(resourceGroupName: string, accountName: string, parameters: StorageAccountUpdateParameters, options?: coreHttp.OperationOptions): Promise<StorageAccountsUpdateResponse>;
}

// @public
export type StorageAccountsCheckNameAvailabilityResponse = CheckNameAvailabilityResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: CheckNameAvailabilityResult;
    };
};

// @public
export type StorageAccountsCreateResponse = StorageAccount & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: StorageAccount;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export interface StorageAccountsGetPropertiesOptionalParams extends coreHttp.OperationOptions {
    expand?: StorageAccountExpand;
}

// @public
export type StorageAccountsGetPropertiesResponse = StorageAccount & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: StorageAccount;
    };
};

// @public
export type StorageAccountsListAccountSASResponse = ListAccountSasResponse & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ListAccountSasResponse;
    };
};

// @public
export type StorageAccountsListByResourceGroupResponse = StorageAccountListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: StorageAccountListResult;
    };
};

// @public
export type StorageAccountsListKeysResponse = StorageAccountListKeysResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: StorageAccountListKeysResult;
    };
};

// @public
export type StorageAccountsListNextResponse = StorageAccountListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: StorageAccountListResult;
    };
};

// @public
export type StorageAccountsListResponse = StorageAccountListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: StorageAccountListResult;
    };
};

// @public
export type StorageAccountsListServiceSASResponse = ListServiceSasResponse & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ListServiceSasResponse;
    };
};

// @public
export type StorageAccountsRegenerateKeyResponse = StorageAccountListKeysResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: StorageAccountListKeysResult;
    };
};

// @public
export type StorageAccountsRestoreBlobRangesResponse = BlobRestoreStatus & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: BlobRestoreStatus;
        [LROSYM]: LROResponseInfo;
    };
};

// @public
export type StorageAccountsUpdateResponse = StorageAccount & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: StorageAccount;
    };
};

// @public
export interface StorageAccountUpdateParameters {
    accessTier?: AccessTier;
    azureFilesIdentityBasedAuthentication?: AzureFilesIdentityBasedAuthentication;
    customDomain?: CustomDomain;
    enableHttpsTrafficOnly?: boolean;
    encryption?: Encryption;
    identity?: Identity;
    kind?: Kind;
    largeFileSharesState?: LargeFileSharesState;
    networkRuleSet?: NetworkRuleSet;
    routingPreference?: RoutingPreference;
    sku?: Sku;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public (undocumented)
export class StorageManagementClient extends StorageManagementClientContext {
    constructor(credentials: coreHttp.TokenCredential | coreHttp.ServiceClientCredentials, subscriptionId: string, options?: StorageManagementClientOptionalParams);
    // (undocumented)
    blobContainers: BlobContainers;
    // (undocumented)
    blobServices: BlobServices;
    // (undocumented)
    encryptionScopes: EncryptionScopes;
    // (undocumented)
    fileServices: FileServices;
    // (undocumented)
    fileShares: FileShares;
    // (undocumented)
    managementPolicies: ManagementPolicies;
    // (undocumented)
    objectReplicationPolicies: ObjectReplicationPolicies;
    // (undocumented)
    operations: Operations;
    // (undocumented)
    privateEndpointConnections: PrivateEndpointConnections;
    // (undocumented)
    privateLinkResources: PrivateLinkResources;
    // (undocumented)
    skus: Skus;
    // (undocumented)
    storageAccounts: StorageAccounts;
    // (undocumented)
    usages: Usages;
}

// @public (undocumented)
export class StorageManagementClientContext extends coreHttp.ServiceClient {
    // (undocumented)
    $host: string;
    constructor(credentials: coreHttp.TokenCredential | coreHttp.ServiceClientCredentials, subscriptionId: string, options?: StorageManagementClientOptionalParams);
    // (undocumented)
    apiVersion: string;
    // (undocumented)
    subscriptionId: string;
}

// @public
export interface StorageManagementClientOptionalParams extends coreHttp.ServiceClientOptions {
    $host?: string;
    apiVersion?: string;
    endpoint?: string;
}

// @public
export interface StorageSkuListResult {
    readonly value?: SkuInformation[];
}

// @public
export interface TagFilter {
    name: string;
    op: string;
    value: string;
}

// @public
export interface TagProperty {
    readonly objectIdentifier?: string;
    readonly tag?: string;
    readonly tenantId?: string;
    readonly timestamp?: Date;
    readonly upn?: string;
}

// @public
export type TrackedResource = Resource & {
    tags?: {
        [propertyName: string]: string;
    };
    location: string;
};

// @public
export interface UpdateHistoryProperty {
    readonly immutabilityPeriodSinceCreationInDays?: number;
    readonly objectIdentifier?: string;
    readonly tenantId?: string;
    readonly timestamp?: Date;
    readonly update?: ImmutabilityPolicyUpdateType;
    readonly upn?: string;
}

// @public
export interface Usage {
    readonly currentValue?: number;
    readonly limit?: number;
    readonly name?: UsageName;
    readonly unit?: UsageUnit;
}

// @public
export interface UsageListResult {
    value?: Usage[];
}

// @public
export interface UsageName {
    readonly localizedValue?: string;
    readonly value?: string;
}

// @public
export interface Usages {
    listByLocation(location: string, options?: coreHttp.OperationOptions): PagedAsyncIterableIterator<Usage>;
}

// @public
export type UsagesListByLocationResponse = UsageListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: UsageListResult;
    };
};

// @public
export type UsageUnit = "Count" | "Bytes" | "Seconds" | "Percent" | "CountsPerSecond" | "BytesPerSecond";

// @public
export interface VirtualNetworkRule {
    action?: "Allow";
    state?: State;
    virtualNetworkResourceId: string;
}


// Warnings were encountered during analysis:
//
// src/models/index.ts:2308:5 - (ae-forgotten-export) The symbol "LROResponseInfo" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
