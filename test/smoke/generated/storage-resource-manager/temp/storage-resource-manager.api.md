## API Report File for "storage-resource-manager"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as coreHttp from '@azure/core-http';
import { HttpMethods } from '@azure/core-http';
import { OperationArguments } from '@azure/core-http';
import { OperationSpec } from '@azure/core-http';
import { Poller } from '@azure/core-lro';
import { PollOperationState } from '@azure/core-lro';
import { RestResponse } from '@azure/core-http';

// @public
export type AccessTier = "Hot" | "Cool";

// @public
export interface AccountSasParameters {
    iPAddressOrRange?: string;
    keyToSign?: string;
    permissions: Permissions_2;
    protocols?: HttpProtocol;
    resourceTypes: SignedResourceTypes;
    services: Services;
    sharedAccessExpiryTime: Date;
    sharedAccessStartTime?: Date;
}

// @public
export type AccountStatus = "available" | "unavailable";

// @public
export interface ActiveDirectoryProperties {
    azureStorageSid: string;
    domainGuid: string;
    domainName: string;
    domainSid: string;
    forestName: string;
    netBiosDomainName: string;
}

// @public
export type AzureEntityResource = Resource & {
    readonly etag?: string;
};

// @public
export interface AzureFilesIdentityBasedAuthentication {
    activeDirectoryProperties?: ActiveDirectoryProperties;
    directoryServiceOptions: DirectoryServiceOptions;
}

// @public
export type BlobContainer = AzureEntityResource & {
    defaultEncryptionScope?: string;
    denyEncryptionScopeOverride?: boolean;
    publicAccess?: PublicAccess;
    readonly lastModifiedTime?: Date;
    readonly leaseStatus?: LeaseStatus;
    readonly leaseState?: LeaseState;
    readonly leaseDuration?: LeaseDuration;
    metadata?: {
        [propertyName: string]: string;
    };
    readonly immutabilityPolicy?: ImmutabilityPolicyProperties;
    readonly legalHold?: LegalHoldProperties;
    readonly hasLegalHold?: boolean;
    readonly hasImmutabilityPolicy?: boolean;
};

// @public
export type BlobContainersClearLegalHoldResponse = LegalHold & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: LegalHold;
    };
};

// @public
export interface BlobContainersCreateOrUpdateImmutabilityPolicyHeaders {
    eTag?: string;
}

// @public
export interface BlobContainersCreateOrUpdateImmutabilityPolicyOptionalParams extends coreHttp.OperationOptions {
    ifMatch?: string;
    parameters?: ImmutabilityPolicy;
}

// @public
export type BlobContainersCreateOrUpdateImmutabilityPolicyResponse = BlobContainersCreateOrUpdateImmutabilityPolicyHeaders & ImmutabilityPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ImmutabilityPolicy;
        parsedHeaders: BlobContainersCreateOrUpdateImmutabilityPolicyHeaders;
    };
};

// @public
export type BlobContainersCreateResponse = BlobContainer & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: BlobContainer;
    };
};

// @public
export interface BlobContainersDeleteImmutabilityPolicyHeaders {
    eTag?: string;
}

// @public
export type BlobContainersDeleteImmutabilityPolicyResponse = BlobContainersDeleteImmutabilityPolicyHeaders & ImmutabilityPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ImmutabilityPolicy;
        parsedHeaders: BlobContainersDeleteImmutabilityPolicyHeaders;
    };
};

// @public
export interface BlobContainersExtendImmutabilityPolicyHeaders {
    eTag?: string;
}

// @public
export interface BlobContainersExtendImmutabilityPolicyOptionalParams extends coreHttp.OperationOptions {
    parameters?: ImmutabilityPolicy;
}

// @public
export type BlobContainersExtendImmutabilityPolicyResponse = BlobContainersExtendImmutabilityPolicyHeaders & ImmutabilityPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ImmutabilityPolicy;
        parsedHeaders: BlobContainersExtendImmutabilityPolicyHeaders;
    };
};

// @public
export interface BlobContainersGetImmutabilityPolicyHeaders {
    eTag?: string;
}

// @public
export interface BlobContainersGetImmutabilityPolicyOptionalParams extends coreHttp.OperationOptions {
    ifMatch?: string;
}

// @public
export type BlobContainersGetImmutabilityPolicyResponse = BlobContainersGetImmutabilityPolicyHeaders & ImmutabilityPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ImmutabilityPolicy;
        parsedHeaders: BlobContainersGetImmutabilityPolicyHeaders;
    };
};

// @public
export type BlobContainersGetResponse = BlobContainer & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: BlobContainer;
    };
};

// @public
export interface BlobContainersLeaseOptionalParams extends coreHttp.OperationOptions {
    parameters?: LeaseContainerRequest;
}

// @public
export type BlobContainersLeaseResponse = LeaseContainerResponse & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: LeaseContainerResponse;
    };
};

// @public
export interface BlobContainersListNextOptionalParams extends coreHttp.OperationOptions {
    filter?: string;
    maxpagesize?: string;
}

// @public
export type BlobContainersListNextResponse = ListContainerItems & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ListContainerItems;
    };
};

// @public
export interface BlobContainersListOptionalParams extends coreHttp.OperationOptions {
    filter?: string;
    maxpagesize?: string;
}

// @public
export type BlobContainersListResponse = ListContainerItems & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ListContainerItems;
    };
};

// @public
export interface BlobContainersLockImmutabilityPolicyHeaders {
    eTag?: string;
}

// @public
export type BlobContainersLockImmutabilityPolicyResponse = BlobContainersLockImmutabilityPolicyHeaders & ImmutabilityPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ImmutabilityPolicy;
        parsedHeaders: BlobContainersLockImmutabilityPolicyHeaders;
    };
};

// @public
export type BlobContainersSetLegalHoldResponse = LegalHold & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: LegalHold;
    };
};

// @public
export type BlobContainersUpdateResponse = BlobContainer & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: BlobContainer;
    };
};

// @public
export interface BlobRestoreParameters {
    blobRanges: BlobRestoreRange[];
    timeToRestore: Date;
}

// @public
export type BlobRestoreProgressStatus = "InProgress" | "Complete" | "Failed";

// @public
export interface BlobRestoreRange {
    endRange: string;
    startRange: string;
}

// @public
export interface BlobRestoreStatus {
    readonly failureReason?: string;
    readonly parameters?: BlobRestoreParameters;
    readonly restoreId?: string;
    readonly status?: BlobRestoreProgressStatus;
}

// @public (undocumented)
export interface BlobServiceItems {
    readonly value?: BlobServiceProperties[];
}

// @public
export type BlobServiceProperties = Resource & {
    readonly sku?: Sku;
    cors?: CorsRules;
    defaultServiceVersion?: string;
    deleteRetentionPolicy?: DeleteRetentionPolicy;
    isVersioningEnabled?: boolean;
    automaticSnapshotPolicyEnabled?: boolean;
    changeFeed?: ChangeFeed;
    restorePolicy?: RestorePolicyProperties;
    containerDeleteRetentionPolicy?: DeleteRetentionPolicy;
};

// @public
export type BlobServicesGetServicePropertiesResponse = BlobServiceProperties & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: BlobServiceProperties;
    };
};

// @public
export type BlobServicesListResponse = BlobServiceItems & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: BlobServiceItems;
    };
};

// @public
export type BlobServicesSetServicePropertiesResponse = BlobServiceProperties & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: BlobServiceProperties;
    };
};

// @public
export type Bypass = "None" | "Logging" | "Metrics" | "AzureServices";

// @public
export interface ChangeFeed {
    enabled?: boolean;
}

// @public
export interface CheckNameAvailabilityResult {
    readonly message?: string;
    readonly nameAvailable?: boolean;
    readonly reason?: Reason;
}

// @public
export interface CloudError {
    error?: CloudErrorBody;
}

// @public
export interface CloudErrorBody {
    code?: string;
    details?: CloudErrorBody[];
    message?: string;
    target?: string;
}

// @public
export interface CorsRule {
    allowedHeaders: string[];
    allowedMethods: CorsRuleAllowedMethodsItem[];
    allowedOrigins: string[];
    exposedHeaders: string[];
    maxAgeInSeconds: number;
}

// @public
export type CorsRuleAllowedMethodsItem = "DELETE" | "GET" | "HEAD" | "MERGE" | "POST" | "OPTIONS" | "PUT";

// @public
export interface CorsRules {
    corsRules?: CorsRule[];
}

// @public
export interface CustomDomain {
    name: string;
    useSubDomainName?: boolean;
}

// @public
export interface DateAfterCreation {
    daysAfterCreationGreaterThan: number;
}

// @public
export interface DateAfterModification {
    daysAfterModificationGreaterThan: number;
}

// @public
export type DefaultAction = "Allow" | "Deny";

// @public
export interface DeletedShare {
    deletedShareName: string;
    deletedShareVersion: string;
}

// @public
export interface DeleteRetentionPolicy {
    days?: number;
    enabled?: boolean;
}

// @public
export interface Dimension {
    displayName?: string;
    name?: string;
}

// @public
export type DirectoryServiceOptions = "None" | "AADDS" | "AD";

// @public
export type EnabledProtocols = "SMB" | "NFS";

// @public
export interface Encryption {
    keySource: KeySource;
    keyVaultProperties?: KeyVaultProperties;
    services?: EncryptionServices;
}

// @public
export type EncryptionScope = Resource & {
    source?: EncryptionScopeSource;
    state?: EncryptionScopeState;
    readonly creationTime?: Date;
    readonly lastModifiedTime?: Date;
    keyVaultProperties?: EncryptionScopeKeyVaultProperties;
};

// @public
export interface EncryptionScopeKeyVaultProperties {
    keyUri?: string;
}

// @public
export interface EncryptionScopeListResult {
    readonly nextLink?: string;
    readonly value?: EncryptionScope[];
}

// @public
export type EncryptionScopesGetResponse = EncryptionScope & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: EncryptionScope;
    };
};

// @public
export type EncryptionScopesListNextResponse = EncryptionScopeListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: EncryptionScopeListResult;
    };
};

// @public
export type EncryptionScopesListResponse = EncryptionScopeListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: EncryptionScopeListResult;
    };
};

// @public
export type EncryptionScopeSource = "Microsoft.Storage" | "Microsoft.KeyVault";

// @public
export type EncryptionScopesPatchResponse = EncryptionScope & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: EncryptionScope;
    };
};

// @public
export type EncryptionScopesPutResponse = EncryptionScope & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: EncryptionScope;
    };
};

// @public
export type EncryptionScopeState = "Enabled" | "Disabled";

// @public
export interface EncryptionService {
    enabled?: boolean;
    keyType?: KeyType_2;
    readonly lastEnabledTime?: Date;
}

// @public
export interface EncryptionServices {
    blob?: EncryptionService;
    file?: EncryptionService;
    queue?: EncryptionService;
    table?: EncryptionService;
}

// @public
export interface Endpoints {
    readonly blob?: string;
    readonly dfs?: string;
    readonly file?: string;
    internetEndpoints?: StorageAccountInternetEndpoints;
    microsoftEndpoints?: StorageAccountMicrosoftEndpoints;
    readonly queue?: string;
    readonly table?: string;
    readonly web?: string;
}

// @public
export interface ErrorResponse {
    code?: string;
    message?: string;
}

// @public (undocumented)
export interface FileServiceItems {
    readonly value?: FileServiceProperties[];
}

// @public
export type FileServiceProperties = Resource & {
    readonly sku?: Sku;
    cors?: CorsRules;
    shareDeleteRetentionPolicy?: DeleteRetentionPolicy;
};

// @public
export type FileServicesGetServicePropertiesResponse = FileServiceProperties & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: FileServiceProperties;
    };
};

// @public
export type FileServicesListResponse = FileServiceItems & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: FileServiceItems;
    };
};

// @public
export type FileServicesSetServicePropertiesResponse = FileServiceProperties & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: FileServiceProperties;
    };
};

// @public
export type FileShare = AzureEntityResource & {
    readonly lastModifiedTime?: Date;
    metadata?: {
        [propertyName: string]: string;
    };
    shareQuota?: number;
    enabledProtocols?: EnabledProtocols;
    rootSquash?: RootSquashType;
    readonly version?: string;
    readonly deleted?: boolean;
    readonly deletedTime?: Date;
    readonly remainingRetentionDays?: number;
    accessTier?: ShareAccessTier;
    readonly accessTierChangeTime?: Date;
    readonly accessTierStatus?: string;
    readonly shareUsageBytes?: number;
};

// @public
export type FileShareItem = AzureEntityResource & {
    readonly lastModifiedTime?: Date;
    metadata?: {
        [propertyName: string]: string;
    };
    shareQuota?: number;
    enabledProtocols?: EnabledProtocols;
    rootSquash?: RootSquashType;
    readonly version?: string;
    readonly deleted?: boolean;
    readonly deletedTime?: Date;
    readonly remainingRetentionDays?: number;
    accessTier?: ShareAccessTier;
    readonly accessTierChangeTime?: Date;
    readonly accessTierStatus?: string;
    readonly shareUsageBytes?: number;
};

// @public
export interface FileShareItems {
    readonly nextLink?: string;
    readonly value?: FileShareItem[];
}

// @public
export type FileSharesCreateResponse = FileShare & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: FileShare;
    };
};

// @public
export type FileSharesGetResponse = FileShare & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: FileShare;
    };
};

// @public
export interface FileSharesListNextOptionalParams extends coreHttp.OperationOptions {
    filter?: string;
    maxpagesize?: string;
}

// @public
export type FileSharesListNextResponse = FileShareItems & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: FileShareItems;
    };
};

// @public
export interface FileSharesListOptionalParams extends coreHttp.OperationOptions {
    filter?: string;
    maxpagesize?: string;
}

// @public
export type FileSharesListResponse = FileShareItems & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: FileShareItems;
    };
};

// @public
export type FileSharesUpdateResponse = FileShare & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: FileShare;
    };
};

// @public
export interface GeoReplicationStats {
    readonly canFailover?: boolean;
    readonly lastSyncTime?: Date;
    readonly status?: GeoReplicationStatus;
}

// @public
export type GeoReplicationStatus = "Live" | "Bootstrap" | "Unavailable";

// @public
export type HttpProtocol = "https,http" | "https";

// @public
export interface Identity {
    readonly principalId?: string;
    readonly tenantId?: string;
    type: "SystemAssigned";
}

// @public
export type ImmutabilityPolicy = AzureEntityResource & {
    immutabilityPeriodSinceCreationInDays?: number;
    readonly state?: ImmutabilityPolicyState;
    allowProtectedAppendWrites?: boolean;
};

// @public
export interface ImmutabilityPolicyProperties {
    allowProtectedAppendWrites?: boolean;
    readonly etag?: string;
    immutabilityPeriodSinceCreationInDays?: number;
    readonly state?: ImmutabilityPolicyState;
    readonly updateHistory?: UpdateHistoryProperty[];
}

// @public
export type ImmutabilityPolicyState = "Locked" | "Unlocked";

// @public
export type ImmutabilityPolicyUpdateType = "put" | "lock" | "extend";

// @public
export interface IPRule {
    action?: "Allow";
    iPAddressOrRange: string;
}

// @public
export type KeyPermission = "Read" | "Full";

// @public
export type KeySource = "Microsoft.Storage" | "Microsoft.Keyvault";

// @public
type KeyType_2 = "Service" | "Account";

export { KeyType_2 as KeyType }

// @public
export interface KeyVaultProperties {
    readonly currentVersionedKeyIdentifier?: string;
    keyName?: string;
    keyVaultUri?: string;
    keyVersion?: string;
    readonly lastKeyRotationTimestamp?: Date;
}

// @public
export type Kind = "Storage" | "StorageV2" | "BlobStorage" | "FileStorage" | "BlockBlobStorage";

// @public
export type LargeFileSharesState = "Disabled" | "Enabled";

// @public
export interface LeaseContainerRequest {
    action: LeaseContainerRequestAction;
    breakPeriod?: number;
    leaseDuration?: number;
    leaseId?: string;
    proposedLeaseId?: string;
}

// @public
export type LeaseContainerRequestAction = "Acquire" | "Renew" | "Change" | "Release" | "Break";

// @public
export interface LeaseContainerResponse {
    leaseId?: string;
    leaseTimeSeconds?: string;
}

// @public
export type LeaseDuration = "Infinite" | "Fixed";

// @public
export type LeaseState = "Available" | "Leased" | "Expired" | "Breaking" | "Broken";

// @public
export type LeaseStatus = "Locked" | "Unlocked";

// @public
export interface LegalHold {
    readonly hasLegalHold?: boolean;
    tags: string[];
}

// @public
export interface LegalHoldProperties {
    readonly hasLegalHold?: boolean;
    tags?: TagProperty[];
}

// @public
export interface ListAccountSasResponse {
    readonly accountSasToken?: string;
}

// @public
export type ListContainerItem = AzureEntityResource & {
    defaultEncryptionScope?: string;
    denyEncryptionScopeOverride?: boolean;
    publicAccess?: PublicAccess;
    readonly lastModifiedTime?: Date;
    readonly leaseStatus?: LeaseStatus;
    readonly leaseState?: LeaseState;
    readonly leaseDuration?: LeaseDuration;
    metadata?: {
        [propertyName: string]: string;
    };
    readonly immutabilityPolicy?: ImmutabilityPolicyProperties;
    readonly legalHold?: LegalHoldProperties;
    readonly hasLegalHold?: boolean;
    readonly hasImmutabilityPolicy?: boolean;
};

// @public
export interface ListContainerItems {
    readonly nextLink?: string;
    readonly value?: ListContainerItem[];
}

// @public
export interface ListServiceSasResponse {
    readonly serviceSasToken?: string;
}

// @public
export type ManagementPoliciesCreateOrUpdateResponse = ManagementPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagementPolicy;
    };
};

// @public
export type ManagementPoliciesGetResponse = ManagementPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ManagementPolicy;
    };
};

// @public
export type ManagementPolicy = Resource & {
    readonly lastModifiedTime?: Date;
    policy?: ManagementPolicySchema;
};

// @public
export interface ManagementPolicyAction {
    baseBlob?: ManagementPolicyBaseBlob;
    snapshot?: ManagementPolicySnapShot;
}

// @public
export interface ManagementPolicyBaseBlob {
    delete?: DateAfterModification;
    tierToArchive?: DateAfterModification;
    tierToCool?: DateAfterModification;
}

// @public
export interface ManagementPolicyDefinition {
    actions: ManagementPolicyAction;
    filters?: ManagementPolicyFilter;
}

// @public
export interface ManagementPolicyFilter {
    blobIndexMatch?: TagFilter[];
    blobTypes: string[];
    prefixMatch?: string[];
}

// @public
export type ManagementPolicyName = "default";

// @public
export interface ManagementPolicyRule {
    definition: ManagementPolicyDefinition;
    enabled?: boolean;
    name: string;
    type: RuleType;
}

// @public
export interface ManagementPolicySchema {
    rules: ManagementPolicyRule[];
}

// @public
export interface ManagementPolicySnapShot {
    delete?: DateAfterCreation;
}

// @public
export interface MetricSpecification {
    aggregationType?: string;
    category?: string;
    dimensions?: Dimension[];
    displayDescription?: string;
    displayName?: string;
    fillGapWithZero?: boolean;
    name?: string;
    resourceIdDimensionNameOverride?: string;
    unit?: string;
}

// @public
export interface NetworkRuleSet {
    bypass?: Bypass;
    defaultAction: DefaultAction;
    ipRules?: IPRule[];
    virtualNetworkRules?: VirtualNetworkRule[];
}

// @public
export interface ObjectReplicationPolicies {
    value?: ObjectReplicationPolicy[];
}

// @public
export type ObjectReplicationPoliciesCreateOrUpdateResponse = ObjectReplicationPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ObjectReplicationPolicy;
    };
};

// @public
export type ObjectReplicationPoliciesGetResponse = ObjectReplicationPolicy & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ObjectReplicationPolicy;
    };
};

// @public
export type ObjectReplicationPoliciesListResponse = ObjectReplicationPolicies & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ObjectReplicationPolicies;
    };
};

// @public
export type ObjectReplicationPolicy = Resource & {
    readonly policyId?: string;
    readonly enabledTime?: Date;
    sourceAccount?: string;
    destinationAccount?: string;
    rules?: ObjectReplicationPolicyRule[];
};

// @public
export interface ObjectReplicationPolicyFilter {
    minCreationTime?: string;
    prefixMatch?: string[];
}

// @public
export interface ObjectReplicationPolicyRule {
    destinationContainer: string;
    filters?: ObjectReplicationPolicyFilter;
    ruleId?: string;
    sourceContainer: string;
}

// @public
export interface Operation {
    display?: OperationDisplay;
    name?: string;
    origin?: string;
    serviceSpecification?: ServiceSpecification;
}

// @public
export interface OperationDisplay {
    description?: string;
    operation?: string;
    provider?: string;
    resource?: string;
}

// @public
export interface OperationListResult {
    value?: Operation[];
}

// @public
export type OperationsListResponse = OperationListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: OperationListResult;
    };
};

// @public
type Permissions_2 = "r" | "d" | "w" | "l" | "a" | "c" | "u" | "p";

export { Permissions_2 as Permissions }

// @public
export interface PrivateEndpoint {
    readonly id?: string;
}

// @public
export type PrivateEndpointConnection = Resource & {
    privateEndpoint?: PrivateEndpoint;
    privateLinkServiceConnectionState?: PrivateLinkServiceConnectionState;
    readonly provisioningState?: PrivateEndpointConnectionProvisioningState;
};

// @public
export interface PrivateEndpointConnectionListResult {
    value?: PrivateEndpointConnection[];
}

// @public
export type PrivateEndpointConnectionProvisioningState = "Succeeded" | "Creating" | "Deleting" | "Failed";

// @public
export type PrivateEndpointConnectionsGetResponse = PrivateEndpointConnection & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: PrivateEndpointConnection;
    };
};

// @public
export type PrivateEndpointConnectionsListResponse = PrivateEndpointConnectionListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: PrivateEndpointConnectionListResult;
    };
};

// @public
export type PrivateEndpointConnectionsPutResponse = PrivateEndpointConnection & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: PrivateEndpointConnection;
    };
};

// @public
export type PrivateEndpointServiceConnectionStatus = "Pending" | "Approved" | "Rejected";

// @public
export type PrivateLinkResource = Resource & {
    readonly groupId?: string;
    readonly requiredMembers?: string[];
    requiredZoneNames?: string[];
};

// @public
export interface PrivateLinkResourceListResult {
    value?: PrivateLinkResource[];
}

// @public
export type PrivateLinkResourcesListByStorageAccountResponse = PrivateLinkResourceListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: PrivateLinkResourceListResult;
    };
};

// @public
export interface PrivateLinkServiceConnectionState {
    actionRequired?: string;
    description?: string;
    status?: PrivateEndpointServiceConnectionStatus;
}

// @public
export type ProvisioningState = "Creating" | "ResolvingDNS" | "Succeeded";

// @public
export type PublicAccess = "Container" | "Blob" | "None";

// @public
export type Reason = "AccountNameInvalid" | "AlreadyExists";

// @public
export type ReasonCode = "QuotaId" | "NotAvailableForSubscription";

// @public (undocumented)
export interface Resource {
    readonly id?: string;
    readonly name?: string;
    readonly type?: string;
}

// @public
export interface RestorePolicyProperties {
    days?: number;
    enabled: boolean;
    readonly lastEnabledTime?: Date;
}

// @public
export interface Restriction {
    reasonCode?: ReasonCode;
    readonly type?: string;
    readonly values?: string[];
}

// @public
export type RootSquashType = "NoRootSquash" | "RootSquash" | "AllSquash";

// @public
export type RoutingChoice = "MicrosoftRouting" | "InternetRouting";

// @public
export interface RoutingPreference {
    publishInternetEndpoints?: boolean;
    publishMicrosoftEndpoints?: boolean;
    routingChoice?: RoutingChoice;
}

// @public
export type RuleType = "Lifecycle";

// @public
export type Services = "b" | "q" | "t" | "f";

// @public
export interface ServiceSasParameters {
    cacheControl?: string;
    canonicalizedResource: string;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentType?: string;
    identifier?: string;
    iPAddressOrRange?: string;
    keyToSign?: string;
    partitionKeyEnd?: string;
    partitionKeyStart?: string;
    permissions?: Permissions_2;
    protocols?: HttpProtocol;
    resource?: SignedResource;
    rowKeyEnd?: string;
    rowKeyStart?: string;
    sharedAccessExpiryTime?: Date;
    sharedAccessStartTime?: Date;
}

// @public
export interface ServiceSpecification {
    metricSpecifications?: MetricSpecification[];
}

// @public
export type ShareAccessTier = "TransactionOptimized" | "Hot" | "Cool" | "Premium";

// @public
export type SignedResource = "b" | "c" | "f" | "s";

// @public
export type SignedResourceTypes = "s" | "c" | "o";

// @public
export interface Sku {
    name: SkuName;
    readonly tier?: SkuTier;
}

// @public
export interface SKUCapability {
    readonly name?: string;
    readonly value?: string;
}

// @public
export interface SkuInformation {
    readonly capabilities?: SKUCapability[];
    readonly kind?: Kind;
    readonly locations?: string[];
    name: SkuName;
    readonly resourceType?: string;
    restrictions?: Restriction[];
    readonly tier?: SkuTier;
}

// @public
export type SkuName = "Standard_LRS" | "Standard_GRS" | "Standard_RAGRS" | "Standard_ZRS" | "Premium_LRS" | "Premium_ZRS" | "Standard_GZRS" | "Standard_RAGZRS";

// @public
export type SkusListResponse = StorageSkuListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: StorageSkuListResult;
    };
};

// @public
export type SkuTier = "Standard" | "Premium";

// @public
export type State = "provisioning" | "deprovisioning" | "succeeded" | "failed" | "networkSourceDeleted";

// @public
export type StorageAccount = TrackedResource & {
    readonly sku?: Sku;
    readonly kind?: Kind;
    identity?: Identity;
    readonly provisioningState?: ProvisioningState;
    readonly primaryEndpoints?: Endpoints;
    readonly primaryLocation?: string;
    readonly statusOfPrimary?: AccountStatus;
    readonly lastGeoFailoverTime?: Date;
    readonly secondaryLocation?: string;
    readonly statusOfSecondary?: AccountStatus;
    readonly creationTime?: Date;
    readonly customDomain?: CustomDomain;
    readonly secondaryEndpoints?: Endpoints;
    readonly encryption?: Encryption;
    readonly accessTier?: AccessTier;
    azureFilesIdentityBasedAuthentication?: AzureFilesIdentityBasedAuthentication;
    enableHttpsTrafficOnly?: boolean;
    readonly networkRuleSet?: NetworkRuleSet;
    isHnsEnabled?: boolean;
    readonly geoReplicationStats?: GeoReplicationStats;
    readonly failoverInProgress?: boolean;
    largeFileSharesState?: LargeFileSharesState;
    readonly privateEndpointConnections?: PrivateEndpointConnection[];
    routingPreference?: RoutingPreference;
    readonly blobRestoreStatus?: BlobRestoreStatus;
};

// @public
export interface StorageAccountCheckNameAvailabilityParameters {
    name: string;
    type: "Microsoft.Storage/storageAccounts";
}

// @public
export interface StorageAccountCreateParameters {
    accessTier?: AccessTier;
    azureFilesIdentityBasedAuthentication?: AzureFilesIdentityBasedAuthentication;
    customDomain?: CustomDomain;
    enableHttpsTrafficOnly?: boolean;
    encryption?: Encryption;
    identity?: Identity;
    isHnsEnabled?: boolean;
    kind: Kind;
    largeFileSharesState?: LargeFileSharesState;
    location: string;
    networkRuleSet?: NetworkRuleSet;
    routingPreference?: RoutingPreference;
    sku: Sku;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export type StorageAccountExpand = "geoReplicationStats" | "blobRestoreStatus";

// @public
export interface StorageAccountInternetEndpoints {
    readonly blob?: string;
    readonly dfs?: string;
    readonly file?: string;
    readonly web?: string;
}

// @public
export interface StorageAccountKey {
    readonly keyName?: string;
    readonly permissions?: KeyPermission;
    readonly value?: string;
}

// @public
export interface StorageAccountListKeysResult {
    readonly keys?: StorageAccountKey[];
}

// @public
export interface StorageAccountListResult {
    readonly nextLink?: string;
    readonly value?: StorageAccount[];
}

// @public
export interface StorageAccountMicrosoftEndpoints {
    readonly blob?: string;
    readonly dfs?: string;
    readonly file?: string;
    readonly queue?: string;
    readonly table?: string;
    readonly web?: string;
}

// @public
export interface StorageAccountRegenerateKeyParameters {
    keyName: string;
}

// @public
export type StorageAccountsCheckNameAvailabilityResponse = CheckNameAvailabilityResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: CheckNameAvailabilityResult;
    };
};

// @public
export type StorageAccountsCreateResponse = StorageAccount & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: StorageAccount;
    };
};

// @public
export interface StorageAccountsGetPropertiesOptionalParams extends coreHttp.OperationOptions {
    expand?: StorageAccountExpand;
}

// @public
export type StorageAccountsGetPropertiesResponse = StorageAccount & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: StorageAccount;
    };
};

// @public
export type StorageAccountsListAccountSASResponse = ListAccountSasResponse & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ListAccountSasResponse;
    };
};

// @public
export type StorageAccountsListByResourceGroupResponse = StorageAccountListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: StorageAccountListResult;
    };
};

// @public
export type StorageAccountsListKeysResponse = StorageAccountListKeysResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: StorageAccountListKeysResult;
    };
};

// @public
export type StorageAccountsListNextResponse = StorageAccountListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: StorageAccountListResult;
    };
};

// @public
export type StorageAccountsListResponse = StorageAccountListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: StorageAccountListResult;
    };
};

// @public
export type StorageAccountsListServiceSASResponse = ListServiceSasResponse & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ListServiceSasResponse;
    };
};

// @public
export type StorageAccountsRegenerateKeyResponse = StorageAccountListKeysResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: StorageAccountListKeysResult;
    };
};

// @public
export type StorageAccountsRestoreBlobRangesResponse = BlobRestoreStatus & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: BlobRestoreStatus;
    };
};

// @public
export type StorageAccountsUpdateResponse = StorageAccount & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: StorageAccount;
    };
};

// @public
export interface StorageAccountUpdateParameters {
    accessTier?: AccessTier;
    azureFilesIdentityBasedAuthentication?: AzureFilesIdentityBasedAuthentication;
    customDomain?: CustomDomain;
    enableHttpsTrafficOnly?: boolean;
    encryption?: Encryption;
    identity?: Identity;
    kind?: Kind;
    largeFileSharesState?: LargeFileSharesState;
    networkRuleSet?: NetworkRuleSet;
    routingPreference?: RoutingPreference;
    sku?: Sku;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public (undocumented)
export class StorageManagementClient extends StorageManagementClientContext {
    constructor(credentials: coreHttp.TokenCredential | coreHttp.ServiceClientCredentials, subscriptionId: string, options?: StorageManagementClientOptionalParams);
    // Warning: (ae-forgotten-export) The symbol "BlobContainers" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    blobContainers: BlobContainers;
    // Warning: (ae-forgotten-export) The symbol "BlobServices" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    blobServices: BlobServices;
    // Warning: (ae-forgotten-export) The symbol "EncryptionScopes" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    encryptionScopes: EncryptionScopes;
    // Warning: (ae-forgotten-export) The symbol "FileServices" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    fileServices: FileServices;
    // Warning: (ae-forgotten-export) The symbol "FileShares" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    fileShares: FileShares;
    // Warning: (ae-forgotten-export) The symbol "ManagementPolicies" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    managementPolicies: ManagementPolicies;
    // Warning: (ae-forgotten-export) The symbol "ObjectReplicationPolicies" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    objectReplicationPolicies: ObjectReplicationPolicies_2;
    // Warning: (ae-forgotten-export) The symbol "Operations" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    operations: Operations;
    // Warning: (ae-forgotten-export) The symbol "PrivateEndpointConnections" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    privateEndpointConnections: PrivateEndpointConnections;
    // Warning: (ae-forgotten-export) The symbol "PrivateLinkResources" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    privateLinkResources: PrivateLinkResources;
    // Warning: (ae-forgotten-export) The symbol "Skus" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    skus: Skus;
    // Warning: (ae-forgotten-export) The symbol "StorageAccounts" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    storageAccounts: StorageAccounts;
    // Warning: (ae-forgotten-export) The symbol "Usages" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    usages: Usages;
}

// @public (undocumented)
export class StorageManagementClientContext extends coreHttp.ServiceClient {
    // (undocumented)
    $host: string;
    constructor(credentials: coreHttp.TokenCredential | coreHttp.ServiceClientCredentials, subscriptionId: string, options?: StorageManagementClientOptionalParams);
    // (undocumented)
    apiVersion: string;
    // (undocumented)
    subscriptionId: string;
}

// @public
export interface StorageManagementClientOptionalParams extends coreHttp.ServiceClientOptions {
    $host?: string;
    apiVersion?: string;
    endpoint?: string;
}

// @public
export interface StorageSkuListResult {
    readonly value?: SkuInformation[];
}

// @public
export interface TagFilter {
    name: string;
    op: string;
    value: string;
}

// @public
export interface TagProperty {
    readonly objectIdentifier?: string;
    readonly tag?: string;
    readonly tenantId?: string;
    readonly timestamp?: Date;
    readonly upn?: string;
}

// @public
export type TrackedResource = Resource & {
    tags?: {
        [propertyName: string]: string;
    };
    location: string;
};

// @public
export interface UpdateHistoryProperty {
    readonly immutabilityPeriodSinceCreationInDays?: number;
    readonly objectIdentifier?: string;
    readonly tenantId?: string;
    readonly timestamp?: Date;
    readonly update?: ImmutabilityPolicyUpdateType;
    readonly upn?: string;
}

// @public
export interface Usage {
    readonly currentValue?: number;
    readonly limit?: number;
    readonly name?: UsageName;
    readonly unit?: UsageUnit;
}

// @public
export interface UsageListResult {
    value?: Usage[];
}

// @public
export interface UsageName {
    readonly localizedValue?: string;
    readonly value?: string;
}

// @public
export type UsagesListByLocationResponse = UsageListResult & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: UsageListResult;
    };
};

// @public
export type UsageUnit = "Count" | "Bytes" | "Seconds" | "Percent" | "CountsPerSecond" | "BytesPerSecond";

// @public
export interface VirtualNetworkRule {
    action?: "Allow";
    state?: State;
    virtualNetworkResourceId: string;
}


// (No @packageDocumentation comment for this package)

```
